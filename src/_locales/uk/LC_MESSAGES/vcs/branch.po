# Copyright (C) 2023, Python training course authors and contributors
# This file is distributed under the same license as the Python Training
# Course package.
# SERHII HORODILOV <sgorodil@gmail.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: Python Training Course 2023.06.dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-10-05 19:49+0300\n"
"PO-Revision-Date: 2023-10-05 20:17+0300\n"
"Last-Translator: Serhii Horodilov <sgorodil@gmail.com>\n"
"Language-Team: uk <LL@li.org>\n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"Generated-By: Babel 2.13.0\n"
"X-Generator: Poedit 3.4\n"

#: ../../src/vcs/branch.txt:-1
msgid "Version control system"
msgstr "Система контролю версій"

#: ../../src/vcs/branch.txt:-1
msgid "Serhii Horodilov"
msgstr "Serhii Horodilov"

#: ../../src/vcs/branch.txt:-1
msgid "version, control, system, vcs, git, branch, merge, cherry-pick"
msgstr "version, control, system, vcs, git, branch, merge, cherry-pick"

#: ../../src/vcs/branch.txt:8
msgid "Branches and Merging"
msgstr "Гілки та злиття"

#: ../../src/vcs/branch.txt:11
msgid "About branches"
msgstr "Про гілки"

#: ../../src/vcs/branch.txt:13
msgid ""
"To really understand the way Git does branching, we need to take a step back "
"and examine how Git stores its data. Git doesn't store data as a series of "
"changesets or differences, but instead as a series of snapshots. When you "
"make a commit, Git stores a commit object that contains a pointer to the "
"snapshot of the content you staged. This object also contains the author's "
"name and email address, the message that you typed, and pointers to the "
"commit or commits that directly came before this commit (its parent or "
"parents): zero parents for the initial commit, one parent for a normal "
"commit, and multiple parents for a commit that results from a merge of two "
"or more branches."
msgstr ""
"Щоб по-справжньому зрозуміти, як Git працює з розгалуженнями, нам потрібно "
"зробити крок назад і розглянути, як Git зберігає свої дані. Git зберігає "
"дані не у вигляді серії наборів змін або відмінностей, а у вигляді серії "
"знімків. Коли ви робите коміт, Git зберігає об'єкт коміту, який містить "
"вказівник на створений вами знімок вмісту. Цей об'єкт також містить ім'я та "
"адресу електронної пошти автора, повідомлення, яке ви набрали, і вказівники "
"на комміт або комміти, які безпосередньо передували цьому комміту (його "
"батька або батьків): нульовий батько для початкового комміту, один батько "
"для звичайного комміту і кілька батьків для комміту, який є результатом "
"злиття двох або більше гілок."

#: ../../src/vcs/branch.txt:28
msgid ""
"A branch in Git is simply a lightweight movable pointer to one of these "
"commits. The default branch name in Git is master. As you start making "
"commits, you're given a master branch that points to the last commit you "
"made. Every time you commit, the master branch pointer moves forward "
"automatically."
msgstr ""
"Гілка в Git'і - це просто легкий рухомий вказівник на одну з цих коммітів. "
"Стандартна назва гілки у Git'і - master. Коли ви починаєте робити комміти, "
"ви отримуєте головну гілку, яка вказує на останній зроблений вами комміт. "
"Кожного разу, коли ви робите комміт, вказівник головної гілки автоматично "
"пересувається вперед."

#: ../../src/vcs/branch.txt:38
msgid "Branch management"
msgstr "Управління гілками"

#: ../../src/vcs/branch.txt:40
msgid ""
"The ``git branch`` command does more that create and delete branches. If you "
"run it with no arguments, you get a simple listing of your current branches:"
msgstr ""
"Команда ``git branch`` робить більше, ніж просто створює і видаляє гілки. "
"Якщо ви запустите її без аргументів, ви отримаєте простий список ваших "
"поточних гілок:"

#: ../../src/vcs/branch.txt:55
msgid ""
"To see all the branches that contain work you haven't yet merged in, use ``--"
"no-merged`` option:"
msgstr ""
"Щоб побачити всі гілки, які містять роботи, до яких ви ще не приєдналися, "
"використовуйте опцію ``--no-merged``:"

#: ../../src/vcs/branch.txt:65
msgid ""
"Branches listed in the output has work, that isn't merged to current branch. "
"So, deleting them via ``git branch -d`` will fail."
msgstr ""
"У гілках, перелічених у виводі, є напрацювання, які не злито з поточною "
"гілкою. Отже, їх видалення за допомогою ``git branch -d`` не спрацює."

#: ../../src/vcs/branch.txt:69
msgid "Create branches"
msgstr "Створення гілок"

#: ../../src/vcs/branch.txt:71
msgid ""
"There are few ways to create a new branch in a Git repository. The most "
"common way is to use ``git branch`` command."
msgstr ""
"Існує декілька способів створити нову гілку в Git-сховищі. Найпоширеніший з "
"них - використання команди ``git branch``."

#: ../../src/vcs/branch.txt:78
msgid ""
"Pointer to a parent commit is optional. By default the parent commit is set "
"to the latest one available (HEAD pointer) at the moment of the branch "
"creation. You can also switch to the newly created branch just after its "
"creation using:"
msgstr ""
"Вказівник на батьківський коміт не є обов'язковим. За замовчуванням "
"батьківський коміт встановлюється на найновіший доступний (вказівник HEAD) "
"на момент створення гілки. Ви також можете переключитися на новостворену "
"гілку одразу після її створення за допомогою:"

#: ../../src/vcs/branch.txt:88
msgid "Switching branches"
msgstr "Перемикання гілок"

#: ../../src/vcs/branch.txt:90
msgid "To switch to an existing branch, you run the ``git checkout`` command."
msgstr "Щоб перейти до існуючої гілки, виконайте команду ``git checkout``."

#: ../../src/vcs/branch.txt:109
msgid "Basic branching and merging"
msgstr "Основи розгалуження та злиття"

#: ../../src/vcs/branch.txt:111
msgid ""
"First, let's say you're working on your project and have a couple of commits "
"already on the ``master`` branch. You've decided that you're going to work "
"on issue #53 in whatever issue-tracking system your company uses. To create "
"a new branch and switch to it at the same time, you can run the ``git "
"checkout`` command with the ``-b`` switch:"
msgstr ""
"По-перше, припустимо, що ви працюєте над своїм проектом і вже маєте кілька "
"комітів на гілці ``master``. Ви вирішили, що будете працювати над issue #53 "
"в будь-якій системі відстеження проблем, яку використовує ваша компанія. Щоб "
"створити нову гілку і одночасно переключитися на неї, ви можете виконати "
"команду ``git checkout`` з ключем ``-b``:"

#: ../../src/vcs/branch.txt:122
msgid "This is shorthand for:"
msgstr "Це скорочено означає:"

#: ../../src/vcs/branch.txt:129
msgid ""
"In deed this creates a new branch pointer, aimed to the latest commit "
"present on ``master`` branch. But, from now your branch is ``feature/"
"issue53``. So, doing commits moves the feature branch pointer forward, "
"because you have it checkout out (that is, your ``HEAD`` is pointing to it)."
msgstr ""
"Насправді це створить новий покажчик гілки, спрямований на останню фіксацію, "
"наявну у гілці ``master``. Але відтепер ваша гілка називається ``feature/"
"issue53``. Отже, виконання коммітів пересуває вказівник гілки feature "
"вперед, тому що ви її вилучили (тобто ваша ``HEAD`` вказує на неї)."

#: ../../src/vcs/branch.txt:134
msgid ""
"Now, lets assume the \"issue53\" is fixed, and you need to bring commits "
"from the ``feature/issue53`` branch back to ``master``."
msgstr ""
"Тепер припустимо, що \"issue53\" виправлено, і вам потрібно перенести коміти "
"з гілки ``feature/issue53`` назад до ``master``."

#: ../../src/vcs/branch.txt:138
msgid "Merging branches"
msgstr "Злиття гілок"

#: ../../src/vcs/branch.txt:140
msgid ""
"You need to switch back to ``master`` branch and use ``git merge`` command, "
"to merge changes (commits) from the source branch into target."
msgstr ""
"Вам потрібно повернутися до гілки ``master`` і скористатися командою ``git "
"merge``, щоб об'єднати зміни (коміти) з вихідної гілки в цільову."

#: ../../src/vcs/branch.txt:152
msgid ""
"You'll notice phrase \"fast-forward\" in that merge. Because the commit "
"pointed to by the branch ``feature/issue53`` you merged in was directly "
"ahead of the last commit on ``master`` branch, Git simply moves the pointer "
"forward."
msgstr ""
"Ви помітите фразу \"перемотування вперед\" у цьому злитті. Оскільки коміт, "
"на який вказує гілка ``feature/issue53``, до якої ви приєдналися, був "
"безпосередньо перед останнім комітом у гілці ``master``, Git просто пересуне "
"вказівник вперед."

#: ../../src/vcs/branch.txt:156
msgid ""
"Changes from ``feature/issue53`` are now in the snapshot of the commit "
"pointed to by the ``master`` branch."
msgstr ""
"Зміни з ``feature/issue53`` тепер містяться у знімку коміту, на який вказує "
"гілка ``master``."

#: ../../src/vcs/branch.txt:163
msgid ""
"Now, lets assume another developer started working on ``feature/issue54`` at "
"the same time. And there are few commits on this feature branch. Suppose, "
"the developer decided that work on **issue54** is finished and they want to "
"merge their feature branch into ``master``."
msgstr ""
"Тепер припустимо, що інший розробник почав працювати над ``feature/issue54`` "
"в той самий час. І у цій гілці мало комітів. Припустимо, що розробник "
"вирішив, що робота над **issue54** завершена і він хоче об'єднати свою гілку "
"з ``master``."

#: ../../src/vcs/branch.txt:179
msgid ""
"This looks a bit different than the ``feature/issue53`` merge. In this case, "
"development history has diverged from some older point. Because the commit "
"on the branch you're on isn't a direct ancestor of the branch you're merging "
"in, Git has to do some work. In this case, Git does a simple three-way "
"merge, using two snapshots pointed to by the branch tips and the common "
"ancestor of the two."
msgstr ""
"Це виглядає дещо інакше, ніж злиття ``функція/випуск53``. У цьому випадку "
"історія розробки розійшлася з якоїсь давнішої точки. Оскільки коміт на "
"гілці, в якій ви перебуваєте, не є прямим предком гілки, в яку ви виконуєте "
"злиття, Git'у доведеться виконати деяку роботу. У цьому випадку Git виконує "
"просте тристороннє злиття, використовуючи два знімки, на які вказують "
"кінчики гілок, і їхнього спільного предка."

#: ../../src/vcs/branch.txt:186
msgid ""
"Instead of just moving the branch pointer forward, Git creates a new "
"snapshot that results from this three-way merge and automatically creates a "
"new commit that points to it. This is referred to as a *merge commit*, and "
"is a special in that it has more than one parent."
msgstr ""
"Замість того, щоб просто перемістити вказівник гілки вперед, Git створює "
"новий знімок, який є результатом цього тристороннього злиття, і автоматично "
"створює новий коміт, який вказує на нього. Це називається *коммітом злиття*, "
"і він особливий тим, що має більше одного батька."

#: ../../src/vcs/branch.txt:196
msgid "Merge conflicts"
msgstr "Конфлікти об'єднання"

#: ../../src/vcs/branch.txt:198
msgid ""
"Occasionally, the merge process doesn't go smoothly. If the same part of the "
"same file is changed differently in the two branches you're merging, Git "
"won't be able to merge them cleanly."
msgstr ""
"Іноді процес злиття відбувається не зовсім гладко. Якщо у двох гілках, які "
"ви об'єднуєте, однакова частина одного і того ж файлу змінена по-різному, "
"Git не зможе об'єднати їх чисто."

#: ../../src/vcs/branch.txt:209
msgid ""
"Git hasn't automatically created a new merge commit. It has paused the "
"process while you resolve the conflict. If you want to see which files are "
"unmerged at any point after a merge conflict, you can run ``git status``:"
msgstr ""
"Git не створив автоматично новий коміт злиття. Він призупинив процес, поки "
"ви вирішуєте конфлікт. Якщо ви хочете побачити, які файли було від'єднано "
"після конфлікту злиття, ви можете запустити ``git status``:"

#: ../../src/vcs/branch.txt:228
msgid ""
"Anything that has merge conflicts and hasn't been resolved is listed as "
"unmerged. Git adds standard conflict-resolution markers to the files that "
"have conflicts, so you can open them manually and resolve those conflicts. "
"Your file contains a section that looks something like this:"
msgstr ""
"Все, що має конфлікти злиття, які не було вирішено, позначається як не "
"об'єднане. Git додає стандартні маркери вирішення конфліктів до файлів, які "
"мають конфлікти, щоб ви могли відкрити їх вручну і вирішити ці конфлікти. "
"Ваш файл містить розділ, який виглядає приблизно так:"

#: ../../src/vcs/branch.txt:243
msgid ""
"This means the version in ``HEAD`` (your ``master`` branch, because that was "
"what you had checked out when you ran merge command) is the top part of that "
"block (everything above the \"=======\"), while the version in ``vcs`` "
"branch looks like everything in the bottom part. In order to resolve the "
"conflict, you have to either choose one side or the other or merge the "
"contents yourself."
msgstr ""
"Це означає, що версія у гілці ``HEAD`` (ваша гілка ``master``, тому що саме "
"її ви перевірили, коли виконували команду merge) - це верхня частина блоку "
"(все, що вище \"=======\"), тоді як версія у гілці ``vcs`` виглядає як все, "
"що знаходиться у нижній частині. Для того, щоб вирішити конфлікт, вам "
"доведеться або стати на чийсь бік, або об'єднати вміст самостійно."

#: ../../src/vcs/branch.txt:249
msgid "When conflicts are resolved, you can run ``git status`` command again:"
msgstr ""
"Коли конфлікти буде вирішено, ви можете знову запустити команду ``git "
"status``:"

#: ../../src/vcs/branch.txt:262
msgid ""
"If you're happy with that, and you verify that everything that had conflicts "
"has been staged, you can run ``git commit`` for finalize the merge commit."
msgstr ""
"Якщо вас все влаштовує, і ви переконалися, що все, що викликало конфлікти, "
"було усунуто, ви можете запустити ``git commit`` для остаточного завершення "
"злиття."

#: ../../src/vcs/branch.txt:266
msgid "Rebasing"
msgstr "Перебазування"

#: ../../src/vcs/branch.txt:268
msgid ""
"In Git, there two main ways to integrate changes from one branch into "
"another: the ``merge`` and the ``rebase``."
msgstr ""
"У Git'і існує два основних способи інтеграції змін з однієї гілки в іншу: "
"\"злиття\" і \"перебазування\"."

#: ../../src/vcs/branch.txt:271
msgid ""
"Earlier, there was an example of diverged work and commits made on two "
"different branches."
msgstr ""
"Раніше ми вже наводили приклад розбіжностей у роботі та зобов'язаннях, "
"зроблених на двох різних гілках."

#: ../../src/vcs/branch.txt:278
msgid ""
"The easiest way to integrate the branches, as we've already covered, is the "
"``merge`` command. It performs a three-way merge between the two latest "
"branch snapshots, and the most recent common ancestor of the two, creating a "
"new snapshot (and commit)."
msgstr ""
"Найпростішим способом об'єднання гілок, як ми вже розглядали, є команда "
"``merge``. Вона виконує тристороннє злиття між двома останніми знімками "
"гілок і останнім спільним предком, створюючи новий знімок (і фіксацію)."

#: ../../src/vcs/branch.txt:283
msgid ""
"However, there is another way: you can take the patch of the change that was "
"introduced in ``master`` and reapply it on top of ``feature``. In Git, this "
"is called *rebasing*. With ``rebase`` command, you can take all the changes "
"that were committed on one branch and replay them on a different branch."
msgstr ""
"Втім, є й інший спосіб: ви можете взяти патч зі змінами, які було внесено до "
"``master``, і повторно застосувати його поверх ``feature``. У Git'і це "
"називається *rebasing*. За допомогою команди ``rebase`` ви можете взяти всі "
"зміни, які були зафіксовані на одній гілці, і відтворити їх на іншій гілці."

#: ../../src/vcs/branch.txt:295
msgid ""
"This operation works by going to the common ancestor of the two branches, "
"getting the diff introduced by each commit of the branch you're on, saving "
"those diffs to temporary files, resetting the current branch to the same "
"commit as the branch you are rebasing onto, and finally applying each change "
"in turn."
msgstr ""
"Ця операція виконується шляхом переходу до спільного предка двох гілок, "
"отримання відмінностей, внесених кожним коммітом гілки, на якій ви "
"перебуваєте, збереження цих відмінностей у тимчасових файлах, скидання "
"поточної гілки до того ж комміту, що і гілка, на яку ви перебазуєтесь, і, "
"нарешті, застосування кожної зміни по черзі."

#: ../../src/vcs/branch.txt:306
msgid ""
"Other maintainers prefer to rebase (or cherry-pick) contributed work on top "
"of their ``master`` branch, rather then merging it in, to keep a mostly "
"linear history."
msgstr ""
"Інші супроводжувачі надають перевагу перезавантаженню (або вилученню) "
"внесених напрацювань на вершині своєї \"головної\" гілки, замість того, щоб "
"об'єднувати їх, щоб зберегти переважно лінійну історію."

#: ../../src/vcs/branch.txt:311
msgid "Cherry-picking"
msgstr "Cherry-picking"

#: ../../src/vcs/branch.txt:313
msgid ""
"The other way to move introduced work from one branch to another is to "
"*cherry-pick* it. A cherry-pick in Git is a rebase for a single commit. It "
"takes the patch that was introduced in a commit and tries to reapply it on "
"the branch you're currently on. This is useful if you have a number of "
"commits on a topic branch and you want to integrate only one of them, or if "
"you only have one commit on a topic branch and you'd prefer to cherry-pick "
"it rather than run rebase."
msgstr ""
"Інший спосіб перенесення внесеної роботи з однієї гілки в іншу - це "
"\"збирання коммітів\" (cherry-pick). Збирання вишень у Git'і - це "
"відновлення бази для одного коміту. Він бере патч, який було внесено в "
"комміті, і намагається повторно застосувати його на гілці, на якій ви зараз "
"перебуваєте. Це корисно, якщо ви маєте декілька коммітів у гілці теми і "
"хочете інтегрувати лише один з них, або якщо ви маєте лише один комміт у "
"гілці теми і вважаєте за краще вибрати його замість того, щоб запускати "
"rebase."

#: ../../src/vcs/branch.txt:333
msgid "Branching strategies"
msgstr "Стратегії розгалуження"

#: ../../src/vcs/branch.txt:335
msgid ""
"Branching strategy in version control systems defines how branches are "
"created, managed, and used in a project's development process. It helps "
"teams collaborate effectively, isolate changes, and organize development "
"efforts. A good branching strategy provides clarity on how to work with "
"branches, minimizes conflicts, and enables a smooth and structured "
"development workflow."
msgstr ""
"Стратегія розгалуження в системах контролю версій визначає, як створюються, "
"управляються та використовуються гілки в процесі розробки проекту. Вона "
"допомагає командам ефективно співпрацювати, ізолювати зміни та "
"організовувати зусилля з розробки. Хороша стратегія розгалуження забезпечує "
"чіткість у роботі з гілками, мінімізує конфлікти та уможливлює плавний і "
"структурований робочий процес розробки."

#: ../../src/vcs/branch.txt:342
msgid ""
"GitFlow is a popular branching strategy that provides a well-defined model "
"for managing branches in a Git repository. It was introduced by Vincent "
"Driessen and is based on the idea of using two main branches: \"master\" and "
"\"develop.\""
msgstr ""
"GitFlow - це популярна стратегія розгалуження, яка надає чітко визначену "
"модель для управління гілками в Git-репозиторії. Вона була представлена "
"Вінсентом Дріссеном (Vincent Driessen) і базується на ідеї використання двох "
"основних гілок: \"master\" і \"develop\"."

#: ../../src/vcs/branch.txt:346
msgid ""
"**Master Branch**: The \"master\" branch represents the stable version of "
"the codebase. It should always contain production-ready code and be free "
"from any major issues. The \"master\" branch is protected, and only release "
"versions are merged into it."
msgstr ""
"**Майстер-гілка**: \"Майстер-гілка\" представляє стабільну версію кодової "
"бази. Вона завжди повинна містити готовий до використання код і не містити "
"жодних серйозних проблем. Майстер-гілка захищена, і в неї зливаються тільки "
"релізні версії."

#: ../../src/vcs/branch.txt:350
msgid ""
"**Develop Branch**: The \"develop\" branch is where the ongoing development "
"and integration of features take place. It serves as the integration branch "
"for various feature branches and should also contain a stable version of the "
"code."
msgstr ""
"**Гілка розробки**: Гілка \"develop\" - це місце, де відбувається постійна "
"розробка та інтеграція функцій. Вона слугує інтеграційною гілкою для різних "
"функціональних гілок, а також повинна містити стабільну версію коду."

#: ../../src/vcs/branch.txt:354
msgid ""
"**Feature Branches**: For each new feature or bug fix, a dedicated "
"\"feature\" branch is created off the \"develop\" branch. These branches are "
"short-lived and exist only for the duration of the feature development."
msgstr ""
"**Вітки функцій**: Для кожної нової функції або виправлення помилки "
"створюється окрема гілка \"feature\" у гілці \"develop\". Ці гілки "
"недовговічні і існують лише на час розробки функції."

#: ../../src/vcs/branch.txt:357
msgid ""
"**Release Branches**: When the development on the \"develop\" branch is "
"ready for a release, a \"release\" branch is created. The release branch is "
"used for testing, bug fixing, and preparing for deployment."
msgstr ""
"**Вітки релізу**: Коли розробка на гілці \"develop\" готова до релізу, "
"створюється гілка \"release\". Релізна гілка використовується для "
"тестування, виправлення помилок і підготовки до розгортання."

#: ../../src/vcs/branch.txt:360
msgid ""
"**Hotfix Branches**: If a critical issue is discovered in the production "
"version, a \"hotfix\" branch is created from the \"master\" branch. This "
"allows for a quick fix without affecting ongoing development on the "
"\"develop\" branch."
msgstr ""
"**Гілки виправлень**: Якщо у виробничій версії виявлено критичну проблему, "
"на основі основної гілки створюється гілка \"hotfix\". Це дозволяє швидко "
"виправити проблему, не впливаючи на поточну розробку на гілці \"develop\"."

#: ../../src/vcs/branch.txt:365
msgid ""
"GitFlow provides a structured approach to managing branching in a "
"collaborative development environment. It ensures that the main branches "
"remain stable, and new features and bug fixes are integrated smoothly before "
"being released. This strategy is particularly useful for projects with "
"regular releases and a team working on multiple features concurrently."
msgstr ""
"GitFlow забезпечує структурований підхід до управління розгалуженням у "
"середовищі спільної розробки. Він гарантує, що основні гілки залишаються "
"стабільними, а нові функції та виправлення помилок плавно інтегруються перед "
"випуском. Ця стратегія особливо корисна для проектів з регулярними випусками "
"і командою, яка працює над декількома функціями одночасно."
