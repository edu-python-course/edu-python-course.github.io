# PYTHON BASICS BLOCK TRANSLATION.
#
# Copyright (C) 2023, Python training course authors and contributors
# This file is distributed under the same license as the Python Training
# Course package.
# OLEKSANDR YEROMIN <unicorn.in.pants@gmail.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: Python Training Course 2022.11.dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-21 06:44+0300\n"
"PO-Revision-Date: 2023-08-18 01:44+0300\n"
"Last-Translator: Serhii Horodilov <sgorodil@gmail.com>\n"
"Language-Team: \n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"Generated-By: Babel 2.12.1\n"
"X-Generator: Poedit 3.3.2\n"

#: ../../src/basics/bool_logic.txt:-1
msgid "this document covers usage of logic and comparison operators in Python"
msgstr ""
"у цьому документі розглядається використання логічних операторів та "
"операторів порівняння у Python"

#: ../../src/basics/bool_logic.txt:-1 ../../src/basics/controlflow.txt:-1
#: ../../src/basics/decorators.txt:-1 ../../src/basics/exceptions.txt:-1
#: ../../src/basics/functions.txt:-1 ../../src/basics/index.txt:-1
#: ../../src/basics/modules.txt:-1 ../../src/basics/pep8.txt:-1
#: ../../src/basics/stdtypes.txt:-1 ../../src/basics/syntax.txt:-1
#: ../../src/basics/testing.txt:-1 ../../src/basics/variables.txt:-1
msgid "Serhii Horodilov"
msgstr "Serhii Horodilov"

#: ../../src/basics/bool_logic.txt:-1
msgid "python, boolean, logic, comparison, operator"
msgstr "python, boolean, logic, comparison, operator"

#: ../../src/basics/bool_logic.txt:14
msgid "Boolean Logic"
msgstr "Булева Логіка"

#: ../../src/basics/bool_logic.txt:20
msgid ""
"`George Boole`_ put together what is now known as `Boolean algebra`_, which "
"relies on **true** and **false** values and define a set of boolean "
"operations: **not**, **and**, and **or**."
msgstr ""
"`Джордж Буль`_ створив те, що зараз відоме як `булева алгебра`_, яка "
"спирається на значення **істина** та **хибність** і визначає набір булевих "
"операцій: **не**, **і** та **або**."

#: ../../src/basics/bool_logic.txt:24
msgid ""
"These Boolean values and operators are helpful in programming because they "
"help you decide the course of action in your programs."
msgstr ""
"Ці булеві значення та оператори корисні у програмуванні, оскільки вони "
"допомагають вам визначати порядок дій у ваших програмах."

#: ../../src/basics/bool_logic.txt:27
msgid ""
"The **Python boolean** type is one of Python's built-in data types. It's "
"used to represent the truth value of an expression. For example, the "
"expression ``1 < 2`` is ``True``, while the expression ``0 == 1`` is "
"``False``. Understanding how Python Boolean values behave is important to "
"programming well in Python."
msgstr ""
"Тип **Python boolean** є одним із вбудованих типів даних Python. Він "
"використовується для представлення значення істинності виразу. Наприклад, "
"вираз ``1 < 2`` є ``True`` (істине), тоді як вираз ``0 == 1`` є ``False`` "
"(хибне). Розуміння того, як поводяться булеві значення у Python, є важливим "
"для якісного програмування на Python."

#: ../../src/basics/bool_logic.txt:34
msgid "Understanding Boolean"
msgstr "Розуміння булевих функцій"

#: ../../src/basics/bool_logic.txt:36
msgid "The Boolean type has only two possible values:"
msgstr "Тип Boolean має лише два можливих значення:"

#: ../../src/basics/bool_logic.txt:38 ../../src/basics/bool_logic.txt:121
#: ../../src/basics/bool_logic.txt:123 ../../src/basics/bool_logic.txt:149
#: ../../src/basics/bool_logic.txt:153 ../../src/basics/bool_logic.txt:155
#: ../../src/basics/bool_logic.txt:191 ../../src/basics/bool_logic.txt:195
#: ../../src/basics/bool_logic.txt:197
msgid "``True``"
msgstr "``True``"

#: ../../src/basics/bool_logic.txt:39 ../../src/basics/bool_logic.txt:121
#: ../../src/basics/bool_logic.txt:123 ../../src/basics/bool_logic.txt:151
#: ../../src/basics/bool_logic.txt:153 ../../src/basics/bool_logic.txt:155
#: ../../src/basics/bool_logic.txt:193 ../../src/basics/bool_logic.txt:195
#: ../../src/basics/bool_logic.txt:197
msgid "``False``"
msgstr "``False``"

#: ../../src/basics/bool_logic.txt:41
msgid "No other value will have ``bool`` as it type."
msgstr "Жодне інше значення не буде мати тип ``bool``."

#: ../../src/basics/bool_logic.txt:50
msgid ""
"The type ``bool`` is **built-in**, meaning it's always available in Python. "
"``True`` and ``False`` are keywords in Python and can't be used as variable "
"names. but ``bool`` type isn't and it's possible assign to the name "
"``bool``, however this is considered bad style."
msgstr ""
"Тип ``bool`` є **вбудованим**, тобто він завжди доступний у Python. ``True`` "
"та ``False`` є ключовими словами у Python і не можуть використовуватися як "
"імена змінних, але тип ``bool`` не є таким, і його можна присвоювати імені "
"``bool``, однак це вважається поганим стилем."

#: ../../src/basics/bool_logic.txt:56
msgid "Boolean as numbers"
msgstr "Булеві як числа"

#: ../../src/basics/bool_logic.txt:58
msgid ""
"Booleans are a subtype of **numeric** type in Python. This means they're "
"numbers for all intents and purposes. In other words, you can apply "
"arithmetic operations to Boolean, and you can also compare them to numbers. "
"``True`` value is treated to be 1, and ``False`` value is treated to be 0."
msgstr ""
"Булеві вирази є підтипом **числового** типу у Python. Це означає, що вони є "
"числами за всіма ознаками. Іншими словами, до булевих типів можна "
"застосовувати арифметичні операції, а також порівнювати їх з числами. "
"Значення ``Істина`` розглядається як 1, а значення ``Неправда`` "
"розглядається як 0."

#: ../../src/basics/bool_logic.txt:63
msgid "There aren't many uses of the numerical nature of Boolean values."
msgstr "Існує не так багато застосувань числової природи булевих значень."

#: ../../src/basics/bool_logic.txt:66
msgid "Truth value testing"
msgstr "Перевірка істинності"

#: ../../src/basics/bool_logic.txt:68
msgid ""
"Any object can be tested for truth value. By default an object considered "
"``True``, unless its class defines either. Here are most of built-in objects "
"considered ``False``:"
msgstr ""
"Будь-який об'єкт можна перевірити на істинність. За замовчуванням об'єкт "
"вважається ``Істинним``, якщо його клас не визначає іншого значення. "
"Більшість вбудованих об'єктів вважаються такими, що мають значення ``False``:"

#: ../../src/basics/bool_logic.txt:72
msgid "constant values: ``None`` and ``False``"
msgstr "константні значення: ``None`` та ``False``"

#: ../../src/basics/bool_logic.txt:73
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"нуль будь-якого числового типу: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: ../../src/basics/bool_logic.txt:75
msgid ""
"empty sequences and collections: ``''``, ``[]``, ``()``, ``{}``, ``set()``, "
"``range(0)``."
msgstr ""
"порожні послідовності та колекції: ``''``, ``[]``, ``()``, ``{}``, "
"``set()``, ``range(0)``."

#: ../../src/basics/bool_logic.txt:80
msgid ""
"If ``len(something)`` is equal to 0, than ``something`` is cast to ``bool`` "
"as ``False``."
msgstr ""
"Якщо ``len(something)`` дорівнює 0, то ``something`` приводиться до ``bool`` "
"як ``False``."

#: ../../src/basics/bool_logic.txt:84
msgid "Boolean comparison"
msgstr "Логічне порівняння"

#: ../../src/basics/bool_logic.txt:88
msgid "Python provides 3 logical operators:"
msgstr "У мові Python передбачено 3 логічних оператори:"

#: ../../src/basics/bool_logic.txt:94 ../../src/basics/bool_logic.txt:228
msgid "Operator"
msgstr "Оператор"

#: ../../src/basics/bool_logic.txt:94
msgid "Logic operator"
msgstr "Логічний оператор"

#: ../../src/basics/bool_logic.txt:96
msgid "``not``"
msgstr "``not``"

#: ../../src/basics/bool_logic.txt:96
msgid "Negation"
msgstr "Заперечення"

#: ../../src/basics/bool_logic.txt:98
msgid "``and``"
msgstr "``and``"

#: ../../src/basics/bool_logic.txt:98
msgid "Conjunction"
msgstr "Кон'юнкція"

#: ../../src/basics/bool_logic.txt:100
msgid "``or``"
msgstr "``or``"

#: ../../src/basics/bool_logic.txt:100
msgid "Disjunction"
msgstr "Диз'юнкція"

#: ../../src/basics/bool_logic.txt:103
msgid ""
"With these operators, you can build expressions by connecting Boolean "
"expressions with each other. These operators are **keywords** of the "
"language, so you cannot use them as identifiers without causing a "
"*SyntaxError*."
msgstr ""
"За допомогою цих операторів ви можете створювати вирази, з'єднуючи булеві "
"вирази один з одним. Ці оператори є **ключовими словами** мови, тому ви не "
"можете використовувати їх як ідентифікатори, не викликавши *SyntaxError*."

#: ../../src/basics/bool_logic.txt:108
msgid "Getting started with ``not`` operator"
msgstr "Початок роботи з оператором ``not``"

#: ../../src/basics/bool_logic.txt:110
msgid ""
"The ``not`` operator is the Boolean or logic operator that implements "
"negation in Python. It's **unary**, which means that it takes only one "
"**operand**. The operand can be a Boolean expression or any Python object. "
"The task of ``not`` is to reverse the truth value of its operand."
msgstr ""
"Оператор ``not`` - це булевий або логічний оператор, який реалізує "
"заперечення у Python. Він є **унарним**, що означає, що він приймає лише "
"один **операнд**. Операндом може бути булевий вираз або будь-який об'єкт "
"Python. Завдання ``not`` полягає в тому, щоб змінити значення істинності "
"свого операнда на протилежне."

#: ../../src/basics/bool_logic.txt:115
msgid "not operator truth table"
msgstr "таблиця істинності оператора not"

#: ../../src/basics/bool_logic.txt:119
msgid "``operand``"
msgstr "``operand``"

#: ../../src/basics/bool_logic.txt:119
msgid "``not operand``"
msgstr "``not operand``"

#: ../../src/basics/bool_logic.txt:126
msgid "This functionality makes it worthwhile in several situations:"
msgstr "Ця функціональність робить його корисним у кількох ситуаціях:"

#: ../../src/basics/bool_logic.txt:129
msgid ""
"Checking **unmet conditions** in the context of ``if`` statements and "
"``while`` loops"
msgstr ""
"Перевірка **невиконання умов** у контексті операторів ``if`` та циклів "
"``while``"

#: ../../src/basics/bool_logic.txt:131
msgid "**Inverting the truth value** of an object or expression"
msgstr "**Інвертування значення істинності** об'єкта або виразу"

#: ../../src/basics/bool_logic.txt:132
msgid "Checking if a **value is not in a given container**"
msgstr "Перевірка, чи **значення не знаходиться у заданому контейнері**"

#: ../../src/basics/bool_logic.txt:133
msgid "Checking for an **object's identity**"
msgstr "Перевірка **ідентичності об'єкта**"

#: ../../src/basics/bool_logic.txt:136
msgid "Getting started with ``and`` operator"
msgstr "Початок роботи з оператором ``and``"

#: ../../src/basics/bool_logic.txt:138
msgid ""
"Python's ``and`` operator is **binary**, which means it takes two "
"**operands**. The operands in an ``and`` expression are commonly known as "
"*conditions*. The result of the operator depends on the truth values of its "
"operands. It'll be ``True`` if **both** are true."
msgstr ""
"Оператор ``and`` у мові Python є **двійковим**, що означає, що він приймає "
"два **операнди**. Операнди у виразі ``і`` зазвичай називають *умовами*. "
"Результат оператора залежить від значень істинності його операндів. "
"Результат буде ``Істина``, якщо **обоє** є істинними."

#: ../../src/basics/bool_logic.txt:143
msgid "and operator truth table"
msgstr "таблиця істинності оператора and"

#: ../../src/basics/bool_logic.txt:147 ../../src/basics/bool_logic.txt:189
msgid "``operand_1``"
msgstr "``operand_1``"

#: ../../src/basics/bool_logic.txt:147 ../../src/basics/bool_logic.txt:189
msgid "``operand_2``"
msgstr "``operand_2``"

#: ../../src/basics/bool_logic.txt:147
msgid "``operand_1 and operand_2``"
msgstr "``operand_1 and operand_2``"

#: ../../src/basics/bool_logic.txt:158
msgid ""
"``and`` operator works not only with operands of Boolean type. It's behavior:"
msgstr "``and`` працює не тільки з операндами булевого типу. Це поведінка:"

#: ../../src/basics/bool_logic.txt:161
msgid "evaluate 1st operand; return it, if it's ``False`` and finish"
msgstr ""
"обчислити 1-й операнд; повернути його, якщо він рівний ``False`` і завершити"

#: ../../src/basics/bool_logic.txt:162
msgid "evaluate 2nd operand; return it, if it's ``False`` and finish"
msgstr ""
"обчислити 2-й операнд; повернути його, якщо він рівний ``False`` і завершити"

#: ../../src/basics/bool_logic.txt:163 ../../src/basics/bool_logic.txt:205
msgid "return 2nd operand"
msgstr "повернути 2-й операнд"

#: ../../src/basics/bool_logic.txt:177
msgid "Getting started with ``or`` operator"
msgstr "Початок роботи з оператором ``or``"

#: ../../src/basics/bool_logic.txt:179
msgid ""
"With Boolean ``or`` operator, you can connect two Boolean expressions into "
"one compound expression. This makes ``or`` the **binary** operator. At least "
"one subexpression must be ``True`` for the compound expression to be "
"considered ``True``, and it doesn't matter which. If both subexpressions are "
"``False``, then the expression is ``False``."
msgstr ""
"За допомогою булевого оператора ``або`` ви можете об'єднати два булевих "
"вирази в один складений вираз. Це робить ``або`` **бінарним** оператором. "
"Принаймні один з підвиразів має бути ``True``, щоб складений вираз вважався "
"``True``, і не має значення, який саме. Якщо обидва під-вирази мають "
"значення ``False``, то вираз буде вважатися ``False``."

#: ../../src/basics/bool_logic.txt:185
msgid "or operator truth table"
msgstr "таблиця істинності оператора or"

#: ../../src/basics/bool_logic.txt:189
msgid "``operand_1 or operand_2``"
msgstr "``operand_1 or operand_2``"

#: ../../src/basics/bool_logic.txt:200
msgid ""
"``or`` operator works not only with operands of Boolean type. It's behavior:"
msgstr "``or`` працює не тільки з операндами булевого типу. Це поведінка:"

#: ../../src/basics/bool_logic.txt:203
msgid "evaluate 1st operand; return it, if it's ``True`` and finish"
msgstr ""
"обчислити 1-й операнд; повернути його, якщо він рівний ``True`` і завершити"

#: ../../src/basics/bool_logic.txt:204
msgid "evaluate 2nd operand; return it, if it's ``True`` and finish"
msgstr ""
"обчислити 2-й операнд; повернути його, якщо він рівний ``True`` і завершити"

#: ../../src/basics/bool_logic.txt:219
msgid "Comparison"
msgstr "Порівняння"

#: ../../src/basics/bool_logic.txt:221
msgid ""
"There are eight comparison operations in Python. They all have the same "
"priority (which is higher than that of the Boolean operations)."
msgstr ""
"У мові Python існує вісім операцій порівняння. Всі вони мають однаковий "
"пріоритет (вищий, ніж у булевих операцій)."

#: ../../src/basics/bool_logic.txt:224
msgid "Comparison operators"
msgstr "Оператори порівняння"

#: ../../src/basics/bool_logic.txt:228
msgid "Meaning"
msgstr "Значення"

#: ../../src/basics/bool_logic.txt:230
msgid "``<``"
msgstr "``<``"

#: ../../src/basics/bool_logic.txt:230
msgid "strictly less than"
msgstr "строго менше, ніж"

#: ../../src/basics/bool_logic.txt:232
msgid "``<=``"
msgstr "``<=``"

#: ../../src/basics/bool_logic.txt:232
msgid "less than or equal"
msgstr "менше або дорівнює"

#: ../../src/basics/bool_logic.txt:234
msgid "``>``"
msgstr "``>``"

#: ../../src/basics/bool_logic.txt:234
msgid "strictly greater than"
msgstr "строго більше, ніж"

#: ../../src/basics/bool_logic.txt:236
msgid "``>=``"
msgstr "``>=``"

#: ../../src/basics/bool_logic.txt:236
msgid "greater or equal"
msgstr "більше або дорівнює"

#: ../../src/basics/bool_logic.txt:238
msgid "``==``"
msgstr "``==``"

#: ../../src/basics/bool_logic.txt:238
msgid "equal (aka *equality* comparison)"
msgstr "дорівнює (також відоме як *equality* порівняння)"

#: ../../src/basics/bool_logic.txt:240
msgid "``!=``"
msgstr "``!=``"

#: ../../src/basics/bool_logic.txt:240
msgid "not equal"
msgstr "не дорівнює"

#: ../../src/basics/bool_logic.txt:242
msgid "``is``"
msgstr "``is``"

#: ../../src/basics/bool_logic.txt:242
msgid "object identity"
msgstr "ідентичність об'єктів"

#: ../../src/basics/bool_logic.txt:244
msgid "``is not``"
msgstr "``is not``"

#: ../../src/basics/bool_logic.txt:244
msgid "negated object identity"
msgstr "заперечення ідентичності об'єкта"

#: ../../src/basics/bool_logic.txt:247
msgid ""
"Each of these comparison operators return a Boolean value, it's always "
"``True`` or ``False``."
msgstr ""
"Кожен з цих операторів порівняння повертає булеве значення, завжди ``True`` "
"або ``False``."

#: ../../src/basics/bool_logic.txt:250
msgid ""
"You can chain comparison operators together: ``x < y < z`` is equal to ``x < "
"y and y < z``."
msgstr ""
"Ви можете з'єднувати оператори порівняння ланцюжком: ``x < y < z`` дорівнює "
"``x < y та y < z``."

#: ../../src/basics/bool_logic.txt:254
msgid "Equality vs Identity"
msgstr "Рівність vs Ідентичністі"

#: ../../src/basics/bool_logic.txt:256
msgid ""
"It's easier to understand the difference between those by asking the "
"question each answers to."
msgstr ""
"Зрозуміти різницю між ними простіше, задавши питання, на яке відповідає "
"кожна з них."

#: ../../src/basics/bool_logic.txt:259
msgid "The question for ``==`` (*equality*) is:"
msgstr "Питання для ``==`` (*рівності*) полягає у наступному:"

#: ../../src/basics/bool_logic.txt:261
msgid "Is object on the left **equal** to the object on the right"
msgstr "Чи є об'єкт зліва **рівним** об'єкту справа"

#: ../../src/basics/bool_logic.txt:263
msgid "The question for ``is`` (*identity*) is:"
msgstr "Питання для ``is`` (*ідентичність*) полягає в наступному:"

#: ../../src/basics/bool_logic.txt:265
msgid "Is object on the left **the same** as the object on the right"
msgstr "Чи є об'єкт ліворуч **таким самим**, як і об'єкт праворуч"

#: ../../src/basics/bool_logic.txt:267
msgid ""
"For example, if there are two cars of the same model, same color etc. in "
"front of you - these cars are equal, but they aren't ident to each other. "
"But if you are shown two pictures of the same car, you understand that the "
"cars on those pictures are the same object."
msgstr ""
"Наприклад, якщо перед вами стоять два автомобілі однієї моделі, одного "
"кольору і т.д. - ці автомобілі рівні, але вони не ідентичні один одному. Але "
"якщо вам показують дві фотографії однієї і тієї ж машини, ви розумієте, що "
"машини на цих фотографіях - це один і той же об'єкт."

#: ../../src/basics/controlflow.txt:-1
msgid "Control flow in Python"
msgstr "Керування виконанням в Python"

#: ../../src/basics/controlflow.txt:-1
msgid "python, basics, control, if, for, while, condition, loop"
msgstr "python, basics, control, if, for, while, condition, loop"

#: ../../src/basics/controlflow.txt:8
msgid "Control Flow"
msgstr "Керування Виконанням"

#: ../../src/basics/controlflow.txt:11
msgid "``if`` statement"
msgstr "Вираз ``if``"

#: ../../src/basics/controlflow.txt:13
msgid ""
"Perhaps the most well-known statement type is ``if`` statement. For example:"
msgstr "Мабуть, найвідомішим типом операторів є оператор ``if``. Наприклад:"

#: ../../src/basics/controlflow.txt:15
msgid "if statement base example"
msgstr "базовий приклад інструкції if"

#: ../../src/basics/controlflow.txt:29
msgid "But let's dive into ``if`` statement with more simple examples."
msgstr "Але давайте зануримося в оператор ``if`` на більш простих прикладах."

#: ../../src/basics/controlflow.txt:32
msgid "How it works"
msgstr "Як це працює"

#: ../../src/basics/controlflow.txt:34
msgid ""
"**if** statement is defined with a keyword ``if`` followed by a Boolean "
"expression or any object and finished with colon. The statement requires a "
"*body*: other statements to execute, also called an *if block*. The body is "
"indented at the same distance from the left (in Python we use 4 spaces to "
"indent a single block of code)."
msgstr ""
"Оператор **if** визначається ключовим словом ``if``, за яким слідує булевий "
"вираз або будь-який об'єкт і завершується двокрапкою. Оператор вимагає "
"наявності *тіла*: інших операторів для виконання, яке також називається "
"*блоком if*. Тіло відступається на однакову відстань зліва (у Python ми "
"використовуємо 4 пробіли для відступу одного блоку коду)."

#: ../../src/basics/controlflow.txt:40
msgid ""
"The body's statements will be executed only in case **if** expression is "
"``True``."
msgstr ""
"Оператори тіла будуть виконані тільки у випадку, якщо вираз **if** має "
"значення ``True``."

#: ../../src/basics/controlflow.txt:53
msgid ""
"The ``print`` statement on line #6 will be executed only for even value of "
"``number`` variable."
msgstr ""
"Оператор ``print`` у рядку #6 буде виконано лише для парного значення "
"змінної ``number``."

#: ../../src/basics/controlflow.txt:57
msgid "``else`` block"
msgstr "блок ``else`` (\"інакше\")"

#: ../../src/basics/controlflow.txt:59
msgid ""
"``if`` can be used by its own, it can extend its behavior with ``else`` "
"block. The general syntax for ``else`` body is the same: at least one "
"indented statement. But ``else`` doesn't take any expression after it. This "
"block of code will be executed only that the ``if`` statement truth check "
"fails."
msgstr ""
"Якщо ``if`` можна використовувати самостійно, він може розширити свою "
"поведінку за допомогою блоку ``else``. Загальний синтаксис тіла ``else`` "
"такий самий: принаймні один оператор з відступом. Але ``else`` не приймає "
"ніяких виразів після себе. Цей блок коду буде виконано тільки в тому "
"випадку, якщо перевірка істинності інструкції ``if`` завершиться невдачею."

#: ../../src/basics/controlflow.txt:76
msgid ""
"You can attach **only one** else block to **if statement**. And you cannot "
"use ``else`` statement on its own - this will cause *SyntaxError*."
msgstr ""
"Ви можете приєднати **тільки один** блок else до **інструкції if**. І ви не "
"можете використовувати інструкцію ``else`` самостійно - це призведе до "
"*SyntaxError*."

#: ../../src/basics/controlflow.txt:80
msgid "``elif`` block(s)"
msgstr "Блок(и) ``elif``"

#: ../../src/basics/controlflow.txt:82
msgid ""
"``elif`` (*else if*) statement may be considered as semi-statement between "
"``if`` and ``else`` statements. In case your program has more than two "
"dedicated choices you are able to extends control flow by appending ``elif`` "
"blocks after ``if`` statement. The syntax is pretty similar to ``if`` "
"statement. Each ``elif`` has its own boolean expression or an object to test "
"for the truth value."
msgstr ""
"Оператор ``elif`` (*else if*) можна розглядати як напівоператор між "
"операторами ``if`` та ``else``. Якщо у вашій програмі є більше двох "
"виділених варіантів, ви можете розширити потік керування, додавши блоки "
"``elif`` після оператора ``if``. Синтаксис цих блоків дуже схожий на "
"синтаксис оператора ``if``. Кожен ``elif`` має власний логічний вираз або "
"об'єкт для перевірки значення істинності."

#: ../../src/basics/controlflow.txt:89
msgid ""
"You can attach as many ``elif`` statements as it needed. But you cannot use "
"``elif`` without ``if`` statement."
msgstr ""
"Ви можете приєднати стільки інструкцій ``elif``, скільки потрібно. Але ви не "
"можете використовувати ``elif`` без інструкції ``if``."

#: ../../src/basics/controlflow.txt:92
msgid ""
"Python will test conditions in ``if`` and ``elif`` statements from top to "
"bottom. The first one, which considered to be ``True`` will be executed. All "
"others will be skipped."
msgstr ""
"Python перевірить умови в операторах ``if`` і ``elif`` зверху вниз. Буде "
"виконано першу з них, яка вважається ``True``. Всі інші будуть пропущені."

#: ../../src/basics/controlflow.txt:96
msgid ""
"If there were no truth conditions ``else`` block will be executed (if "
"exists)."
msgstr ""
"Якщо умов істинності не було, буде виконано блок ``інакше`` (якщо він існує)."

#: ../../src/basics/controlflow.txt:112
msgid ""
"The order conditions appears matter. The truth test goes from top to bottom "
"and stops at first expression which is ``True``."
msgstr ""
"Порядок виведення умов має значення. Перевірка на істинність йде зверху вниз "
"і зупиняється на першому виразі, який є ``True``."

#: ../../src/basics/controlflow.txt:117
msgid "Usage"
msgstr "Використання"

#: ../../src/basics/controlflow.txt:119
msgid ""
"``if/elif/else`` statements help you to control which portion of your code "
"is executed based on conditions from outer scope."
msgstr ""
"Оператори ``if/elif/else`` допомагають вам контролювати, яка частина вашого "
"коду виконується на основі умов із зовнішньої області видимості."

#: ../../src/basics/decorators.txt:-1
msgid "Python decorators"
msgstr "Декоратори в Python"

#: ../../src/basics/decorators.txt:-1
msgid "python, basics, decorators"
msgstr "python, basics, decorators"

#: ../../src/basics/decorators.txt:11
msgid "Decorators"
msgstr "Декоратори"

#: ../../src/basics/decorators.txt:13
msgid ""
"Decorators provide a simple syntax for calling higher-order functions :cite:"
"`realpython:decorators`."
msgstr ""
"Декоратори надають простий синтаксис для виклику функцій вищого порядку :"
"cite:`realpython:decorators`."

#: ../../src/basics/decorators.txt:18
msgid "There is some kind of misunderstanding in definitions."
msgstr "Існує певне непорозуміння у визначеннях."

#: ../../src/basics/decorators.txt:20
msgid ""
"**Decorator** is a function returning another function, usually applied as a "
"function transformation using the ``@wrapper`` syntax :cite:`docs-python:"
"term-decorator`."
msgstr ""
"**Декоратор** - це функція, що повертає іншу функцію, зазвичай "
"застосовується як перетворення функції за допомогою синтаксису ``@wrapper`` :"
"cite:`docs-python:term-decorator`."

#: ../../src/basics/decorators.txt:24
msgid ""
"However, that's no quit enough to describe it. The more complete definition "
"is:"
msgstr "Однак цього недостатньо, щоб описати його. Більш повне визначення:"

#: ../../src/basics/decorators.txt:27
msgid ""
"**Decorator** is a structural design pattern that lets you attach new "
"behaviors to objects by placing these objects inside special wrapper objects "
"that contain the behaviors :cite:`refactoring.guru:decorator`."
msgstr ""
"**Декоратор** -- це патерн структурного дизайну, який дозволяє додавати нові "
"поведінки до об'єктів, розміщуючи ці об'єкти всередині спеціальних обгорток, "
"які містять поведінку :cite:`refactoring.guru:decorator`."

#: ../../src/basics/decorators.txt:31
msgid ""
"Before you understand decorators, you must first understand how functions "
"work."
msgstr ""
"Перш ніж розбиратися в декораторах, потрібно зрозуміти, як працюють функції."

#: ../../src/basics/decorators.txt:35
msgid "First-class objects"
msgstr "Об'єкти першого класу"

#: ../../src/basics/decorators.txt:37
msgid ""
"In Python functions are `first-class objects`_. Everything in Python is an "
"object. Functions are objects too."
msgstr ""
"У Python функції є `об'єктами першого класу`_. Усе в Python є об'єктом. "
"Функції також є об'єктами."

#: ../../src/basics/decorators.txt:41
msgid "Inner functions"
msgstr "Внутрішні функції"

#: ../../src/basics/decorators.txt:43
msgid ""
"Functions can be nested. This means it is possible to define functions "
"inside other functions."
msgstr ""
"Функції можуть бути вкладеними. Це означає, що можна визначати функції "
"всередині інших функцій."

#: ../../src/basics/decorators.txt:46
msgid "Nested functions example"
msgstr "Приклад вкладених функцій"

#: ../../src/basics/decorators.txt:60
msgid ""
"The order in which inner functions are defined no matters. The function "
"definition does not execute the function body; this gets executed only when "
"the function is called. Furthermore, the inner functions are not defined "
"until the parent function is called. They are locally scoped to their "
"parent. Trying to call ``heapify`` function outside of ``heap_sort`` will "
"cause ``NameError`` exception."
msgstr ""
"Порядок визначення внутрішніх функцій не має значення. Визначення функції не "
"виконує тіло функції; воно виконується лише під час виклику функції. Крім "
"того, внутрішні функції не визначаються до виклику батьківської функції. "
"Вони локально масштабуються до свого батька. Спроба викликати функцію "
"``heapify`` поза ``heap_sort`` призведе до виключення ``NameError``."

#: ../../src/basics/decorators.txt:68
msgid "Functions are objects"
msgstr "Функції є об'єктами"

#: ../../src/basics/decorators.txt:70
msgid ""
"This means functions can be passed around and used as arguments, just like "
"any other object (e.g. *int*, *str* etc.)."
msgstr ""
"Це означає, що функції можна передавати і використовувати як аргументи так "
"само, як і будь-які інші об'єкти (наприклад, *int*, *str* тощо)."

#: ../../src/basics/decorators.txt:95
msgid "Returning functions"
msgstr "Повернення функцій"

#: ../../src/basics/decorators.txt:97
msgid ""
"Since function can be passed as an argument, it may be returned from another "
"function."
msgstr ""
"Оскільки функція може бути передана як аргумент, вона може бути повернута з "
"іншої функції."

#: ../../src/basics/decorators.txt:120
msgid "``parent`` returns functions themselves, there are no parentheses."
msgstr "``parent`` повертає самі функції, дужок немає."

#: ../../src/basics/decorators.txt:122
msgid ""
"After running the code snippet above, ``first`` refers the ``first_child`` "
"function from the inner ``parent`` scope. From now it can be used to call "
"the target function it refers."
msgstr ""
"Після виконання наведеного вище фрагмента коду, ``first`` звертається до "
"функції ``first_child`` з внутрішньої області видимості ``parent``. Тепер її "
"можна використовувати для виклику цільової функції, на яку вона посилається."

#: ../../src/basics/decorators.txt:134
msgid "Simple decorators"
msgstr "Прості декоратори"

#: ../../src/basics/decorators.txt:136
msgid ""
"Now you're ready to move on and see the magical beast that is the Python "
"decorators. Let's start with a simple example:"
msgstr ""
"Тепер ви готові рухатися далі і побачити чарівного звіра, яким є декоратори "
"Python. Почнемо з простого прикладу:"

#: ../../src/basics/decorators.txt:154
msgid "Running function:"
msgstr "Запуск функцій:"

#: ../../src/basics/decorators.txt:165
msgid ""
"The common way to use decorators is to replace the original function with a "
"decorated one:"
msgstr ""
"Найпоширеніший спосіб використання декораторів - це заміна оригінальної "
"функції на декоровану:"

#: ../../src/basics/decorators.txt:176
msgid ""
"``say_hello`` function is the reference to the ``decorator.<locals>."
"wrapper``, which itself is bound to the original ``say_hello`` function. "
"There is a syntactic sugar to do this, called *pie-syntax*. The following "
"example does exact the same things as the first decorator example:"
msgstr ""
"Функція ``say_hello`` є посиланням на ``decorator.<locals>.wrapper``, яка "
"сама зв'язана з оригінальною функцією ``say_hello``. Для цього існує "
"синтаксичний цукор, який називається *pie-синтаксис*. Наступний приклад "
"робить те саме, що і перший приклад декоратора:"

#: ../../src/basics/decorators.txt:198
msgid ""
"There is no way to *undecorate* object in Python. Once something is bound to "
"the decorator's wrapper - it is decorated forever."
msgstr ""
"У Python не існує способу *віддекорувати* об'єкт. Як тільки щось прив'язано "
"до обгортки декоратора - воно прикрашене назавжди."

#: ../../src/basics/decorators.txt:201
msgid ""
"A decorated function still remains a **function**. So, it can be decorated "
"once more time again, and again, and again..."
msgstr ""
"Прикрашена функція все одно залишається **функцією**. Отже, її можна "
"прикрасити ще раз, і ще раз, і ще раз, і ще раз..."

#: ../../src/basics/decorators.txt:253
msgid ""
"\"Wrapper\" is the alternative nickname for the Decorator pattern that "
"clearly expresses the main idea of the pattern. A wrapper is an object that "
"can be linked with some target object. The wrapper contains the same set of "
"methods as the target and delegates to it all requests it receives. However, "
"the wrapper may alter the result by doing something either before or after "
"it passes the request to the target."
msgstr ""
"\"Обгортка\" - це альтернативна назва шаблону \"Декоратор\", яка чітко "
"виражає основну ідею шаблону. Обгортка - це об'єкт, який можна зв'язати з "
"деяким цільовим об'єктом. Обгортка містить той самий набір методів, що й "
"цільовий об'єкт, і делегує йому всі запити, які він отримує. Однак обгортка "
"може змінити результат, виконавши щось до або після передачі запиту "
"цільовому об'єкту."

#: ../../src/basics/decorators.txt:261
msgid "Passing arguments to the wrapper"
msgstr "Передача аргументів в обгортку"

#: ../../src/basics/decorators.txt:263
msgid ""
"Until now the examples use *simple* decorators. But what if the decorated "
"function gets some arguments? This will cause ``TypeError`` exception that "
"tell that \"arguments are missed\". This can be fixed with just passing "
"arguments to the ``wrapper`` inner function."
msgstr ""
"Досі у прикладах використовувались *прості* декоратори. Але що, якщо "
"декорована функція отримає якісь аргументи? Це викличе виключення "
"``TypeError``, яке скаже, що \"аргументи пропущено\". Це можна виправити, "
"просто передавши аргументи у внутрішню функцію ``обгортки``."

#: ../../src/basics/decorators.txt:289
msgid ""
"If case you're trying to make a generic decorator, you may pass ``*args`` "
"and ``**kwargs`` instead of exact arguments:"
msgstr ""
"Якщо ви намагаєтеся створити узагальнений декоратор, ви можете передати "
"``*args`` і ``**kwargs`` замість точних аргументів:"

#: ../../src/basics/decorators.txt:308
msgid "Passing arguments to decorator"
msgstr "Передача аргументів до декоратора"

#: ../../src/basics/decorators.txt:310
msgid ""
"At last it's time to know how to pass arguments to the decorator. Here is a "
"simple implementation of ``defer`` decorator which deferred the function "
"execution for some time:"
msgstr ""
"Нарешті прийшов час дізнатися, як передавати аргументи декоратору. Ось "
"проста реалізація декоратора ``defer``, який відкладає виконання функції на "
"деякий час:"

#: ../../src/basics/decorators.txt:353
msgid "Class decorators"
msgstr "Декоратори класів"

#: ../../src/basics/decorators.txt:355
msgid ""
"There are some pre-defined decorators exists for usage together with "
"classes. They are:"
msgstr ""
"Існує декілька попередньо визначених декораторів для використання разом з "
"класами. Ось вони:"

#: ../../src/basics/decorators.txt:358
msgid "``classmethod``"
msgstr "``classmethod``"

#: ../../src/basics/decorators.txt:359
msgid "``staticmethod``"
msgstr "``staticmethod``"

#: ../../src/basics/decorators.txt:360
msgid "``property``"
msgstr "``property``"

#: ../../src/basics/decorators.txt:362
msgid ""
"If you develop an intuitive understanding for their differences you'll be "
"able to write object-oriented Python that communicates its intent more "
"clearly and will be easier to maintain in the long run :cite:`realpython:"
"methods-demystified`."
msgstr ""
"Якщо ви розвинете інтуїтивне розуміння їх відмінностей, ви зможете писати "
"об'єктно-орієнтований Python, який більш чітко передає свої наміри і який "
"буде легше підтримувати в довгостроковій перспективі :cite:`realpython:"
"methods-demystified`."

#: ../../src/basics/decorators.txt:368
msgid "Class methods"
msgstr "Методи класу"

#: ../../src/basics/decorators.txt:370
msgid ""
"Instead of accepting a ``self`` parameter, class methods take a ``cls`` "
"parameter that points to the class — and not the object instance — when the "
"method is called."
msgstr ""
"Замість того, щоб приймати параметр ``self``, методи класу приймають "
"параметр ``cls``, який вказує на клас - а не на екземпляр об'єкта - під час "
"виклику методу."

#: ../../src/basics/decorators.txt:374
msgid ""
"Because the class method only has access to this ``cls`` argument, it can't "
"modify object instance state. That would require access to ``self``. "
"However, class methods can still modify class state that applies across all "
"instances of the class."
msgstr ""
"Оскільки метод класу має доступ лише до цього аргументу ``cls``, він не може "
"змінювати стан екземпляра об'єкта. Для цього потрібен доступ до ``self``. "
"Однак, методи класу все ще можуть змінювати стан класу, який застосовується "
"до всіх екземплярів класу."

#: ../../src/basics/decorators.txt:379
msgid ""
"The common usage for ``classmethod`` is provide alternative initializers."
msgstr ""
"Загальноприйнятим використанням ``classmethod`` є надання альтернативних "
"ініціалізаторів."

#: ../../src/basics/decorators.txt:382
msgid "Static methods"
msgstr "Статичні методи"

#: ../../src/basics/decorators.txt:384
msgid ""
"This type of method takes neither a ``self`` nor a ``cls`` parameter (but of "
"course it's free to accept an arbitrary number of other parameters)."
msgstr ""
"Цей тип методів не приймає ні параметра ``self``, ні параметра ``cls`` (але, "
"звичайно, він може приймати довільну кількість інших параметрів)."

#: ../../src/basics/decorators.txt:387
msgid ""
"Therefore a static method can neither modify object state nor class state. "
"Static methods are restricted in what data they can access - and they're "
"primarily a way to namespace your methods."
msgstr ""
"Тому статичний метод не може змінювати стан об'єкта або класу. Статичні "
"методи обмежені в доступі до даних, до яких вони можуть отримати доступ - і "
"це, насамперед, спосіб організації простору імен ваших методів."

#: ../../src/basics/decorators.txt:391
msgid ""
"It's tricky to explain ``staticmethod`` usage. Almost always you can create "
"a dedicated function instead of static method. But sometimes you need to "
"bind some logic independent from class itself or its instances to a class - "
"it common to encapsulate it with ``staticmethod``."
msgstr ""
"Пояснити використання ``staticmethod`` досить складно. Майже завжди замість "
"статичного методу можна створити спеціальну функцію. Але іноді вам потрібно "
"прив'язати до класу деяку логіку, незалежну від самого класу або його "
"екземплярів, і тоді прийнято інкапсулювати її за допомогою ``staticmethod``."

#: ../../src/basics/decorators.txt:397
msgid "Properties"
msgstr "Властивості"

#: ../../src/basics/decorators.txt:399
msgid ""
"It's a way to bind a method name to access it as an attribute. Properties "
"are **read-only** by default. This means a value cannot be assigned to "
"``property member``."
msgstr ""
"Це спосіб зв'язати ім'я методу для доступу до нього як до атрибуту. За "
"замовчуванням властивості доступні лише для читання. Це означає, що члену "
"властивості не можна присвоїти значення."

#: ../../src/basics/decorators.txt:404
msgid "Some examples"
msgstr "Деякі приклади"

#: ../../src/basics/exceptions.txt:-1
msgid "Handling exceptions in Python"
msgstr "Опрацювання винятків в Python"

#: ../../src/basics/exceptions.txt:-1
msgid "python, exceptions, handling, try, except, finally"
msgstr "python, exceptions, handling, try, except, finally"

#: ../../src/basics/exceptions.txt:11
msgid "Errors and Exceptions"
msgstr "Помилки та Bинятки"

#: ../../src/basics/exceptions.txt:13
msgid ""
"There are (at least) two distinguishable kinds of errors: *syntax errors* "
"and *exceptions* :cite:`docs-python:errors`."
msgstr ""
"Існує (принаймні) два типи помилок, які можна розрізнити: *синтаксичні "
"помилки* та *винятки* :cite:`docs-python:errors`."

#: ../../src/basics/exceptions.txt:17
msgid "Syntax errors"
msgstr "Синтаксичні помилки"

#: ../../src/basics/exceptions.txt:19
msgid "Syntax errors are also known as parsing errors."
msgstr "Синтаксичні помилки також відомі як помилки синтаксичного аналізу."

#: ../../src/basics/exceptions.txt:29
msgid ""
"The parser repeats the offending line and displays a little \"arrow\" "
"pointing at the earliest point in the line where the error was detected. The "
"error is caused by (or at least detected at) the token preceding the arrow."
msgstr ""
"Синтаксичний аналізатор повторює помилковий рядок і показує маленьку "
"\"стрілку\", яка вказує на найпершу точку в рядку, де було виявлено помилку. "
"Помилка спричинена (або принаймні виявлена) лексемою, що стоїть перед "
"стрілкою."

#: ../../src/basics/exceptions.txt:34
msgid "Exceptions"
msgstr "Винятки"

#: ../../src/basics/exceptions.txt:36
msgid ""
"Even if a statement or expression is syntactically correct, it may cause an "
"error when an attempt is made to execute it. Errors detected during "
"execution are called exceptions and are not unconditionally fatal: you will "
"soon learn how to handle them in Python programs."
msgstr ""
"Навіть якщо оператор або вираз є синтаксично правильним, він може спричинити "
"помилку під час спроби його виконання. Помилки, виявлені під час виконання, "
"називаються винятками і не є безумовно фатальними: незабаром ви дізнаєтеся, "
"як поводитися з ними у програмах на Python."

#: ../../src/basics/exceptions.txt:41
msgid ""
"Exceptions come in different types, and the type is printed as part of the "
"message."
msgstr ""
"Винятки бувають різних типів, і тип виводиться як частина повідомлення."

#: ../../src/basics/exceptions.txt:44
msgid "For example, the ``div`` function implemented as"
msgstr "Наприклад, функція ``div``, реалізована як"

#: ../../src/basics/exceptions.txt:53
msgid ""
"may cause a ``ZeroDivisionError`` exception in case 0 is passed as ``y`` "
"parameter."
msgstr ""
"може спричинити виключення ``ZeroDivisionError`` у випадку, якщо як параметр "
"``y`` передано 0."

#: ../../src/basics/exceptions.txt:56
msgid ""
"Standard exception names are built-in identifiers (not reserved keywords)."
msgstr ""
"Стандартні імена винятків є вбудованими ідентифікаторами (не зарезервованими "
"ключовими словами)."

#: ../../src/basics/exceptions.txt:58
msgid "The list of `built-in exceptions`_"
msgstr "Список `вбудованих винятків`_"

#: ../../src/basics/exceptions.txt:61
msgid "Tracebacks"
msgstr "Відслідковування"

#: ../../src/basics/exceptions.txt:63
msgid "\"File\" is replaced with a *dummy string* within the examples."
msgstr "У прикладах слово \"файл\" замінено на *фіктивний рядок*."

#: ../../src/basics/exceptions.txt:65
msgid "Let's assume the following modules structure:"
msgstr "Припустимо наступну структуру модулів:"

#: ../../src/basics/exceptions.txt:73
msgid ""
"The **main** module imports a ``div`` function implemented above from the "
"**func** module. The code in main is implemented as follows:"
msgstr ""
"Модуль **main** імпортує функцію ``div``, реалізовану вище, з модуля "
"**func**. Код в main реалізовано наступним чином:"

#: ../../src/basics/exceptions.txt:85
msgid ""
"While running the code with correct inputs it will work fine. But there are "
"at two exceptions for this script."
msgstr ""
"При виконанні коду з коректними вхідними даними він буде працювати "
"нормально. Але для цього скрипта є два винятки."

#: ../../src/basics/exceptions.txt:88
msgid ""
"The first one is related on type conversion. While running the main script "
"there is case of invalid input."
msgstr ""
"Перша пов'язана з перетворенням типів. Під час запуску основного скрипту "
"виникає випадок некоректного введення."

#: ../../src/basics/exceptions.txt:100
msgid ""
"Note the **traceback** indicates the module and the exact line of code that "
"causes the exception."
msgstr ""
"Зверніть увагу, що **traceback** вказує на модуль і точний рядок коду, який "
"викликає виключення."

#: ../../src/basics/exceptions.txt:103
msgid ""
"The second one exception occurs when a 0 is passed as the second parameter "
"to ``div`` function. The traceback would look like:"
msgstr ""
"Другий виняток виникає, коли в якості другого параметра у функцію ``div`` "
"передається 0. Трасування буде мати вигляд:"

#: ../../src/basics/exceptions.txt:117
msgid ""
"The traceback indicates all calls (top to bottom) that cause an exception."
msgstr "Трасування показує всі виклики (зверху вниз), які викликають виняток."

#: ../../src/basics/exceptions.txt:120 ../../src/basics/syntax.txt
msgid "Exception handling"
msgstr "Обробка виняткових ситуацій"

#: ../../src/basics/exceptions.txt:122
msgid ""
"It is possible to write programs that handle selected exceptions. The "
"``try`` statement is used to do that."
msgstr ""
"Можна писати програми, які обробляють вибрані виключення. Для цього "
"використовується інструкція ``try``."

#: ../../src/basics/exceptions.txt:125
msgid "The try statement works as follows."
msgstr "Інструкція try працює наступним чином."

#: ../../src/basics/exceptions.txt:127
msgid ""
"First, the try clause (the statement(s) between the try and except keywords) "
"is executed."
msgstr ""
"Спочатку виконується блок try (оператор(и) між ключовими словами try та "
"except)."

#: ../../src/basics/exceptions.txt:129
msgid ""
"If no exception occurs, the except clause is skipped and execution of the "
"try statement is finished."
msgstr ""
"Якщо виключення не виникає, то блок except пропускається і виконання try "
"завершується."

#: ../../src/basics/exceptions.txt:131
msgid ""
"If an exception occurs during execution of the try clause, the rest of the "
"clause is skipped. Then, if its type matches the exception named after the "
"except keyword, the except clause is executed, and then execution continues "
"after the try/except block."
msgstr ""
"Якщо під час виконання оператора try виникає виняток, решта оператора "
"пропускається. Потім, якщо тип виключення збігається з типом виключення, "
"названим ключовим словом except, виконується умова except, а потім виконання "
"продовжується після блоку try/except."

#: ../../src/basics/exceptions.txt:135
msgid ""
"If an exception occurs which does not match the exception named in the "
"except clause, it is passed on to outer try statements; if no handler is "
"found, it is an unhandled exception and execution stops with a message as "
"shown above."
msgstr ""
"Якщо виникає виняток, який не збігається з виключенням, названим в операторі "
"except, він передається зовнішнім операторам try; якщо оброблювач не "
"знайдено, це необроблений виняток, і виконання зупиняється з повідомленням, "
"як показано вище."

#: ../../src/basics/exceptions.txt:152
msgid ""
"A try statement may have more than one except clause, to specify handlers "
"for different exceptions."
msgstr ""
"Оператор try може мати більше одного оператора except, щоб вказати обробники "
"для різних винятків."

#: ../../src/basics/exceptions.txt:182
msgid "Handling ALL exception"
msgstr "Обробка ВСІХ винятків"

#: ../../src/basics/exceptions.txt:184
msgid "It's a bad practice to handle **all** exceptions."
msgstr "Погана практика - обробляти **всі** винятки."

#: ../../src/basics/exceptions.txt:186
msgid ""
"When indicating an ``except`` block without specifying an exception to catch "
"it will work for any exception, that occurs in ``try`` block. The same is "
"relevant for handling ``BaseException`` and ``Exception``. But you can never "
"say what exact goes wrong."
msgstr ""
"Якщо вказати блок ``except`` без вказівки виключення, яке потрібно "
"перехопити, то він буде працювати для будь-якого виключення, яке виникне в "
"блоці ``try``. Те ж саме стосується обробки винятків ``BaseException`` та "
"``Exception``. Але ніколи не можна сказати, що саме відбувається не так."

#: ../../src/basics/exceptions.txt:191
msgid ""
"However, this scenario may work for logging an exception and raising it "
"again to be handled on upper levels."
msgstr ""
"Однак цей сценарій може спрацювати для реєстрації винятку та його повторного "
"підняття для обробки на верхніх рівнях."

#: ../../src/basics/exceptions.txt:213
msgid ""
"All exceptions are inherited from ``Exception`` class, which is subclass of "
"``BaseException``. So, you can never know what exactly goes wrong with your "
"code."
msgstr ""
"Усі виключення успадковуються від класу ``Exception``, який є підкласом "
"класу ``BaseException``. Таким чином, ви ніколи не можете знати, що саме йде "
"не так у вашому коді."

#: ../../src/basics/exceptions.txt:218
msgid "``finally`` statement"
msgstr "Вираз ``finally``"

#: ../../src/basics/exceptions.txt:220
msgid ""
"The ``try`` statement cannot be used itself. This will cause "
"``SyntaxError``. Either ``except`` or ``finally`` block is required to be "
"included."
msgstr ""
"Оператор ``try`` не можна використовувати самостійно. Це призведе до "
"виникнення ``синтаксичної помилки``. Необхідно включити блок ``except`` або "
"``finally``."

#: ../../src/basics/exceptions.txt:223
msgid ""
"While the ``except`` block tries to catch the exceptions if any, the "
"``finally`` block will be always executed regardless of the exception occurs."
msgstr ""
"У той час як блок ``except`` намагається перехопити винятки, якщо такі є, "
"блок ``finally`` буде виконано завжди, незалежно від того, чи виникає "
"виняток."

#: ../../src/basics/exceptions.txt:249
msgid "``else`` statement"
msgstr "Вираз ``else``"

#: ../../src/basics/exceptions.txt:251
msgid ""
"The ``try`` statement can also use ``else`` (which is optional). The "
"statements within this block will be execute only in case there were no "
"exceptions raised while running the ``try``."
msgstr ""
"Оператор ``try`` може також використовувати ``else`` (необов'язково). "
"Оператори у цьому блоці будуть виконані лише у тому випадку, якщо під час "
"виконання ``try`` не було згенеровано винятків."

#: ../../src/basics/exceptions.txt:273
msgid "Raising exceptions"
msgstr "Створення винятків"

#: ../../src/basics/exceptions.txt:275
msgid ""
"The ``raise`` statement allows the programmer to force a specified exception "
"to occur. The sole argument to raise indicates the exception to be raised. "
"This must be either an exception instance or an exception class (a class "
"that derives from ``BaseException``, such as ``Exception`` or one of its "
"subclasses). If an exception class is passed, it will be implicitly "
"instantiated by calling its constructor with no arguments."
msgstr ""
"Оператор ``raise`` дозволяє програмісту примусово згенерувати вказане "
"виключення. Єдиний аргумент raise вказує на виключення, яке потрібно "
"згенерувати. Це має бути або екземпляр виключення, або клас виключення "
"(клас, який є похідним від ``BaseException``, наприклад, ``Exception`` або "
"один з його підкласів). Якщо передається клас виключення, він буде неявно "
"інстанційований шляхом виклику його конструктора без аргументів."

#: ../../src/basics/exceptions.txt:287
msgid ""
"``raise`` statement itself will re-raise all the exceptions within the "
"context. Also exceptions can be raised again from the ``except`` block. It's "
"a common pattern to catch the exception for loggers and when re-raise it."
msgstr ""
"Оператор ``raise`` сам по собі повторно підніме всі винятки в контексті. "
"Також винятки можна згенерувати повторно з блоку ``except``. Це звичайний "
"патерн для перехоплення винятку для логів і повторного його здіймання."

#: ../../src/basics/exceptions.txt:300
msgid "Creating custom exceptions"
msgstr "Створення власних винятків"

#: ../../src/basics/exceptions.txt:302
msgid ""
"Programs may name their own exceptions by creating a new exception class. "
"Exceptions should typically be derived from the Exception class, either "
"directly or indirectly."
msgstr ""
"Програми можуть називати власні винятки, створюючи новий клас винятків. "
"Винятки, як правило, мають бути похідними від класу Exception, прямо або "
"опосередковано."

#: ../../src/basics/exceptions.txt:306
msgid ""
"Exception classes can be defined which do anything any other class can do, "
"but are usually kept simple, often only offering a number of attributes that "
"allow information about the error to be extracted by handlers for the "
"exception."
msgstr ""
"Можна визначити класи винятків, які можуть робити все, що може робити будь-"
"який інший клас, але зазвичай вони є простими, часто пропонуючи лише "
"декілька атрибутів, які дозволяють обробникам винятків витягувати інформацію "
"про помилку."

#: ../../src/basics/exceptions.txt:311
msgid ""
"Most exceptions are defined with names that end in \"Error\", similar to the "
"naming of the standard exceptions."
msgstr ""
"Більшість винятків визначено з іменами, які закінчуються на \"Error\", "
"подібно до іменування стандартних винятків."

#: ../../src/basics/exceptions.txt:314
msgid ""
"Many standard modules define their own exceptions to report errors that may "
"occur in functions they define."
msgstr ""
"Багато стандартних модулів визначають власні винятки для повідомлення про "
"помилки, які можуть виникнути у визначених ними функціях."

#: ../../src/basics/exceptions.txt:317
msgid "User-defined exception"
msgstr "Виняток, визначений користувачем"

#: ../../src/basics/functions.txt:-1
msgid "Python functions"
msgstr "Функції в Python"

#: ../../src/basics/functions.txt:-1
msgid "python, basics, functions"
msgstr "python, basics, functions"

#: ../../src/basics/functions.txt:8 ../../src/basics/modules.txt:8
#: ../../src/basics/pep8.txt:8 ../../src/basics/testing.txt:8
msgid "Page is under construction"
msgstr "Сторінка знаходиться на стадії розробки"

#: ../../src/basics/functions.txt:16 ../../src/basics/syntax.txt
msgid "Functions"
msgstr "Функції"

#: ../../src/basics/index.txt:-1
msgid "Python course - Basics"
msgstr "Курс Python - Основи"

#: ../../src/basics/index.txt:-1
msgid "python, basics, index"
msgstr "python, basics, index"

#: ../../src/basics/index.txt:8
msgid "Python Basics"
msgstr "Основи Python"

#: ../../src/basics/modules.txt:-1
msgid "Modules and imports in Python"
msgstr "Модулі та імпорти в Pythons"

#: ../../src/basics/modules.txt:-1
msgid "python, basics, modules, import"
msgstr "python, basics, modules, import"

#: ../../src/basics/modules.txt:16
msgid "Pythons Modules and Imports"
msgstr "Модулі та Імпорти в Pythons"

#: ../../src/basics/pep8.txt:-1
msgid "PEP-8 style guide"
msgstr "Керівництво зі стилю PEP-8"

#: ../../src/basics/pep8.txt:-1
msgid "python, style, guide"
msgstr "python, style, guide"

#: ../../src/basics/pep8.txt:16
msgid "Style Guides: PEP8"
msgstr "Керівництва зі стилю: PEP8"

#: ../../src/basics/stdtypes.txt:-1
msgid "Python built-in types"
msgstr "Вбудовані типи даних в Python"

#: ../../src/basics/stdtypes.txt:-1
msgid "python, basics"
msgstr "python, basics"

#: ../../src/basics/stdtypes.txt:8
msgid "Built-in Types"
msgstr "Вбудовані Типи"

#: ../../src/basics/stdtypes.txt:10
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions :cite:`docs-python:stdtypes`. This section covers "
"only the most base of them. Others will be discussed in the future within "
"their own topics."
msgstr ""
"Основними вбудованими типами є числа, послідовності, відображення, класи, "
"екземпляри та винятки :cite:`docs-python:stdtypes`. У цьому розділі "
"розглянуто лише найпростіші з них. Інші будуть розглянуті в майбутньому у "
"відповідних темах."

#: ../../src/basics/stdtypes.txt:16
msgid "Numeric types"
msgstr "Числові типи"

#: ../../src/basics/stdtypes.txt:18
msgid ""
"There are 3 distinct numeric types: *integers*, *floating point numbers*, "
"and *complex numbers*. In addition, Booleans are a subtype of integers. "
"Integers have unlimited precision. Floating point numbers are usually "
"implemented using ``double`` in C. Complex numbers have a real and imaginary "
"part, which are each a floating point number."
msgstr ""
"Існує 3 різних числових типи: *цілі числа*, *числа з плаваючою комою* та "
"*комплексні числа*. Крім того, булеві числа є підтипом цілих чисел. Цілі "
"числа мають необмежену точність. Числа з плаваючою комою зазвичай "
"реалізуються за допомогою ``double`` у C. Комплексні числа мають дійсну та "
"уявну частини, кожна з яких є числом з плаваючою комою."

#: ../../src/basics/stdtypes.txt:24
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators. Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers. Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers. Appending ``j`` or "
"``J`` to a numeric literal yields an imaginary number (a complex number with "
"a zero real part) which you can add to an integer or float to get a complex "
"number with real and imaginary parts."
msgstr ""
"Числа створюються за допомогою числових літералів або як результат "
"вбудованих функцій та операторів. Цілі літерали без прикрас (включаючи "
"шістнадцяткові, вісімкові та двійкові числа) створюють цілі числа. Числові "
"літерали, що містять десяткову крапку або знак експоненти, дають числа з "
"плаваючою комою. Додавання ``j`` або ``J`` до числового літерала дає уявне "
"число (комплексне число з нульовою дійсною частиною), яке ви можете додати "
"до цілого числа або числа з плаваючою комою, щоб отримати комплексне число з "
"дійсною та уявною частинами."

#: ../../src/basics/stdtypes.txt:33
msgid "Supported operations"
msgstr "Операції, які підтримуються"

#: ../../src/basics/stdtypes.txt:36 ../../src/basics/stdtypes.txt:154
#: ../../src/basics/stdtypes.txt:204
msgid "Operation"
msgstr "Операція"

#: ../../src/basics/stdtypes.txt:36 ../../src/basics/stdtypes.txt:154
#: ../../src/basics/stdtypes.txt:204
msgid "Result"
msgstr "Результат"

#: ../../src/basics/stdtypes.txt:38
msgid "``x + y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:38
msgid "sum of *x* and *y*"
msgstr "сума *x* і *y*"

#: ../../src/basics/stdtypes.txt:40
msgid "``x - y``"
msgstr "``x - y``"

#: ../../src/basics/stdtypes.txt:40
msgid "difference of *x* and *y*"
msgstr "різниця між *x* і *y*"

#: ../../src/basics/stdtypes.txt:42
msgid "``x * y``"
msgstr "``x * y``"

#: ../../src/basics/stdtypes.txt:42
msgid "product of *x* and *y*"
msgstr "добуток *x* і *y*"

#: ../../src/basics/stdtypes.txt:44
msgid "``x / y``"
msgstr "``x / y``"

#: ../../src/basics/stdtypes.txt:44
msgid "quotient of *x* and *y*"
msgstr "частка *x* і *y*"

#: ../../src/basics/stdtypes.txt:46
msgid "``x // y``"
msgstr "``x // y``"

#: ../../src/basics/stdtypes.txt:46
msgid "floored quotient of *x* and *y*"
msgstr "цілочисельне ділення *x* і *y*"

#: ../../src/basics/stdtypes.txt:48
msgid "``x % y``"
msgstr "``x % y``"

#: ../../src/basics/stdtypes.txt:48
msgid "remainder of ``x / y``"
msgstr "залишок від ділення ``x / y``"

#: ../../src/basics/stdtypes.txt:50
msgid "``-x``"
msgstr "``-x``"

#: ../../src/basics/stdtypes.txt:50
msgid "*x* negated"
msgstr "*x* від'ємне"

#: ../../src/basics/stdtypes.txt:52
msgid "``+x``"
msgstr "``+x``"

#: ../../src/basics/stdtypes.txt:52
msgid "*y* unchanged"
msgstr "*y* без змін"

#: ../../src/basics/stdtypes.txt:54
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../src/basics/stdtypes.txt:54
msgid "absolute value or magnitude of *x*"
msgstr "абсолютне значення або величина *x*"

#: ../../src/basics/stdtypes.txt:56
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../src/basics/stdtypes.txt:56
msgid "*x* converted to integer"
msgstr "*x* перетворено в ціле число"

#: ../../src/basics/stdtypes.txt:58
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../src/basics/stdtypes.txt:58
msgid "*x* converted to floating point"
msgstr "*x* перетворено у число з плаваючою комою"

#: ../../src/basics/stdtypes.txt:60
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../src/basics/stdtypes.txt:60
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"комплексне число з дійсною частиною *re* та уявною частиною *im*. За "
"замовчуванням *im* дорівнює нулю."

#: ../../src/basics/stdtypes.txt:63
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../src/basics/stdtypes.txt:63
msgid "the pair ``(x // y, x % y)``"
msgstr "об'єднує ``(x // y, x % y)``"

#: ../../src/basics/stdtypes.txt:65
msgid "``pow(x, y)`` ``x ** y``"
msgstr "``pow(x, y)`` ``x ** y``"

#: ../../src/basics/stdtypes.txt:65
msgid "*x* to the power *y*"
msgstr "*x* у степені *y*"

#: ../../src/basics/stdtypes.txt:69
msgid ""
"``x // y`` also referred to as integer division. The resultant value is a "
"whole integer, through the result's type is not necessarily int. The result "
"is always rounded towards minus infinity: ``1 // 2`` is ``0``"
msgstr ""
"``x // y`` також називається цілочисельним діленням. Значення результату є "
"цілим числом, оскільки тип результату не обов'язково int. Результат завжди "
"округлюється до мінус нескінченності: ``1 // 2`` є ``0``"

#: ../../src/basics/stdtypes.txt:74
msgid ""
"``float(x)`` also accepts the strings ``\"nan\"`` and ``\"inf\"`` with an "
"optional prefix \"+\" or \"-\" for :abbr:`NaN(Not a Number)` and positive "
"and negative infinity."
msgstr ""
"``float(x)`` також приймає рядки ``\"nan\"`` та ``\"inf\"`` з необов'язковим "
"префіксом \"+\" або \"-\" для :abbr:`NaN(Not a Number)`` та додатної і "
"від'ємної нескінченності."

#: ../../src/basics/stdtypes.txt:79
msgid "Code examples"
msgstr "Приклади коду"

#: ../../src/basics/stdtypes.txt:81
msgid "Integer numbers"
msgstr "Цілі числа"

#: ../../src/basics/stdtypes.txt:94
msgid "Floating point numbers"
msgstr "Числа з плаваючою комою"

#: ../../src/basics/stdtypes.txt:109 ../../src/basics/stdtypes.txt:182
#: ../../src/basics/stdtypes.txt:290 ../../src/basics/stdtypes.txt:299
#: ../../src/basics/stdtypes.txt:328
msgid "Value comparisons"
msgstr "Порівняння значень"

#: ../../src/basics/stdtypes.txt:111
msgid ""
"Numbers of built-in numeric types can be compared within and across their "
"types (with the restriction that complex numbers do not support order "
"comparison). Within the limits of the types involved, they compare "
"mathematically correct without loss of precision."
msgstr ""
"Числа вбудованих числових типів можна порівнювати всередині та між типами (з "
"обмеженням, що комплексні числа не підтримують порівняння порядків). У межах "
"відповідних типів вони порівнюються математично коректно без втрати точності."

#: ../../src/basics/stdtypes.txt:116
msgid ""
"The \"not-a-number\" values ``float(\"NaN\")`` and ``decimal."
"Decimal('NaN')`` are special. Any ordered comparison of a number to a not-a-"
"number value is false."
msgstr ""
"Значення \"не-число\" ``float(\"NaN\")`` та ``decimal.Decimal('NaN')`` є "
"спеціальними. Будь-яке впорядковане порівняння числа зі значенням \"не-"
"число\" є хибним."

#: ../../src/basics/stdtypes.txt:120
msgid "Sequence types"
msgstr "Типи послідовностей"

#: ../../src/basics/stdtypes.txt:122
msgid ""
"There are 3 basic sequence types: *lists*, *tuples*, and *range objects*. "
"Additional sequence types tailored for processing of binary data and text "
"strings are described in dedicated sections."
msgstr ""
"Існує 3 основних типи послідовностей: *списки*, *кортежі* та *об'єкти "
"діапазону*. Додаткові типи послідовностей, призначені для обробки двійкових "
"даних і текстових рядків, описано у відповідних розділах."

#: ../../src/basics/stdtypes.txt:127
msgid "Lists"
msgstr "Списки"

#: ../../src/basics/stdtypes.txt:129
msgid ""
"Lists are mutable sequences, typically used to store collections of items. "
"They may be constructed in several ways:"
msgstr ""
"Списки - це змінні послідовності, які зазвичай використовуються для "
"зберігання колекцій елементів. Вони можуть бути побудовані кількома "
"способами:"

#: ../../src/basics/stdtypes.txt:132
msgid "using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"використовуючи пару квадратних дужок для позначення порожнього списку: ``[]``"

#: ../../src/basics/stdtypes.txt:133
msgid ""
"using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"використовуючи квадратні дужки, розділяючи елементи комами: ``[a]``, ``[a, "
"b, c]``"

#: ../../src/basics/stdtypes.txt:134
msgid "using a list comprehension: ``[x for x in iterable]``"
msgstr "використовуючи генератори списків: ``[x for x in iterable]``"

#: ../../src/basics/stdtypes.txt:135
msgid "using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "використовуючи конструктор типу: ``list()`` або ``list(iterable)``"

#: ../../src/basics/stdtypes.txt:138
msgid "Tuples"
msgstr "Кортежі"

#: ../../src/basics/stdtypes.txt:140
msgid ""
"Tuples are immutable sequences, typically used to store collections of data "
"or for cases where an immutable sequence of data is needed (such as allowing "
"storage in a ``set`` or ``dict`` instances). They may be constructed in a "
"number of ways:"
msgstr ""
"Кортежі - це незмінні послідовності, які зазвичай використовуються для "
"зберігання наборів даних або у випадках, коли потрібна незмінна "
"послідовність даних (наприклад, для зберігання в екземплярах ``set`` або "
"``dict``). Вони можуть бути побудовані кількома способами:"

#: ../../src/basics/stdtypes.txt:145
msgid "using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"використовуючи пару круглих дужок для позначення порожнього кортежу: ``()``"

#: ../../src/basics/stdtypes.txt:146
msgid "using a trailing comma for a singleton tuple: ``a,`` or ``(a, b, c)``"
msgstr ""
"з використанням кінцевої коми для одиночного кортежу: ``a,`` або ``(a, b, "
"c)``"

#: ../../src/basics/stdtypes.txt:147
msgid "separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "розділення елементів комами: ``a, b, c`` або ``(a, b, c)``"

#: ../../src/basics/stdtypes.txt:148
msgid "using the type constructor: ``tuple()`` or ``tuple(iterable)``"
msgstr "з використанням конструктора типу: ``tuple()`` або ``tuple(iterable)``"

#: ../../src/basics/stdtypes.txt:151
msgid "Common operations"
msgstr "Спільні операції"

#: ../../src/basics/stdtypes.txt:156
msgid "``x in s`` ``x not in s``"
msgstr "``x in s`` ``x not in s``"

#: ../../src/basics/stdtypes.txt:156
msgid ""
"``True`` if an item of *s* equal to *x* ``False`` if an item of *s* equal to "
"*x*"
msgstr ""
"``True``, якщо елемент *s* дорівнює *x* ``False``, якщо елемент *s* дорівнює "
"*x*"

#: ../../src/basics/stdtypes.txt:159
msgid "``s + t``"
msgstr "``s + t``"

#: ../../src/basics/stdtypes.txt:159
msgid "the concatenation of *s* and *t*"
msgstr "конкатенація *s* та *t*"

#: ../../src/basics/stdtypes.txt:161
msgid "``s * n``"
msgstr "``s * n``"

#: ../../src/basics/stdtypes.txt:161
msgid "equivalent to adding *s* to itself *n* times"
msgstr "еквівалентно додаванню *s* до самого себе *n* разів"

#: ../../src/basics/stdtypes.txt:163
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../src/basics/stdtypes.txt:163
msgid "*i*-th item of *s*, origin 0"
msgstr "*i*-й елемент з *s*, походження 0"

#: ../../src/basics/stdtypes.txt:165
msgid "``s[i:j]`` ``s[i:j:k]``"
msgstr "``s[i:j]`` ``s[i:j:k]``"

#: ../../src/basics/stdtypes.txt:165
msgid ""
"slice of *s* from *i* to *j* with step *k*. any of these (or even all 3) may "
"be omitted."
msgstr ""
"фрагмент *s* від *i* до *j* з кроком *k*. будь-який з них (або навіть всі 3) "
"можна опустити."

#: ../../src/basics/stdtypes.txt:168
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../src/basics/stdtypes.txt:168
msgid "length of *s*"
msgstr "довжина *s*"

#: ../../src/basics/stdtypes.txt:170
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../src/basics/stdtypes.txt:170
msgid "smallest item of *s*"
msgstr "найменший елемент *s*"

#: ../../src/basics/stdtypes.txt:172
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../src/basics/stdtypes.txt:172
msgid "largest item of *s*"
msgstr "найбільший елемент *s*"

#: ../../src/basics/stdtypes.txt:174
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../src/basics/stdtypes.txt:174
msgid "total number of occurrences of *x* in *s*"
msgstr "загальна кількість входжень *x* у *s*"

#: ../../src/basics/stdtypes.txt:176
msgid "``s.index(x)`` ``s.index(x, i)`` ``s.index(x, i, j)``"
msgstr "``s.index(x)`` ``s.index(x, i)`` ``s.index(x, i, j)``"

#: ../../src/basics/stdtypes.txt:176
msgid ""
"index of the first occurrence of *x* in *s* at or after index *i* and before "
"index *j*"
msgstr ""
"індекс першого входження *x* у *s* на або після індексу *i* та перед "
"індексом *j*"

#: ../../src/basics/stdtypes.txt:184
msgid ""
"Sequences can be compared only within each of their types, with the "
"restriction that ranges do not support order comparison. Equality comparison "
"across these types results in inequality, and ordering comparison across "
"these types raises ``TypeError``."
msgstr ""
"Послідовності можна порівнювати лише в межах кожного типу, з обмеженням, що "
"діапазони не підтримують порівняння за порядком. Порівняння рівності між "
"цими типами призводить до нерівності, а порівняння порядку між цими типами "
"викликає ``TypeError``."

#: ../../src/basics/stdtypes.txt:189
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements. The built-in containers typically assume identical objects are "
"equal to themselves. Lexicographical comparison between built-in collections "
"works as follows:"
msgstr ""
"Послідовності порівнюються лексикографічно за допомогою порівняння "
"відповідних елементів. Вбудовані контейнери зазвичай вважають ідентичні "
"об'єкти рівними собі. Лексикографічне порівняння між вбудованими колекціями "
"працює наступним чином:"

#: ../../src/basics/stdtypes.txt:194
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal."
msgstr ""
"Для того, щоб дві колекції були рівними, вони повинні бути одного типу, мати "
"однакову довжину і кожна пара відповідних елементів повинна порівнюватися "
"однаково."

#: ../../src/basics/stdtypes.txt:196
msgid ""
"Collections that supports order comparison are ordered the same as their "
"first unequal elements. If corresponding element does not exist, the shorter "
"collection is ordered first."
msgstr ""
"Колекції, що підтримують порівняння порядків, впорядковуються так само, як і "
"їх перші нерівні елементи. Якщо відповідного елемента не існує, то спочатку "
"впорядковується коротша колекція."

#: ../../src/basics/stdtypes.txt:201
msgid "Mutable sequence types"
msgstr "Типи змінних послідовностей"

#: ../../src/basics/stdtypes.txt:206
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../src/basics/stdtypes.txt:206
msgid "item *i* of *s* is replaced by *x*"
msgstr "елемент *i* в *s* замінюється на *x*"

#: ../../src/basics/stdtypes.txt:208
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../src/basics/stdtypes.txt:208
msgid "slice of *s* from *i* to *j* replaced by the contents of *t*"
msgstr "фрагмент *s* від *i* до *j*, замінений вмістом *t*"

#: ../../src/basics/stdtypes.txt:211
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../src/basics/stdtypes.txt:211
msgid "same as ``s[i:j] = []``"
msgstr "те саме, що ``s[i:j] = []``"

#: ../../src/basics/stdtypes.txt:213
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../src/basics/stdtypes.txt:213
msgid "the elements of *s* are replaced by those of *t* [#]_"
msgstr "елементи *s* замінюються елементами *t* [#]_"

#: ../../src/basics/stdtypes.txt:215
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../src/basics/stdtypes.txt:215
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "видаляє елементи ``s[i:j:k]`` зі списку"

#: ../../src/basics/stdtypes.txt:217
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../src/basics/stdtypes.txt:217
msgid ""
"appends *x* to the end of the sequence; the same as ``s[len(s):len(s)] = "
"[x]``"
msgstr ""
"додає *x* до кінця послідовності; те саме, що ``s[len(s):len(s)] = [x]``"

#: ../../src/basics/stdtypes.txt:220
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../src/basics/stdtypes.txt:220
msgid "removes all items from *s* (``del s[:]``) [#py33]_"
msgstr "видаляє всі елементи з *s* (``del s[:]``) [#py33]_"

#: ../../src/basics/stdtypes.txt:222
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../src/basics/stdtypes.txt:222
msgid "creates a shallow copy of *s* (``s[:]``) [#py33]_"
msgstr "створює поверхневу копію *s* (``s[:]``) [#py33]_"

#: ../../src/basics/stdtypes.txt:224
msgid "``s.extend(t)`` ``s += t``"
msgstr "``s.extend(t)`` ``s += t``"

#: ../../src/basics/stdtypes.txt:224
msgid "extends *s* with the contents of *t*"
msgstr "розширює *s* вмістом *t*"

#: ../../src/basics/stdtypes.txt:227
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../src/basics/stdtypes.txt:227
msgid "inserts *x* into *s* at the index *i*; same as ``s[i:i] = [x]``"
msgstr "вставляє *x* у *s* за індексом *i*; те саме, що ``s[i:i] = [x]``"

#: ../../src/basics/stdtypes.txt:230
msgid "``s.pop()``, ``s.pop(i)``"
msgstr "``s.pop()``, ``s.pop(i)``"

#: ../../src/basics/stdtypes.txt:230
msgid ""
"retrieves the item at *i* and also removes it from *s* (if *i* is omitted - "
"use the last one available index)"
msgstr ""
"отримує елемент за адресою *i*, а також видаляє його з *s* (якщо *i* "
"пропущено - використовуйте останній доступний індекс)"

#: ../../src/basics/stdtypes.txt:233
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../src/basics/stdtypes.txt:233
msgid "remove the first item that is equal to *x* from *s*"
msgstr "видалити перший елемент, який дорівнює *x*, із *s*"

#: ../../src/basics/stdtypes.txt:235
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../src/basics/stdtypes.txt:235
msgid "reverses the items of *s* in place"
msgstr "перевертає елементи *s* на місце"

#: ../../src/basics/stdtypes.txt:238
msgid "*t* must have the same length as the slice it is replacing"
msgstr "*t* повинен мати таку ж довжину, як і фрагмент, який він замінює"

#: ../../src/basics/stdtypes.txt:239
msgid "new in Python version 3.3"
msgstr "нове в Python версії 3.3"

#: ../../src/basics/stdtypes.txt:242
msgid "Text sequence type"
msgstr "Тип текстової послідовності"

#: ../../src/basics/stdtypes.txt:245
msgid "String methods"
msgstr "Методи рядків"

#: ../../src/basics/stdtypes.txt:247
msgid ""
"Strings implement all of the common sequence operations, along with the "
"additional methods."
msgstr ""
"Рядки реалізують всі звичайні операції з послідовністю, а також додаткові "
"методи."

#: ../../src/basics/stdtypes.txt:292
msgid ""
"Strings compare lexicographically using the numerical Unicode code points of "
"their characters."
msgstr ""
"Рядки порівнюються лексикографічно, використовуючи числові кодові точки "
"символів у Юнікоді."

#: ../../src/basics/stdtypes.txt:296
msgid "Set types"
msgstr "Типи множин"

#: ../../src/basics/stdtypes.txt:301
msgid ""
"Sets (instances of ``set`` or ``frozenset``) can be compared within and "
"across their types. They define order comparison operators to mean subset "
"and superset tests. Those relations do not define total ordering (e.g. two "
"sets ``{1, 2}`` and ``{2, 3}`` are not equal, nor subsets of one another, "
"nor supersets of one another)."
msgstr ""
"Множини (екземпляри ``set`` або ``frozenset``) можна порівнювати всередині "
"та між їхніми типами. Вони визначають оператори порівняння порядку, які "
"означають тести підмножин та надмножин. Ці відношення не визначають повного "
"впорядкування (наприклад, дві множини ``{1, 2}`` і ``{2, 3}`` не є рівними, "
"не є підмножинами одна одної і не є надмножинами одна одної)."

#: ../../src/basics/stdtypes.txt:308
msgid "Mapping type"
msgstr "Тип відображення"

#: ../../src/basics/stdtypes.txt:310
msgid ""
"A mapping object maps hashable values to arbitrary objects. Mappings are "
"mutable objects. There is currently ony one standard mapping type, the "
"*dictionary*. In few words mappings are collections of keys and their values."
msgstr ""
"Об'єкт зіставлення зіставляє хешовані значення з довільними об'єктами. "
"Відображення є змінними об'єктами. Наразі існує лише один стандартний тип "
"відображення, *dictionary*. Якщо кількома словами, то відображення - це "
"набори ключів та їхніх значень."

#: ../../src/basics/stdtypes.txt:314
msgid ""
"A dictionary's keys are almost arbitrary values. Values that are not "
"hashable may not be used as keys. Values that compare equal (such as ``1``, "
"``1.0`` and ``True``) can be used interchangeably to index the same "
"dictionary entry."
msgstr ""
"Ключі словника - це майже довільні значення. Значення, які не піддаються "
"хешуванню, не можна використовувати як ключі. Значення, які порівнюються як "
"рівні (наприклад, ``1``, ``1.0`` і ``True``), можуть використовуватися як "
"взаємозамінні для індексації однієї і тієї ж словникової статті."

#: ../../src/basics/stdtypes.txt:318
msgid "Dictionaries can be created by several means:"
msgstr "Словники можна створювати кількома способами:"

#: ../../src/basics/stdtypes.txt:320
msgid "Use braces to denote the empty dictionary: ``{}``"
msgstr "Використовуйте дужки для позначення порожнього словника: ``{}``"

#: ../../src/basics/stdtypes.txt:321
msgid ""
"Use a comma-separated list of ``key: value`` pairs with braces: "
"``{'first_name': 'Serhii', 'last_name': 'Horodilov', 'age': 34}``"
msgstr ""
"Використовуйте список пар ``key: value`` через кому з дужками: "
"``{'first_name': 'Serhii', 'last_name': 'Horodilov', 'age': 34}``"

#: ../../src/basics/stdtypes.txt:323
msgid "Use a dict comprehension: ``{x: x ** 2 for x in range(10)}``"
msgstr "Використовуючи генератори списків: ``{x: x 2 for x in range(10)}``"

#: ../../src/basics/stdtypes.txt:324
msgid ""
"Use the type constructor: ``dict()``, ``dict([('key', 100)])``, "
"``dict(key=100)``"
msgstr ""
"Використовуйте конструктор типу: ``dict()``, ``dict([('key', 100)])``, "
"``dict(key=100)``"

#: ../../src/basics/stdtypes.txt:330
msgid ""
"Instances of ``dict`` compare equal if and only if they have equal key-value "
"pairs."
msgstr ""
"Екземпляри ``dict`` порівнюються однаково тоді і тільки тоді, коли вони "
"мають однакові пари ключ-значення."

#: ../../src/basics/stdtypes.txt:333
#, fuzzy
msgid "Order comparisons raise ``TypeError``."
msgstr "Порівняння порядку викликає ``TypeError``."

#: ../../src/basics/syntax.txt:-1
msgid "Python syntax"
msgstr "Синтаксис Python"

#: ../../src/basics/syntax.txt:-1
msgid "python, basics, syntax"
msgstr "python, basics, syntax"

#: ../../src/basics/syntax.txt:8
msgid "Python Syntax"
msgstr "Синтаксис Python"

#: ../../src/basics/syntax.txt:10
msgid ""
"As a natural language like English or Ukrainian has its own rules to write "
"down something, programming languages do. This makes them programming "
"**languages**."
msgstr ""
"Як природна мова, наприклад, англійська чи українська, має власні правила "
"для запису чогось, так і мови програмування мають свої власні правила. Це "
"робить їх **мовами** програмування."

#: ../../src/basics/syntax.txt:14
msgid ""
"A programming language syntax is the set of rules and principles that govern "
"how code is written and structured in a given programming language. Syntax "
"encompasses the rules for writing statements, expressions, variables, data "
"types, control structures, and other constructs that make up the language."
msgstr ""
"Синтаксис мови програмування - це набір правил і принципів, які керують "
"написанням і структуруванням коду певною мовою програмування. Синтаксис "
"охоплює правила написання операторів, виразів, змінних, типів даних, "
"керуючих структур та інших конструкцій, які складають мову."

#: ../../src/basics/syntax.txt:19
msgid ""
"The syntax of a programming language defines how code is organized and "
"interpreted by a compiler or interpreter. It defines the rules for writing "
"valid statements and expressions that can be understood and executed by the "
"language's runtime system."
msgstr ""
"Синтаксис мови програмування визначає, як код організовується та "
"інтерпретується компілятором або інтерпретатором. Він визначає правила "
"написання правильних операторів і виразів, які можуть бути зрозумілі та "
"виконані системою виконання мови."

#: ../../src/basics/syntax.txt:24
msgid ""
"A programming language's syntax is designed to be both readable and "
"expressive, allowing programmers to write code that is easy to understand "
"and modify. Syntax often influences the style and structure of code, as well "
"as its maintainability and performance."
msgstr ""
"Синтаксис мови програмування розроблений таким чином, щоб бути одночасно "
"читабельним і виразним, що дозволяє програмістам писати код, який легко "
"розуміти і модифікувати. Синтаксис часто впливає на стиль і структуру коду, "
"а також на його зручність супроводу та продуктивність."

#: ../../src/basics/syntax.txt:29
msgid ""
"Different programming languages have different syntax, with some languages "
"being more concise and expressive than others. While syntax is an important "
"aspect of a programming language, it is only one of several factors that "
"determine its ease of use, flexibility, and suitability for different "
"programming tasks."
msgstr ""
"Різні мови програмування мають різний синтаксис, причому деякі мови є більш "
"стислими та виразними, ніж інші. Хоча синтаксис є важливим аспектом мови "
"програмування, він є лише одним з декількох факторів, які визначають її "
"простоту використання, гнучкість та придатність для різних завдань "
"програмування."

#: ../../src/basics/syntax.txt:35
msgid ""
"In the case of Python, the language's syntax defines how code is written and "
"structured in a way that is consistent, readable, and easy to understand. A "
"general overview is provided below, no need to dive deep in this now. All of "
"the following is to be discussed during the course. So, some of the key "
"aspects of Python's syntax include:"
msgstr ""
"У випадку з Python синтаксис мови визначає, як писати код і структурувати "
"його таким чином, щоб він був послідовним, читабельним і легким для "
"розуміння. Нижче наведено загальний огляд, немає необхідності заглиблюватися "
"в цю тему зараз. Все наступне ми будемо обговорювати під час курсу. Отже, "
"деякі з ключових аспектів синтаксису Python включають:"

#: ../../src/basics/syntax.txt
msgid "Indentation"
msgstr "Відступ"

#: ../../src/basics/syntax.txt:42
msgid ""
"Python uses whitespace, specifically indentation, to delimit blocks of code, "
"such as loops, conditionals, and functions. This means that the indentation "
"level of a line determines which block of code it belongs to."
msgstr ""
"Python використовує пробіли, зокрема відступи, для розділення блоків коду, "
"таких як цикли, умови та функції. Це означає, що рівень відступу рядка "
"визначає, до якого блоку коду він належить."

#: ../../src/basics/syntax.txt
#, fuzzy
msgid "Statement structure"
msgstr "Структура коду"

#: ../../src/basics/syntax.txt:48
msgid ""
"Python statements are typically written on one line, with the end of the "
"line indicating the end of the statement. However, if a statement is too "
"long to fit on one line, it can be continued across multiple lines using "
"backslashes."
msgstr ""
"Оператори Python зазвичай пишуться в одному рядку, кінець рядка вказує на "
"кінець оператора. Однак, якщо оператор занадто довгий і не вміщується в один "
"рядок, його можна продовжити на декілька рядків, використовуючи зворотні "
"косі риски."

#: ../../src/basics/syntax.txt ../../src/basics/variables.txt:8
msgid "Variables"
msgstr "Змінні"

#: ../../src/basics/syntax.txt:54
msgid ""
"In Python, variables are created automatically when a value is assigned to "
"them, and their type is inferred from the value. Variables can be assigned "
"values of different types, including integers, floats, strings, and more "
"complex data structures like lists and dictionaries."
msgstr ""
"У Python змінні створюються автоматично, коли їм присвоюється значення, а "
"їхній тип виводиться зі значення. Змінним можна присвоювати значення різних "
"типів, включаючи цілі числа, числа з плаваючою комою, рядки та більш складні "
"структури даних, такі як списки та словники."

#: ../../src/basics/syntax.txt
msgid "Operators"
msgstr "Оператори"

#: ../../src/basics/syntax.txt:60
msgid ""
"Python supports a wide range of operators for performing arithmetic, "
"comparison, and logical operations. These include arithmetic operators like "
"``+``, ``-``, ``*``, and ``/``, as well as comparison operators like ``<``, "
"``>``, ``==``, and ``!=``."
msgstr ""
"Python підтримує широкий спектр операторів для виконання арифметичних, "
"порівняльних та логічних операцій. До них відносяться арифметичні оператори, "
"такі як ``+``, ``-``, ``*`` і ``/``, а також оператори порівняння, такі як "
"``<``, ``>``, ``==`` і ``!=``."

#: ../../src/basics/syntax.txt
#, fuzzy
msgid "Control flow"
msgstr "Контроль потоку"

#: ../../src/basics/syntax.txt:66
msgid ""
"Python provides control flow statements like if, else, elif, for, and while "
"to control the flow of execution in a program. These statements are used to "
"make decisions, repeat code, or perform actions based on conditions."
msgstr ""
"Python надає оператори керування потоком, такі як if, else, elif, for та "
"while, щоб керувати потоком виконання програми. Ці оператори "
"використовуються для прийняття рішень, повторення коду або виконання дій на "
"основі умов."

#: ../../src/basics/syntax.txt:72
msgid ""
"In Python, functions are defined using the def keyword and can take "
"arguments and return values. The body of a function is defined using a block "
"of indented code."
msgstr ""
"У мові Python функції визначаються за допомогою ключового слова def і можуть "
"приймати аргументи та повертати значення. Тіло функції описується за "
"допомогою блоку коду з відступами."

#: ../../src/basics/syntax.txt
msgid "Modules"
msgstr "Модулі"

#: ../../src/basics/syntax.txt:77
msgid ""
"Python has a large library of modules that provide pre-written code for a "
"variety of tasks. Modules can be imported into a program using the import "
"statement."
msgstr ""
"Python має велику бібліотеку модулів, які надають заздалегідь написаний код "
"для різноманітних завдань. Модулі можна імпортувати в програму за допомогою "
"оператора import."

#: ../../src/basics/syntax.txt:82
msgid ""
"Python provides a way to handle errors and exceptions in a program using the "
"try, except, else, and finally keywords. These statements allow a program to "
"gracefully recover from errors and continue executing."
msgstr ""
"Python надає спосіб обробки помилок та винятків у програмі за допомогою "
"ключових слів try, except, else та finally. Ці оператори дозволяють програмі "
"витончено відновлюватися після помилок і продовжувати виконання."

#: ../../src/basics/syntax.txt:86
msgid "In few words:"
msgstr "У кількох словах:"

#: ../../src/basics/syntax.txt:88
msgid "Input/Output example script"
msgstr "Приклад скрипту вводу/виводу"

#: ../../src/basics/syntax.txt:107
msgid ""
"The code snippet above demonstrates some basics abilities of Python to "
"gather data from the user, process it and print out back. Note the words "
"starting with a # (hash) symbol. This is a comment. Any sequence of "
"characters after the hash and till the line end are considered to be a "
"comment. These are for those people, who see the code and they are ignored "
"by the interpreter."
msgstr ""
"Фрагмент коду вище демонструє деякі базові можливості Python для збору даних "
"від користувача, їх обробки та виведення назад. Зверніть увагу на слова, що "
"починаються з символу # (хеш). Це коментар. Будь-яка послідовність символів "
"після хешу і до кінця рядка вважається коментарем. Вони призначені для тих "
"людей, які бачать код, а інтерпретатор їх ігнорує."

#: ../../src/basics/syntax.txt:113
msgid ""
"On the other hand each individual line is the instruction for the "
"interpreter to perform some action, like gather inputs, do math, store data "
"in memory etc."
msgstr ""
"З іншого боку, кожен окремий рядок є інструкцією для інтерпретатора виконати "
"певну дію, наприклад, зібрати вхідні дані, виконати обчислення, зберегти "
"дані в пам'яті тощо."

#: ../../src/basics/testing.txt:-1
msgid "Testing software in Python"
msgstr "Тестування програмного забезпечення на Python"

#: ../../src/basics/testing.txt:-1
msgid "python, testing, unittest, pytest"
msgstr "python, testing, unittest, pytest"

#: ../../src/basics/testing.txt:16
msgid "Testing"
msgstr "Тестування"

#: ../../src/basics/variables.txt:-1
msgid "Variables in programming"
msgstr "Змінні в програмуванні"

#: ../../src/basics/variables.txt:-1
msgid "programming, basics, variables"
msgstr "programming, basics, variables"

#: ../../src/basics/variables.txt:10
msgid ""
"In computer science a **variable** is a named storage location in memory "
"that can hold a value (*data*). The value stored in a variable can be "
"changed or accessed by the program during its execution."
msgstr ""
"У комп'ютерних науках **змінна** - це іменована комірка пам'яті, яка може "
"зберігати значення (*дані*). Значення, що зберігається у змінній, може бути "
"змінене або доступне програмі під час її виконання."

#: ../../src/basics/variables.txt:14
msgid ""
"In Python, variables are created dynamically once a value is assigned to "
"them. This makes Python a dynamically typed language, which means that the "
"data type of a variable is inferred from the value assigned to it. So, you "
"do not need to declare a variable before using it, as in statically typed "
"languages."
msgstr ""
"У Python змінні створюються динамічно, щойно їм присвоюється значення. Це "
"робить Python динамічно типізованою мовою, що означає, що тип даних змінної "
"виводиться з присвоєного їй значення. Отже, вам не потрібно оголошувати "
"змінну перед її використанням, як у мовах зі статичною типізацією."

#: ../../src/basics/variables.txt:19
msgid ""
"The ability to create variables dynamically and infer their data type makes "
"Python code more concise and easier to read. However, it also requires "
"careful attention to variable naming and assignment to avoid unexpected "
"behavior."
msgstr ""
"Можливість динамічно створювати змінні та визначати тип їхніх даних робить "
"код Python лаконічнішим і легшим для читання. Однак, це також вимагає "
"ретельної уваги до іменування та присвоєння змінних, щоб уникнути "
"неочікуваної поведінки."

#: ../../src/basics/variables.txt:23
msgid ""
"In Python ``=`` (assignment operator) is used to set a value to some "
"variable, the portion on the left of the operator is a *variable name* and "
"the portion on the right is a *value* to assign to a variable."
msgstr ""
"У Python ``=`` (оператор присвоювання) використовується для присвоєння "
"значення деякій змінній, частина ліворуч від оператора - це *ім'я змінної*, "
"а частина праворуч - це *значення*, яке потрібно присвоїти змінній."

#: ../../src/basics/variables.txt:27
msgid "Variable assignment in Python"
msgstr "Присвоєння змінних у Python"

#: ../../src/basics/variables.txt:34
msgid "Variable assignment in Java"
msgstr "Присвоєння змінних у Java"

#: ../../src/basics/variables.txt:42
msgid "Naming"
msgstr "Іменування"

#: ../../src/basics/variables.txt:44
msgid ""
"In Python there are several rules that describe how to name your variables. "
"Some of these are requirements and cannot be ignored, others are rather "
"recommended than required and can be omitted. For now note, that a variable "
"name **cannot**:"
msgstr ""
"У Python є кілька правил, які описують, як називати ваші змінні. Деякі з них "
"є обов'язковими і не можуть бути проігноровані, інші є скоріше "
"рекомендаційними, ніж обов'язковими, і їх можна опустити. Наразі зауважте, "
"що ім'я змінної **не може**:"

#: ../../src/basics/variables.txt:49
msgid "a language keyword (like ``pass``, ``def`` or ``class``)"
msgstr "ключовим словом мови (наприклад, ``pass``, ``def`` або ``class``)"

#: ../../src/basics/variables.txt:50
msgid "start with a number (e.g. ``123``, ``1_something``)"
msgstr "починатись з числа (наприклад, ``123``, ``1_something``)"

#: ../../src/basics/variables.txt:51
msgid "contain special operators in it (``+``, ``-``, ``=`` etc.)"
msgstr "містити спеціальні оператори (``+``, ``-``, ``=`` тощо)."

#: ../../src/basics/variables.txt:52
msgid "contain white spaces"
msgstr "містити пробіли"

#: ../../src/basics/variables.txt:54
msgid "Also here are some general recommendation on naming anything:"
msgstr ""
"Також тут є кілька загальних рекомендацій щодо того, як називати будь-що:"

#: ../../src/basics/variables.txt:56
msgid "do not use built-in functions as a variable name (e.g. ``len = 42``)"
msgstr ""
"не використовуйте вбудовані функції як ім'я змінної (наприклад, ``len = 42``)"

#: ../../src/basics/variables.txt:57
msgid "keep names meaningful (``x = 10`` vs ``number_of_student = 100``)"
msgstr ""
"зберігайте змістовність імен (``x = 10`` проти ``number_of_student = 100``)"

#~ msgid "Data Types"
#~ msgstr "Типи Даних"

#~ msgid ""
#~ "Data may represent different things and require various operations "
#~ "available. In programming data types is an important concept. For example "
#~ "**1984** may be a number (``1984``), a text (``\"1984\"``) or event a "
#~ "date. The data type describes the operations, that are allowed for the "
#~ "data, like additions for numbers or concatenation for text (e.g. ``1 + 2 -"
#~ "> 3``, ``\"1\" + \"3\" -> \"13\"``)."
#~ msgstr ""
#~ "Дані можуть представляти різні речі та вимагати різноманітних "
#~ "доступнихоперацій. У програмуванні типи даних є важливою концепцією. "
#~ "Наприклад, **1984** може бути числом (``1984``), текстом (``\"1984\"`` ) "
#~ "або подією чи датою. Тип даних описує можливі операції, дозволені для "
#~ "даних, як-от додавання чисел або конкатенація для тексту (наприклад, ``1 "
#~ "+ 2 -> 3``, ``\"1\" + \"3 \" -> \"13\"``)."

#~ msgid ""
#~ "Python uses dynamic typing. This means as a developer you should not "
#~ "declare a variable with its data type - the interpreter will do this for "
#~ "you. Other popular language using dynamic typing are JavaScript and PHP. "
#~ "Setting variables in Python is as easy as:"
#~ msgstr ""
#~ "Python використовує динамічну типізацію. Це означає, що ви, як розробник, "
#~ "не повинні оголошувати змінну з її типом даних - інтерпретатор зробить це "
#~ "за вас. Іншими популярними мовами, які використовують динамічну "
#~ "типізацію, є JavaScript і PHP. Налаштування змінних у Python доволі "
#~ "просто, як: "

#~ msgid "Built-In Data Types"
#~ msgstr "Вбудовані типи даних"

#~ msgid "Python has the following data types built-in:"
#~ msgstr "Python має такі вбудовані типи даних:"

#~ msgid "Integers (``int``)"
#~ msgstr "Цілі числа (``int``)"

#~ msgid "Floating-point numbers (``float``)"
#~ msgstr "Числа з плаваючою крапкою (``float``)"

#~ msgid "Complex numbers (``complex``)"
#~ msgstr "Комплексні числа (``complex``)"

#~ msgid "Booleans (``bool``)"
#~ msgstr "Логічні значення (``bool``)"

#~ msgid "Strings (``str``)"
#~ msgstr "Рядки (``str``)"

#~ msgid "Bytes (``bytes``)"
#~ msgstr "Байти (``bytes``)"

#~ msgid "Byte arrays (``bytearray``)"
#~ msgstr "Масиви байтів (``bytearray``)"

#~ msgid "Lists (``list``)"
#~ msgstr "Списки (``list``)"

#~ msgid "Tuples (``tuple``)"
#~ msgstr "Кортежі (``tuple``)"

#~ msgid "Sets (``set``)"
#~ msgstr "Cети (``set``)"

#~ msgid "Frozen sets (``frozenset``)"
#~ msgstr "Заморожені сети (``frozenset``)"

#~ msgid "Dictionaries (``dict``)"
#~ msgstr "Словники (``dict``)"

#~ msgid "None (``NoneType``)"
#~ msgstr "Жодного (``NoneType``)"

#~ msgid ""
#~ "Any one can use them without additional imports or packages installations."
#~ msgstr ""
#~ "Будь-хто може використовувати їх без додаткового імпорту чи встановлення "
#~ "пакетів. "

#~ msgid "Text"
#~ msgstr "Текстові дані"

#~ msgid ""
#~ "Text data are stored as strings (``str`` data type) in Python. Any "
#~ "sequence of letters, digits, punctuation marks and whitespace characters "
#~ "enclosed with quotes is considered to be a string literal. Both single "
#~ "quotes (``'``) and double quotes (``\"``) can be used interchangeably to "
#~ "create a string in Python."
#~ msgstr ""
#~ "Текстові дані зберігаються як рядки (тип даних ``str``) у Python. Будь-"
#~ "яка послідовність літер, цифр, знаків пунктуації та пробілів, взята в "
#~ "лапки, вважається рядковим літералом. Обидві одинарні лапки (``'``) або "
#~ "подвійні лапки (``\"``) можна взаємозамінно використовувати для створення "
#~ "рядків."

#~ msgid "Escaping"
#~ msgstr "Екранування"

#~ msgid ""
#~ "In programming this is a process of using a special character to indicate "
#~ "that the following character(s) should be treated differently from their "
#~ "literal meaning. The common usage is to include a special character(s) "
#~ "within strings. A **backslash** character is used to *escape* the "
#~ "following one."
#~ msgstr ""
#~ "У програмуванні це процес використання спеціального символу, щоб вказати, "
#~ "що наступний(і) символ(и) слід розглядати інакше, ніж їхнє буквальне "
#~ "значення. Загальне використання полягає в тому, щоб включити "
#~ "спеціальний(і) символ(и) в рядки. Символ **backslash** використовується "
#~ "для екранування наступного. "

#~ msgid "Example of Escaping in Python"
#~ msgstr "Приклади Екранування в Python"

#~ msgid "Single quotes or double quotes"
#~ msgstr "Одинарні або подвійні лапки"

#~ msgid ""
#~ "Don't care. Use any quote mark you like. A *string* is a sequence of "
#~ "characters after the opening quote and till the closing one. You may use "
#~ "double quotes in case a single quote is a part of the text (e.g. ``\"It's "
#~ "a Serhii's document\"``) and vise versa (e.g. ``'The name of the ship was "
#~ "a \"Billy of Tea\"'``). It's a good practice not to mess single and "
#~ "double quotes within one project. Just keep using a chosen one character "
#~ "for all strings."
#~ msgstr ""
#~ "Неважливо які лапки ви використовуйте. Рядок - це послідовність символів "
#~ "після початкової лапки та до кінцевої. Ви можете використовувати подвійні "
#~ "лапки, якщо одинарна лапка є частиною тексту (наприклад, ``\"Це документ "
#~ "Сергія\"``) і навпаки (наприклад ``'Назва корабля була \"Billy of "
#~ "Tea\"'``). Рекомендується не плутати одинарні та подвійні лапки в одному "
#~ "проекті. Просто продовжуйте використовувати один вибраний символ для всіх "
#~ "рядків. "

#~ msgid "Multiline strings"
#~ msgstr "Багатострічкові рядки"

#~ msgid ""
#~ "You can assign a multiline string by using triple quotes: Both single "
#~ "quote and double quote characters are available."
#~ msgstr ""
#~ "Ви можете призначити багаторядковий рядок, використовуючи потрійні лапки: "
#~ "в середині них доступні як одинарні, так і подвійні лапки. "

#~ msgid ""
#~ "The same syntax is used to create docstring, which are a special case of "
#~ "string usage. We will look on these in the future."
#~ msgstr ""
#~ "Такий самий синтаксис використовується для створення рядка документації, "
#~ "який є окремим випадком використання рядка. Ми розглянемо це в "
#~ "майбутньому. "

#~ msgid "This subsection describes only the most common operations."
#~ msgstr "У цьому розділі описано лише найпоширеніші операції. "

#~ msgid "Concatenation"
#~ msgstr "Конкатинація"

#~ msgid ""
#~ "The ``+`` operator is used to concatenate (join) two or more strings."
#~ msgstr ""
#~ "Оператор ``+`` використовується для конкатенації (об'єднання) двох або "
#~ "більше рядків. "

#~ msgid ""
#~ "On the other hand the ``join`` method concatenates a collection of "
#~ "strings, which may be more efficient than using ``+``."
#~ msgstr ""
#~ "З іншого боку, метод ``join`` об'єднує колекцію рядків, що може бути "
#~ "ефективнішим, ніж використання ``+``. "

#~ msgid "Repetition"
#~ msgstr "Повторення"

#~ msgid ""
#~ "The ``*`` operator is used to repeat a string a specified number of "
#~ "times. Only multipliers of the ``int`` type are allowed."
#~ msgstr ""
#~ "Оператор ``*`` використовується для повторення рядка вказану кількість "
#~ "разів. Дозволені операції лише з множниками типу ``int``. "

#~ msgid "Length"
#~ msgstr "Довжина"

#~ msgid "The ``len`` function is used to find the length of a string."
#~ msgstr "Функція ``len`` використовується для визначення довжини рядка."

#~ msgid "Case conversion"
#~ msgstr "Перетворення регістру"

#~ msgid ""
#~ "The ``lower``, ``upper``, ``capitalize`` and ``title`` methods perform "
#~ "actions on case."
#~ msgstr ""
#~ "Методи ``lower``, ``upper``, ``capitalize`` і ``title`` виконують дії з "
#~ "зміною регістра. "

#~ msgid "``lower`` creates a new string with all lower-case characters."
#~ msgstr "``lower`` створює новий рядок з усіма символами нижнього регістру."

#~ msgid "``upper`` creates a new string with all upper-case characters."
#~ msgstr "``upper`` створює новий рядок з усіма символами верхнього регістру."

#~ msgid ""
#~ "``capitalize`` creates a new string with the upper-case 1st character."
#~ msgstr ""
#~ "``capitalize`` створює новий рядок із першим символом у верхньому "
#~ "регістрі. "

#~ msgid "``title`` will make all characters after whitespace upper case."
#~ msgstr "``title`` зробить усі символи після пробілів верхнім регістром."

#~ msgid "Stripping"
#~ msgstr "Зачистка"

#~ msgid ""
#~ "The ``strip``, ``lstrip`` and ``rstrip`` methods are used to remove "
#~ "leading and/or trailing whitespace characters."
#~ msgstr ""
#~ "Методи ``strip``, ``lstrip`` і ``rstrip`` використовуються для видалення "
#~ "початкових і/або кінцевих пробільних символів. "

#~ msgid "Strings are subscriptable"
#~ msgstr "Рядки можна підписувати"

#~ msgid "``str`` is not the only one subscriptable data type in Python."
#~ msgstr "``str`` - це не єдиний тип даних, який можна підписувати в Python."

#~ msgid ""
#~ "This means you can access individual characters or slices within a string "
#~ "using indexes. A string is a *sequence* of characters and each character "
#~ "within a string has its own position - an *index*. Indexing starts at 0, "
#~ "so the first character in a string is at index 0, the second one is at "
#~ "index 1, and so on. Negative indexing is also possible, with -1 "
#~ "representing the last character in a string, -2 representing the second-"
#~ "to-last character, and so on. Use square brackets (``[]``) to access the "
#~ "index."
#~ msgstr ""
#~ "Це означає, що ви можете отримати доступ до окремих символів або "
#~ "фрагментів у рядку за допомогою індексів. Рядок — це послідовність "
#~ "символів, і кожен символ у рядку має власну позицію — індекс. Індексація "
#~ "починається з 0, отже, перший символ у рядку має індекс 0, другий - "
#~ "індекс 1 і так далі. Також можливе від'ємне індексування, коли -1 "
#~ "представляє останній символ у рядку, а -2 представляє передостанній "
#~ "символ і так далі. Використовуйте квадратні дужки (``[]``), щоб отримати "
#~ "доступ до індексу. "

#~ msgid ""
#~ "You can also *slice* strings, this means to get a subsequence of "
#~ "characters. The slice syntax consists of 3 digits:"
#~ msgstr ""
#~ "Ви також можете *розрізати* рядки, тобто отримати підпослідовність "
#~ "символів. Синтаксис фрагмента складається з 3 цифр: "

#~ msgid ""
#~ "the first one represent the index to start (inclusive), defaults to 0"
#~ msgstr ""
#~ "Перший представляє початковий індекс (включно), за замовчанням дорівнює "
#~ "0. "

#~ msgid ""
#~ "the second one represent the index to stop (non-inclusive), defaults to "
#~ "the length of the sequence"
#~ msgstr ""
#~ "Другий представляє індекс для зупинки (не включно), за замовчуванням "
#~ "довжина послідовності. "

#~ msgid "the third one represents a step, defaults to 1"
#~ msgstr "Третій представляє крок, за замовчуванням 1."

#~ msgid ""
#~ "These numbers are separated within colon (``:``) and enclosed within "
#~ "square brackets. Any slice digit may be omitted."
#~ msgstr ""
#~ "Ці числа розділені двокрапкою (``:``) і взяті в квадратні дужки. Будь-яка "
#~ "цифра зрізу може бути упущена. "

#~ msgid "Sequence slicing"
#~ msgstr "Нарізка послідовності"

#~ msgid "Strings are iterable"
#~ msgstr "Рядки можна повторювати"

#~ msgid ""
#~ "Since strings are arrays, we can loop through the characters in a string "
#~ "with a ``for`` loop:"
#~ msgstr ""
#~ "Оскільки рядки є масивами, ми можемо прокручувати символи в рядку за "
#~ "допомогою циклу ``for``: "

#~ msgid "Strings are immutable"
#~ msgstr "Рядки незмінні"

#~ msgid ""
#~ "This means, you cannot change an individual character within a string."
#~ msgstr "Це означає, що ви не можете змінити окремий символ у рядку."

#~ msgid "Integers"
#~ msgstr "Цілі числа"

#~ msgid ""
#~ "``int``, or integer, is a whole number, positive or negative, without "
#~ "decimals."
#~ msgstr ""
#~ "``int``, тобто ціле число, може бути додатнім або від'ємним, без "
#~ "десяткових знаків. "

#~ msgid "Floats"
#~ msgstr "Числа з плаваючою комою"

#~ msgid ""
#~ "``float``, or floating point number, is a number, positive or negative, "
#~ "containing one or more decimals."
#~ msgstr ""
#~ "``float``, або число з плаваючою комою, - це число, додатне чи від’ємне, "
#~ "що містить один або більше десяткових знаків. "
