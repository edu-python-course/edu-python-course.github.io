# PYTHON BASICS BLOCK TRANSLATION.
#
# Copyright (C) 2023, Python training course authors and contributors
# This file is distributed under the same license as the Python Training
# Course package.
# OLEKSANDR YEROMIN <unicorn.in.pants@gmail.com>, 2023.
msgid ""
msgstr ""
"Project-Id-Version: Python Training Course 2022.11.dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-21 06:44+0300\n"
"PO-Revision-Date: 2023-04-21 06:46+0300\n"
"Last-Translator: Serhii Horodilov <sgorodil@gmail.com>\n"
"Language-Team: \n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"Generated-By: Babel 2.12.1\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../src/basics/bool_logic.txt:-1
msgid "this document covers usage of logic and comparison operators in Python"
msgstr ""
"цей документ охоплює використання логіки та операторів порівняння в Python"

#: ../../src/basics/bool_logic.txt:-1 ../../src/basics/controlflow.txt:-1
#: ../../src/basics/decorators.txt:-1 ../../src/basics/exceptions.txt:-1
#: ../../src/basics/functions.txt:-1 ../../src/basics/index.txt:-1
#: ../../src/basics/modules.txt:-1 ../../src/basics/pep8.txt:-1
#: ../../src/basics/stdtypes.txt:-1 ../../src/basics/syntax.txt:-1
#: ../../src/basics/testing.txt:-1 ../../src/basics/variables.txt:-1
msgid "Serhii Horodilov"
msgstr "Serhii Horodilov"

#: ../../src/basics/bool_logic.txt:-1
msgid "python, boolean, logic, comparison, operator"
msgstr "python, boolean, logic, comparison, operator"

#: ../../src/basics/bool_logic.txt:14
msgid "Boolean Logic"
msgstr "Булева Логіка"

#: ../../src/basics/bool_logic.txt:20
msgid ""
"`George Boole`_ put together what is now known as `Boolean algebra`_, which "
"relies on **true** and **false** values and define a set of boolean "
"operations: **not**, **and**, and **or**."
msgstr ""
"`George Boole`_ об'єднав те, що тепер відомо як `булева алгебра`_, яка "
"спирається на значення **true** і **false** і визначає набір логічних "
"операцій: **not**, **and** і **or**."

#: ../../src/basics/bool_logic.txt:24
msgid ""
"These Boolean values and operators are helpful in programming because they "
"help you decide the course of action in your programs."
msgstr ""
"Ці булеві значення та оператори корисні в програмуванні, оскільки вони "
"допомагають визначити курс дій у ваших програмах."

#: ../../src/basics/bool_logic.txt:27
msgid ""
"The **Python boolean** type is one of Python's built-in data types. It's "
"used to represent the truth value of an expression. For example, the "
"expression ``1 < 2`` is ``True``, while the expression ``0 == 1`` is "
"``False``. Understanding how Python Boolean values behave is important to "
"programming well in Python."
msgstr ""
"Тип **Python boolean** є одним із вбудованих типів даних Python. Він "
"використовується для представлення істиності значення виразу. Наприклад, "
"вираз ``1 < 2`` є ``True``, тоді як вираз ``0 == 1`` є ``False``. Розуміння "
"того, як поводяться логічні значення Python, є важливим для якісного "
"програмування на Python."

#: ../../src/basics/bool_logic.txt:34
msgid "Understanding Boolean"
msgstr "Розбираємось з Логічним типом даних"

#: ../../src/basics/bool_logic.txt:36
msgid "The Boolean type has only two possible values:"
msgstr "Логічний тип має лише два можливих значення:"

#: ../../src/basics/bool_logic.txt:38 ../../src/basics/bool_logic.txt:121
#: ../../src/basics/bool_logic.txt:123 ../../src/basics/bool_logic.txt:149
#: ../../src/basics/bool_logic.txt:153 ../../src/basics/bool_logic.txt:155
#: ../../src/basics/bool_logic.txt:191 ../../src/basics/bool_logic.txt:195
#: ../../src/basics/bool_logic.txt:197
msgid "``True``"
msgstr "``True``"

#: ../../src/basics/bool_logic.txt:39 ../../src/basics/bool_logic.txt:121
#: ../../src/basics/bool_logic.txt:123 ../../src/basics/bool_logic.txt:151
#: ../../src/basics/bool_logic.txt:153 ../../src/basics/bool_logic.txt:155
#: ../../src/basics/bool_logic.txt:193 ../../src/basics/bool_logic.txt:195
#: ../../src/basics/bool_logic.txt:197
msgid "``False``"
msgstr "``False``"

#: ../../src/basics/bool_logic.txt:41
msgid "No other value will have ``bool`` as it type."
msgstr "Жодне інше значення не матиме тип ``bool``."

#: ../../src/basics/bool_logic.txt:50
msgid ""
"The type ``bool`` is **built-in**, meaning it's always available in Python. "
"``True`` and ``False`` are keywords in Python and can't be used as variable "
"names. but ``bool`` type isn't and it's possible assign to the name "
"``bool``, however this is considered bad style."
msgstr ""
"Тип ``bool`` є **вбудованим**, тобто він завжди доступний у Python. ``True`` "
"і ``False`` є ключовими словами в Python і не можуть використовуватися як "
"імена змінних, але тип ``bool`` не є таким, і імені ``bool`` призначити інше "
"значення, однак це вважається поганим стилем."

#: ../../src/basics/bool_logic.txt:56
msgid "Boolean as numbers"
msgstr "Boolean як число"

#: ../../src/basics/bool_logic.txt:58
msgid ""
"Booleans are a subtype of **numeric** type in Python. This means they're "
"numbers for all intents and purposes. In other words, you can apply "
"arithmetic operations to Boolean, and you can also compare them to numbers. "
"``True`` value is treated to be 1, and ``False`` value is treated to be 0."
msgstr ""
"Логічні значення є підтипом **числового** типу в Python. Це означає, що вони "
"є числами для всіх намірів і цілей. Іншими словами, ви можете застосовувати "
"арифметичні операції до логічних значень, а також порівнювати їх із числами. "
"Значення ``True`` розглядається як 1, а значення ``False`` розглядається як "
"0."

#: ../../src/basics/bool_logic.txt:63
msgid "There aren't many uses of the numerical nature of Boolean values."
msgstr ""
"Числовій природі логічних значень можна знайти не так багато застосунків."

#: ../../src/basics/bool_logic.txt:66
msgid "Truth value testing"
msgstr "Перевірка істинності"

#: ../../src/basics/bool_logic.txt:68
msgid ""
"Any object can be tested for truth value. By default an object considered "
"``True``, unless its class defines either. Here are most of built-in objects "
"considered ``False``:"
msgstr ""
"Будь-який об'єкт можна перевірити на істинність. За замовчуванням об'єкт "
"вважається ``True``, якщо його клас не визначає іншого. Ось більшість "
"вбудованих об'єктів, які вважаються ``False``:"

#: ../../src/basics/bool_logic.txt:72
msgid "constant values: ``None`` and ``False``"
msgstr "константи: ``None`` та ``False``"

#: ../../src/basics/bool_logic.txt:73
msgid ""
"zero of any numeric type: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"
msgstr ""
"нуль будь-якого числового типу: ``0``, ``0.0``, ``0j``, ``Decimal(0)``, "
"``Fraction(0, 1)``"

#: ../../src/basics/bool_logic.txt:75
msgid ""
"empty sequences and collections: ``''``, ``[]``, ``()``, ``{}``, ``set()``, "
"``range(0)``."
msgstr ""
"порожні послідовності та колекції: ``''``, ``[]``, ``()``, ``{}``, "
"``set()``, ``range(0)``."

#: ../../src/basics/bool_logic.txt:80
msgid ""
"If ``len(something)`` is equal to 0, than ``something`` is cast to ``bool`` "
"as ``False``."
msgstr ""
"Якщо ``len(something)`` дорівнює 0, тоді ``something`` буде приведено до "
"``bool`` як ``False``."

#: ../../src/basics/bool_logic.txt:84
msgid "Boolean comparison"
msgstr "Логічне Порівняння"

#: ../../src/basics/bool_logic.txt:88
msgid "Python provides 3 logical operators:"
msgstr "Python надає 3 логічних оператори:"

#: ../../src/basics/bool_logic.txt:94 ../../src/basics/bool_logic.txt:228
msgid "Operator"
msgstr "Оператор"

#: ../../src/basics/bool_logic.txt:94
msgid "Logic operator"
msgstr "Логічний оператор"

#: ../../src/basics/bool_logic.txt:96
msgid "``not``"
msgstr "``not``"

#: ../../src/basics/bool_logic.txt:96
msgid "Negation"
msgstr "Заперечення"

#: ../../src/basics/bool_logic.txt:98
msgid "``and``"
msgstr "``and``"

#: ../../src/basics/bool_logic.txt:98
msgid "Conjunction"
msgstr "Кон'юнкція"

#: ../../src/basics/bool_logic.txt:100
msgid "``or``"
msgstr "``or``"

#: ../../src/basics/bool_logic.txt:100
msgid "Disjunction"
msgstr "Диз'юнкція"

#: ../../src/basics/bool_logic.txt:103
msgid ""
"With these operators, you can build expressions by connecting Boolean "
"expressions with each other. These operators are **keywords** of the "
"language, so you cannot use them as identifiers without causing a "
"*SyntaxError*."
msgstr ""
"За допомогою цих операторів можна будувати вирази, поєднуючі логічні вирази "
"один з одним. Ці оператори є **ключовими словами** мови, тому ви не можете "
"використовувати їх як ідентифікатори, не викликаючи *SyntaxError*."

#: ../../src/basics/bool_logic.txt:108
msgid "Getting started with ``not`` operator"
msgstr "Початок роботи з оператором ``not``"

#: ../../src/basics/bool_logic.txt:110
msgid ""
"The ``not`` operator is the Boolean or logic operator that implements "
"negation in Python. It's **unary**, which means that it takes only one "
"**operand**. The operand can be a Boolean expression or any Python object. "
"The task of ``not`` is to reverse the truth value of its operand."
msgstr ""
"Оператор ``not`` є логічним або логічним оператором, який реалізує "
"заперечення в Python. Це **унарний**, що означає, що він приймає лише один "
"**операнд**. Операндом може бути логічний вираз або будь-який об'єкт Python. "
"Завдання ``not`` полягає в тому, щоб змінити значення істинності свого "
"операнда."

#: ../../src/basics/bool_logic.txt:115
msgid "not operator truth table"
msgstr "таблиця істинності оператора not"

#: ../../src/basics/bool_logic.txt:119
msgid "``operand``"
msgstr "``operand``"

#: ../../src/basics/bool_logic.txt:119
msgid "``not operand``"
msgstr "``not operand``"

#: ../../src/basics/bool_logic.txt:126
msgid "This functionality makes it worthwhile in several situations:"
msgstr "Ця функція доцільна в кількох ситуаціях:"

#: ../../src/basics/bool_logic.txt:129
msgid ""
"Checking **unmet conditions** in the context of ``if`` statements and "
"``while`` loops"
msgstr ""
"Перевірка **невиконаних умов** у контексті операторів ``if`` і циклів "
"``while``"

#: ../../src/basics/bool_logic.txt:131
msgid "**Inverting the truth value** of an object or expression"
msgstr "**Інвертування значення істинності** об'єкта чи виразу"

#: ../../src/basics/bool_logic.txt:132
msgid "Checking if a **value is not in a given container**"
msgstr "Перевірка того, що **значення не міститься в заданому контейнері**"

#: ../../src/basics/bool_logic.txt:133
msgid "Checking for an **object's identity**"
msgstr "Перевірка **ідентичності об'єкта**"

#: ../../src/basics/bool_logic.txt:136
msgid "Getting started with ``and`` operator"
msgstr "Початок роботи з оператором ``and``"

#: ../../src/basics/bool_logic.txt:138
msgid ""
"Python's ``and`` operator is **binary**, which means it takes two "
"**operands**. The operands in an ``and`` expression are commonly known as "
"*conditions*. The result of the operator depends on the truth values of its "
"operands. It'll be ``True`` if **both** are true."
msgstr ""
"Оператор Python ``and`` є **бінарним**, що означає, що він приймає два "
"**операнди**. Операнди у виразі ``and`` зазвичай відомі як *умови*. "
"Результат оператора залежить від істинних значень його операндів. Це буде "
"``True``, якщо **обидва** є істинними."

#: ../../src/basics/bool_logic.txt:143
msgid "and operator truth table"
msgstr "таблиця істинності оператора and"

#: ../../src/basics/bool_logic.txt:147 ../../src/basics/bool_logic.txt:189
msgid "``operand_1``"
msgstr "``operand_1``"

#: ../../src/basics/bool_logic.txt:147 ../../src/basics/bool_logic.txt:189
msgid "``operand_2``"
msgstr "``operand_2``"

#: ../../src/basics/bool_logic.txt:147
msgid "``operand_1 and operand_2``"
msgstr "``operand_1 and operand_2``"

#: ../../src/basics/bool_logic.txt:158
msgid ""
"``and`` operator works not only with operands of Boolean type. It's behavior:"
msgstr ""
"Оператор ``and`` працює не тільки з операндами логічного типу. Його "
"поведінка:"

#: ../../src/basics/bool_logic.txt:161
msgid "evaluate 1st operand; return it, if it's ``False`` and finish"
msgstr "обчислити 1-й операнд; повернути його, якщо він ``False`` та завершити"

#: ../../src/basics/bool_logic.txt:162
msgid "evaluate 2nd operand; return it, if it's ``False`` and finish"
msgstr "обчислити 2-й операнд; повернути його, якщо він ``False`` та завершити"

#: ../../src/basics/bool_logic.txt:163 ../../src/basics/bool_logic.txt:205
msgid "return 2nd operand"
msgstr "повернути 2-й операнд"

#: ../../src/basics/bool_logic.txt:177
msgid "Getting started with ``or`` operator"
msgstr "Початок роботи з оператором ``or``"

#: ../../src/basics/bool_logic.txt:179
msgid ""
"With Boolean ``or`` operator, you can connect two Boolean expressions into "
"one compound expression. This makes ``or`` the **binary** operator. At least "
"one subexpression must be ``True`` for the compound expression to be "
"considered ``True``, and it doesn't matter which. If both subexpressions are "
"``False``, then the expression is ``False``."
msgstr ""
"За допомогою логічного оператора ``or`` ви можете з'єднати два логічні "
"вирази в один складений вираз. Це робить ``or`` **бінарним** оператором. "
"Принаймні один підвираз має бути ``True``, щоб складений вираз вважався "
"``True``, і не має значення який. Якщо обидва підвирази мають значення "
"``False``, тоді вираз є ``False``."

#: ../../src/basics/bool_logic.txt:185
msgid "or operator truth table"
msgstr "таблиця істинності оператора or"

#: ../../src/basics/bool_logic.txt:189
msgid "``operand_1 or operand_2``"
msgstr "``operand_1 or operand_2``"

#: ../../src/basics/bool_logic.txt:200
msgid ""
"``or`` operator works not only with operands of Boolean type. It's behavior:"
msgstr ""
"Оператор ``or`` працює не тільки з операндами логічного типу. Його поведінка:"

#: ../../src/basics/bool_logic.txt:203
msgid "evaluate 1st operand; return it, if it's ``True`` and finish"
msgstr "обчислити 1-й операнд; повернути його, якщо він ``True`` та завершити"

#: ../../src/basics/bool_logic.txt:204
msgid "evaluate 2nd operand; return it, if it's ``True`` and finish"
msgstr "обчислити 2-й операнд; повернути його, якщо він ``True`` та завершити"

#: ../../src/basics/bool_logic.txt:219
msgid "Comparison"
msgstr "Порівняння"

#: ../../src/basics/bool_logic.txt:221
msgid ""
"There are eight comparison operations in Python. They all have the same "
"priority (which is higher than that of the Boolean operations)."
msgstr ""
"У Python є вісім операцій порівняння. Усі вони мають однаковий пріоритет "
"(вищий, ніж у логічних операцій)."

#: ../../src/basics/bool_logic.txt:224
msgid "Comparison operators"
msgstr "Оператори порівняння"

#: ../../src/basics/bool_logic.txt:228
msgid "Meaning"
msgstr "Значення"

#: ../../src/basics/bool_logic.txt:230
msgid "``<``"
msgstr "``<``"

#: ../../src/basics/bool_logic.txt:230
msgid "strictly less than"
msgstr "строго менше ніж"

#: ../../src/basics/bool_logic.txt:232
msgid "``<=``"
msgstr "``<=``"

#: ../../src/basics/bool_logic.txt:232
msgid "less than or equal"
msgstr "менше або дорівнює"

#: ../../src/basics/bool_logic.txt:234
msgid "``>``"
msgstr "``>``"

#: ../../src/basics/bool_logic.txt:234
msgid "strictly greater than"
msgstr "строго більше ніж"

#: ../../src/basics/bool_logic.txt:236
msgid "``>=``"
msgstr "``>=``"

#: ../../src/basics/bool_logic.txt:236
msgid "greater or equal"
msgstr "більше або дорівнює"

#: ../../src/basics/bool_logic.txt:238
msgid "``==``"
msgstr "``==``"

#: ../../src/basics/bool_logic.txt:238
msgid "equal (aka *equality* comparison)"
msgstr "дорівнює (також відоме як порівняння *equality*)"

#: ../../src/basics/bool_logic.txt:240
msgid "``!=``"
msgstr "``!=``"

#: ../../src/basics/bool_logic.txt:240
msgid "not equal"
msgstr "не дорівнює"

#: ../../src/basics/bool_logic.txt:242
msgid "``is``"
msgstr "``is``"

#: ../../src/basics/bool_logic.txt:242
msgid "object identity"
msgstr "ідентичність об'єкта"

#: ../../src/basics/bool_logic.txt:244
msgid "``is not``"
msgstr "``is not``"

#: ../../src/basics/bool_logic.txt:244
msgid "negated object identity"
msgstr "заперечена ідентичність об'єкта"

#: ../../src/basics/bool_logic.txt:247
msgid ""
"Each of these comparison operators return a Boolean value, it's always "
"``True`` or ``False``."
msgstr ""
"Кожен із цих операторів порівняння повертає логічне значення, воно завжди "
"``True`` або ``False``."

#: ../../src/basics/bool_logic.txt:250
msgid ""
"You can chain comparison operators together: ``x < y < z`` is equal to ``x < "
"y and y < z``."
msgstr ""
"Ви можете об'єднати оператори порівняння: ``x < y < z`` дорівнює ``x < y і y "
"< z``."

#: ../../src/basics/bool_logic.txt:254
msgid "Equality vs Identity"
msgstr "Рівність та Ідентичність"

#: ../../src/basics/bool_logic.txt:256
msgid ""
"It's easier to understand the difference between those by asking the "
"question each answers to."
msgstr ""
"Легше зрозуміти різницю між ними, поставивши запитання, на яке кожен "
"відповідає."

#: ../../src/basics/bool_logic.txt:259
msgid "The question for ``==`` (*equality*) is:"
msgstr "Питання для ``==`` (*equality*) таке:"

#: ../../src/basics/bool_logic.txt:261
msgid "Is object on the left **equal** to the object on the right"
msgstr "Об'єкт ліворуч **дорівнює** об'єкту праворуч"

#: ../../src/basics/bool_logic.txt:263
msgid "The question for ``is`` (*identity*) is:"
msgstr "Питання для ``is`` (*identity*) таке:"

#: ../../src/basics/bool_logic.txt:265
msgid "Is object on the left **the same** as the object on the right"
msgstr "Об'єкт ліворуч **те саме**, що й об'єкт праворуч"

#: ../../src/basics/bool_logic.txt:267
msgid ""
"For example, if there are two cars of the same model, same color etc. in "
"front of you - these cars are equal, but they aren't ident to each other. "
"But if you are shown two pictures of the same car, you understand that the "
"cars on those pictures are the same object."
msgstr ""
"Наприклад, якщо перед вами дві машини однієї моделі, одного кольору і т. д. "
"- ці машини рівні, але не ідентичні одна одній. Але якщо вам покажуть дві "
"фотографії однієї машини, ви зрозумієте, що машини на цих фотографіях є "
"одним і тим же об'єктом."

#: ../../src/basics/controlflow.txt:-1
msgid "Control flow in Python"
msgstr "Контроль потоку в Python"

#: ../../src/basics/controlflow.txt:-1
msgid "python, basics, control, if, for, while, condition, loop"
msgstr "python, basics, control, if, for, while, condition, loop"

#: ../../src/basics/controlflow.txt:8
msgid "Control Flow"
msgstr "Керування виконанням"

#: ../../src/basics/controlflow.txt:11
msgid "``if`` statement"
msgstr "Вираз ``if``"

#: ../../src/basics/controlflow.txt:13
msgid ""
"Perhaps the most well-known statement type is ``if`` statement. For example:"
msgstr "Мабуть, найвідомішим типом оператора є оператор ``if``. Наприклад:"

#: ../../src/basics/controlflow.txt:15
msgid "if statement base example"
msgstr "базовий приклад оператора if"

#: ../../src/basics/controlflow.txt:29
msgid "But let's dive into ``if`` statement with more simple examples."
msgstr ""
"Але давайте зануримося в інструкцію ``if`` з більш простими прикладами."

#: ../../src/basics/controlflow.txt:32
msgid "How it works"
msgstr "Як це працює"

#: ../../src/basics/controlflow.txt:34
msgid ""
"**if** statement is defined with a keyword ``if`` followed by a Boolean "
"expression or any object and finished with colon. The statement requires a "
"*body*: other statements to execute, also called an *if block*. The body is "
"indented at the same distance from the left (in Python we use 4 spaces to "
"indent a single block of code)."
msgstr ""
"Оператор **if** визначається ключовим словом ``if``, за яким слідує логічний "
"вираз або будь-який об'єкт і завершується двокрапкою. Оператор потребує "
"*тіло*: інші оператори для виконання, які також називають блоком *if*. Тіло "
"має відступ на однаковій відстані зліва (у Python ми використовуємо 4 "
"пробіли для відступу одного блоку коду)."

#: ../../src/basics/controlflow.txt:40
msgid ""
"The body's statements will be executed only in case **if** expression is "
"``True``."
msgstr ""
"Оператори тіла виконуватимуться лише у випадку, якщо вираз **if** має "
"значення ``True``."

#: ../../src/basics/controlflow.txt:53
msgid ""
"The ``print`` statement on line #6 will be executed only for even value of "
"``number`` variable."
msgstr ""
"Оператор ``print`` у рядку #6 буде виконано лише для парного значення "
"змінної ``number``."

#: ../../src/basics/controlflow.txt:57
msgid "``else`` block"
msgstr "Блок ``else``"

#: ../../src/basics/controlflow.txt:59
msgid ""
"``if`` can be used by its own, it can extend its behavior with ``else`` "
"block. The general syntax for ``else`` body is the same: at least one "
"indented statement. But ``else`` doesn't take any expression after it. This "
"block of code will be executed only that the ``if`` statement truth check "
"fails."
msgstr ""
"``if`` може використовуватися самостійно, він може розширити свою поведінку "
"за допомогою блоку ``else``. Загальний синтаксис для тіла ``else`` той "
"самий: принаймні один оператор із відступом. Але ``else`` не приймає жодного "
"виразу після нього. Цей блок коду буде виконано лише тоді, коли перевірка "
"істинності оператора ``if`` буде невдалою."

#: ../../src/basics/controlflow.txt:76
msgid ""
"You can attach **only one** else block to **if statement**. And you cannot "
"use ``else`` statement on its own - this will cause *SyntaxError*."
msgstr ""
"Ви можете приєднати **лише один** блок else до **інструкції if**. І ви не "
"можете використовувати оператор ``else`` сам по собі - це спричинить "
"*SyntaxError*."

#: ../../src/basics/controlflow.txt:80
msgid "``elif`` block(s)"
msgstr "Блок(и) ``elif``"

#: ../../src/basics/controlflow.txt:82
msgid ""
"``elif`` (*else if*) statement may be considered as semi-statement between "
"``if`` and ``else`` statements. In case your program has more than two "
"dedicated choices you are able to extends control flow by appending ``elif`` "
"blocks after ``if`` statement. The syntax is pretty similar to ``if`` "
"statement. Each ``elif`` has its own boolean expression or an object to test "
"for the truth value."
msgstr ""
"Оператор ``elif`` (*else if*) можна розглядати як напівоператор між ``if`` "
"та ``else``. Якщо у вашій програмі є більше двох виділених варіантів, ви "
"можете розширити потік керування, додавши блоки ``elif`` після оператора "
"``if``. Синтаксис дуже схожий на оператор if. Кожен ``elif`` має свій "
"власний логічний вираз або об'єкт для перевірки значення істинності."

#: ../../src/basics/controlflow.txt:89
msgid ""
"You can attach as many ``elif`` statements as it needed. But you cannot use "
"``elif`` without ``if`` statement."
msgstr ""
"Ви можете додати скільки завгодно операторів ``elif``. Але ви не можете "
"використовувати ``elif`` без оператора ``if``."

#: ../../src/basics/controlflow.txt:92
msgid ""
"Python will test conditions in ``if`` and ``elif`` statements from top to "
"bottom. The first one, which considered to be ``True`` will be executed. All "
"others will be skipped."
msgstr ""
"Python перевірить умови в операторах ``if`` та ``elif`` зверху вниз. Буде "
"виконано перший, який вважається ``True``. Усі інші будуть проігноровано."

#: ../../src/basics/controlflow.txt:96
msgid ""
"If there were no truth conditions ``else`` block will be executed (if "
"exists)."
msgstr "Якщо не було істиних умов, буде виконано блок ``else`` (якщо існує)."

#: ../../src/basics/controlflow.txt:112
msgid ""
"The order conditions appears matter. The truth test goes from top to bottom "
"and stops at first expression which is ``True``."
msgstr ""
"Порядок у якому визначено умови має значення. Перевірка істинності йде "
"зверху вниз і зупиняється на першому виразі, який є ``True``."

#: ../../src/basics/controlflow.txt:117
msgid "Usage"
msgstr "Використання"

#: ../../src/basics/controlflow.txt:119
msgid ""
"``if/elif/else`` statements help you to control which portion of your code "
"is executed based on conditions from outer scope."
msgstr ""
"Оператори ``if/elif/else`` допомагають вам контролювати, яка частина вашого "
"коду виконується на основі умов ззовні."

#: ../../src/basics/decorators.txt:-1
msgid "Python decorators"
msgstr "Декоратори в Python"

#: ../../src/basics/decorators.txt:-1
msgid "python, basics, decorators"
msgstr "python, basics, decorators"

#: ../../src/basics/decorators.txt:11
msgid "Decorators"
msgstr "Декоратори"

#: ../../src/basics/decorators.txt:13
msgid ""
"Decorators provide a simple syntax for calling higher-order functions :cite:"
"`realpython:decorators`."
msgstr ""
"Декоратори забезпечують простий синтаксис для виклику функцій вищого "
"порядку :cite:`realpython:decorators`."

#: ../../src/basics/decorators.txt:18
msgid "There is some kind of misunderstanding in definitions."
msgstr "Є деяке непорозуміння у визначеннях."

#: ../../src/basics/decorators.txt:20
msgid ""
"**Decorator** is a function returning another function, usually applied as a "
"function transformation using the ``@wrapper`` syntax :cite:`docs-python:"
"term-decorator`."
msgstr ""
"**Декоратор** — це функція, яка повертає іншу функцію, зазвичай "
"застосовується як перетворення функції за допомогою синтаксису ``@wrapper`` :"
"cite:`docs-python:term-decorator`."

#: ../../src/basics/decorators.txt:24
msgid ""
"However, that's no quit enough to describe it. The more complete definition "
"is:"
msgstr "Однак цього недостатньо, щоб описати це. Більш повне визначення таке:"

#: ../../src/basics/decorators.txt:27
msgid ""
"**Decorator** is a structural design pattern that lets you attach new "
"behaviors to objects by placing these objects inside special wrapper objects "
"that contain the behaviors :cite:`refactoring.guru:decorator`."
msgstr ""
"**Декоратор** — це структурний шаблон проектування, який дає змогу додавати "
"нову поведінку до об'єктів, розміщуючи ці об'єкти всередині спеціальних "
"об'єктів-огорток, які містять поведінку :cite:`refactoring.guru:decorator`."

#: ../../src/basics/decorators.txt:31
msgid ""
"Before you understand decorators, you must first understand how functions "
"work."
msgstr ""
"Перш ніж зрозуміти декораторів, ви повинні спочатку зрозуміти, як працюють "
"функції."

#: ../../src/basics/decorators.txt:35
msgid "First-class objects"
msgstr "Об'єкти першого класу"

#: ../../src/basics/decorators.txt:37
msgid ""
"In Python functions are `first-class objects`_. Everything in Python is an "
"object. Functions are objects too."
msgstr ""
"У Python функції є `об'єктами першого класу`_. Усе в Python є об'єктом. "
"Функції також є об'єктами."

#: ../../src/basics/decorators.txt:41
msgid "Inner functions"
msgstr "Внутрішні функції"

#: ../../src/basics/decorators.txt:43
msgid ""
"Functions can be nested. This means it is possible to define functions "
"inside other functions."
msgstr ""
"Функції можуть бути вкладеними. Це означає, що можна визначати функції "
"всередині інших функцій."

#: ../../src/basics/decorators.txt:46
msgid "Nested functions example"
msgstr "Приклад вкладених функцій"

#: ../../src/basics/decorators.txt:60
msgid ""
"The order in which inner functions are defined no matters. The function "
"definition does not execute the function body; this gets executed only when "
"the function is called. Furthermore, the inner functions are not defined "
"until the parent function is called. They are locally scoped to their "
"parent. Trying to call ``heapify`` function outside of ``heap_sort`` will "
"cause ``NameError`` exception."
msgstr ""
"Порядок визначення внутрішніх функцій не має значення. Визначення функції не "
"виконує тіло функції; це виконується лише під час виклику функції. Крім "
"того, внутрішні функції не визначені, доки не буде викликана батьківська "
"функція. Вони локально прив'язані до свого батьківського елемента. Спроба "
"викликати функцію ``heapify`` поза межами ``heap_sort`` спричинить виняток "
"``NameError``."

#: ../../src/basics/decorators.txt:68
msgid "Functions are objects"
msgstr "Функції є об'єктами"

#: ../../src/basics/decorators.txt:70
msgid ""
"This means functions can be passed around and used as arguments, just like "
"any other object (e.g. *int*, *str* etc.)."
msgstr ""
"Це означає, що функції можна передавати й використовувати як аргументи, як і "
"будь-який інший об'єкт (наприклад, *int*, *str* тощо)."

#: ../../src/basics/decorators.txt:95
msgid "Returning functions"
msgstr "Повернення функцій"

#: ../../src/basics/decorators.txt:97
msgid ""
"Since function can be passed as an argument, it may be returned from another "
"function."
msgstr ""
"Оскільки функцію можна передати як аргумент, її можна повернути з іншої "
"функції."

#: ../../src/basics/decorators.txt:120
msgid "``parent`` returns functions themselves, there are no parentheses."
msgstr "``parent`` повертає самі функції, тут нема дужок."

#: ../../src/basics/decorators.txt:122
msgid ""
"After running the code snippet above, ``first`` refers the ``first_child`` "
"function from the inner ``parent`` scope. From now it can be used to call "
"the target function it refers."
msgstr ""
"Після виконання наведеного вище фрагмента коду ``first`` посилається на "
"функцію ``first_child`` із внутрішньої області ``parent``. Відтепер його "
"можна використовувати для виклику цільової функції, на яку він посилається."

#: ../../src/basics/decorators.txt:134
msgid "Simple decorators"
msgstr "Прості декоратори"

#: ../../src/basics/decorators.txt:136
msgid ""
"Now you're ready to move on and see the magical beast that is the Python "
"decorators. Let's start with a simple example:"
msgstr ""
"Тепер ви готові рухатися далі та побачити чарівного звіра, яким є декоратори "
"Python. Почнемо з простого прикладу:"

#: ../../src/basics/decorators.txt:154
msgid "Running function:"
msgstr "Запуск функцій:"

#: ../../src/basics/decorators.txt:165
msgid ""
"The common way to use decorators is to replace the original function with a "
"decorated one:"
msgstr ""
"Поширеним способом використання декораторів є заміна оригінальної функції на "
"декоровану:"

#: ../../src/basics/decorators.txt:176
msgid ""
"``say_hello`` function is the reference to the ``decorator.<locals>."
"wrapper``, which itself is bound to the original ``say_hello`` function. "
"There is a syntactic sugar to do this, called *pie-syntax*. The following "
"example does exact the same things as the first decorator example:"
msgstr ""
"Функція ``say_hello`` є посиланням на ``decorator.<locals>.wrapper``, який "
"сам прив'язаний до оригінальної функції ``say_hello``. Для цього існує "
"синтаксичний цукор, який називається *pie-syntax*. Наступний приклад виконує "
"ті самі речі, що й перший приклад декоратора:"

#: ../../src/basics/decorators.txt:198
msgid ""
"There is no way to *undecorate* object in Python. Once something is bound to "
"the decorator's wrapper - it is decorated forever."
msgstr ""
"У Python немає способу *скасувати* об'єкт. Одного разу щось прив'язане до "
"обгортки декоратора - воно прикрашене назавжди."

#: ../../src/basics/decorators.txt:201
msgid ""
"A decorated function still remains a **function**. So, it can be decorated "
"once more time again, and again, and again..."
msgstr ""
"Декорована функція все ще залишається **функцією**. Отже, його можна "
"прикрашати ще раз, і ще, і ще..."

#: ../../src/basics/decorators.txt:253
msgid ""
"\"Wrapper\" is the alternative nickname for the Decorator pattern that "
"clearly expresses the main idea of the pattern. A wrapper is an object that "
"can be linked with some target object. The wrapper contains the same set of "
"methods as the target and delegates to it all requests it receives. However, "
"the wrapper may alter the result by doing something either before or after "
"it passes the request to the target."
msgstr ""
"\"Обгортка\" — альтернативне прізвисько візерунка \"Декоратор\", яке чітко "
"виражає основну ідею візерунка. Обгортка — це об'єкт, який можна зв'язати з "
"деяким цільовим об'єктом. Обгортка містить той самий набір методів, що й "
"мета, і делегує їй усі отримані запити. Однак обгортка може змінити "
"результат, зробивши щось до або після того, як вона передає запит цільовому "
"об'єкту."

#: ../../src/basics/decorators.txt:261
msgid "Passing arguments to the wrapper"
msgstr "Передача аргументів до wrapper"

#: ../../src/basics/decorators.txt:263
msgid ""
"Until now the examples use *simple* decorators. But what if the decorated "
"function gets some arguments? This will cause ``TypeError`` exception that "
"tell that \"arguments are missed\". This can be fixed with just passing "
"arguments to the ``wrapper`` inner function."
msgstr ""
"Досі приклади використовують *прості* декоратори. Але що, якщо декорована "
"функція отримує деякі аргументи? Це спричинить виняток ``TypeError``, який "
"повідомляє, що \"аргументи пропущено\". Це можна виправити, просто передавши "
"аргументи внутрішній функції ``wrapper``."

#: ../../src/basics/decorators.txt:289
msgid ""
"If case you're trying to make a generic decorator, you may pass ``*args`` "
"and ``**kwargs`` instead of exact arguments:"
msgstr ""
"Якщо ви намагаєтеся створити загальний декоратор, ви можете передати "
"``*args`` і ``**kwargs`` замість точних аргументів:"

#: ../../src/basics/decorators.txt:308
msgid "Passing arguments to decorator"
msgstr "Передача аргументів декоратору"

#: ../../src/basics/decorators.txt:310
msgid ""
"At last it's time to know how to pass arguments to the decorator. Here is a "
"simple implementation of ``defer`` decorator which deferred the function "
"execution for some time:"
msgstr ""
"Нарешті настав час знати, як передавати аргументи декоратору. Ось проста "
"реалізація декоратора ``defer``, яка відкладає виконання функції на деякий "
"час:"

#: ../../src/basics/decorators.txt:353
msgid "Class decorators"
msgstr "Декоратори класів"

#: ../../src/basics/decorators.txt:355
msgid ""
"There are some pre-defined decorators exists for usage together with "
"classes. They are:"
msgstr ""
"Існують деякі попередньо визначені декоратори для використання разом із "
"класами. Це:"

#: ../../src/basics/decorators.txt:358
msgid "``classmethod``"
msgstr "``classmethod``"

#: ../../src/basics/decorators.txt:359
msgid "``staticmethod``"
msgstr "``staticmethod``"

#: ../../src/basics/decorators.txt:360
msgid "``property``"
msgstr "``property``"

#: ../../src/basics/decorators.txt:362
msgid ""
"If you develop an intuitive understanding for their differences you'll be "
"able to write object-oriented Python that communicates its intent more "
"clearly and will be easier to maintain in the long run :cite:`realpython:"
"methods-demystified`."
msgstr ""
"Якщо ви розвинете інтуїтивне розуміння їхніх відмінностей, ви зможете "
"написати об'єктно-орієнтований Python, який чіткіше передає свої наміри та "
"який буде легше підтримувати в довгостроковій перспективі :cite:`realpython:"
"methods-demystified`."

#: ../../src/basics/decorators.txt:368
msgid "Class methods"
msgstr "Методи класу"

#: ../../src/basics/decorators.txt:370
msgid ""
"Instead of accepting a ``self`` parameter, class methods take a ``cls`` "
"parameter that points to the class — and not the object instance — when the "
"method is called."
msgstr ""
"Замість того, щоб приймати параметр self, під час виклику методу методи "
"класу приймають параметр ``cls``, який вказує на клас, а не на екземпляр "
"класу."

#: ../../src/basics/decorators.txt:374
msgid ""
"Because the class method only has access to this ``cls`` argument, it can't "
"modify object instance state. That would require access to ``self``. "
"However, class methods can still modify class state that applies across all "
"instances of the class."
msgstr ""
"Оскільки метод класу має доступ лише до цього аргументу ``cls``, він не може "
"змінити стан екземпляра об'єкта. Це потребує доступу до ``self``. Однак "
"методи класу все ще можуть змінювати стан класу, який застосовується до всіх "
"екземплярів класу."

#: ../../src/basics/decorators.txt:379
msgid ""
"The common usage for ``classmethod`` is provide alternative initializers."
msgstr ""
"Загальним використанням ``методи класу`` є надання альтернативних "
"ініціалізаторів."

#: ../../src/basics/decorators.txt:382
msgid "Static methods"
msgstr "Статичні методи"

#: ../../src/basics/decorators.txt:384
msgid ""
"This type of method takes neither a ``self`` nor a ``cls`` parameter (but of "
"course it's free to accept an arbitrary number of other parameters)."
msgstr ""
"Цей тип методу не приймає ані ``self``, ані ``cls`` параметр (але, звичайно, "
"він може приймати будь-яку кількість інших параметрів)."

#: ../../src/basics/decorators.txt:387
msgid ""
"Therefore a static method can neither modify object state nor class state. "
"Static methods are restricted in what data they can access - and they're "
"primarily a way to namespace your methods."
msgstr ""
"Тому статичний метод не може змінити ні стан об'єкта, ні стан класу. "
"Статичні методи обмежені в тому, до яких даних вони можуть отримати доступ, "
"і вони, перш за все, є способом простору імен ваших методів."

#: ../../src/basics/decorators.txt:391
msgid ""
"It's tricky to explain ``staticmethod`` usage. Almost always you can create "
"a dedicated function instead of static method. But sometimes you need to "
"bind some logic independent from class itself or its instances to a class - "
"it common to encapsulate it with ``staticmethod``."
msgstr ""
"Важко пояснити використання ``staticmethod``. Майже завжди ви можете "
"створити спеціальну функцію замість статичного методу. Але іноді вам "
"потрібно прив'язати до класу певну логіку, незалежну від самого класу або "
"його екземплярів – зазвичай інкапсулювати її за допомогою ``staticmethod``."

#: ../../src/basics/decorators.txt:397
msgid "Properties"
msgstr "Властивості"

#: ../../src/basics/decorators.txt:399
msgid ""
"It's a way to bind a method name to access it as an attribute. Properties "
"are **read-only** by default. This means a value cannot be assigned to "
"``property member``."
msgstr ""
"Це спосіб прив'язати назву методу для доступу до нього як до атрибута. За "
"замовчуванням властивості доступні **лише для читання**. Це означає, що "
"значення не можна призначити ``члену властивості``."

#: ../../src/basics/decorators.txt:404
msgid "Some examples"
msgstr "Деякі приклади"

#: ../../src/basics/exceptions.txt:-1
msgid "Handling exceptions in Python"
msgstr "Опрацювання винятків в Python"

#: ../../src/basics/exceptions.txt:-1
msgid "python, exceptions, handling, try, except, finally"
msgstr "python, exceptions, handling, try, except, finally"

#: ../../src/basics/exceptions.txt:11
msgid "Errors and Exceptions"
msgstr "Помилки та винятки"

#: ../../src/basics/exceptions.txt:13
msgid ""
"There are (at least) two distinguishable kinds of errors: *syntax errors* "
"and *exceptions* :cite:`docs-python:errors`."
msgstr ""
"Існує (принаймні) два типи помилок: *синтаксичні помилки* та *виключення* :"
"cite:`docs-python:errors`."

#: ../../src/basics/exceptions.txt:17
msgid "Syntax errors"
msgstr "Синтаксичні помилки"

#: ../../src/basics/exceptions.txt:19
msgid "Syntax errors are also known as parsing errors."
msgstr "Синтаксичні помилки також відомі як помилки Python парсера."

#: ../../src/basics/exceptions.txt:29
msgid ""
"The parser repeats the offending line and displays a little \"arrow\" "
"pointing at the earliest point in the line where the error was detected. The "
"error is caused by (or at least detected at) the token preceding the arrow."
msgstr ""
"Синтаксичний аналізатор повторює неправильний рядок і відображає маленьку "
"\"стрілку\", яка вказує на найперший символ рядка, де було виявлено помилку. "
"Помилка спричинена (або принаймні виявлена) символом(а) перед стрілкою."

#: ../../src/basics/exceptions.txt:34
msgid "Exceptions"
msgstr "Винятки"

#: ../../src/basics/exceptions.txt:36
msgid ""
"Even if a statement or expression is syntactically correct, it may cause an "
"error when an attempt is made to execute it. Errors detected during "
"execution are called exceptions and are not unconditionally fatal: you will "
"soon learn how to handle them in Python programs."
msgstr ""
"Навіть якщо оператор або вираз синтаксично правильний, це може спричинити "
"помилку під час спроби його виконання. Помилки, виявлені під час виконання, "
"називаються винятками і не є фатальними: незабаром ви дізнаєтеся, як їх "
"обробляти в програмах на Python."

#: ../../src/basics/exceptions.txt:41
msgid ""
"Exceptions come in different types, and the type is printed as part of the "
"message."
msgstr ""
"Винятки бувають різних типів, і тип друкується як частина повідомлення."

#: ../../src/basics/exceptions.txt:44
msgid "For example, the ``div`` function implemented as"
msgstr "Наприклад, функція ``div``, реалізована як"

#: ../../src/basics/exceptions.txt:53
msgid ""
"may cause a ``ZeroDivisionError`` exception in case 0 is passed as ``y`` "
"parameter."
msgstr ""
"може викликати виняток ``ZeroDivisionError``, якщо 0 передається як параметр "
"``y``."

#: ../../src/basics/exceptions.txt:56
msgid ""
"Standard exception names are built-in identifiers (not reserved keywords)."
msgstr ""
"Стандартні назви винятків є вбудованими ідентифікаторами (а не "
"зарезервованими ключовими словами)."

#: ../../src/basics/exceptions.txt:58
msgid "The list of `built-in exceptions`_"
msgstr "Список `вбудованих винятків`_"

#: ../../src/basics/exceptions.txt:61
msgid "Tracebacks"
msgstr "Відстеження"

#: ../../src/basics/exceptions.txt:63
msgid "\"File\" is replaced with a *dummy string* within the examples."
msgstr "У наведених прикладах \"Файл\" замінено на *фіктивний рядок*."

#: ../../src/basics/exceptions.txt:65
msgid "Let's assume the following modules structure:"
msgstr "Припустимо наступну структуру модулів:"

#: ../../src/basics/exceptions.txt:73
msgid ""
"The **main** module imports a ``div`` function implemented above from the "
"**func** module. The code in main is implemented as follows:"
msgstr ""
"Модуль **main** імпортує функцію ``div``, реалізовану вище, з модуля "
"**func**. Основний код реалізовано наступним чином:"

#: ../../src/basics/exceptions.txt:85
msgid ""
"While running the code with correct inputs it will work fine. But there are "
"at two exceptions for this script."
msgstr ""
"Під час виконання коду з правильними введеннями він працюватиме нормально. "
"Але для цього сценарію є два винятки."

#: ../../src/basics/exceptions.txt:88
msgid ""
"The first one is related on type conversion. While running the main script "
"there is case of invalid input."
msgstr ""
"Перший пов'язаний з перетворенням типів. Під час виконання основного "
"сценарію є випадок неправильного введення."

#: ../../src/basics/exceptions.txt:100
msgid ""
"Note the **traceback** indicates the module and the exact line of code that "
"causes the exception."
msgstr ""
"Зауважте, що **traceback** вказує на модуль і точний рядок коду, який "
"викликає виняток."

#: ../../src/basics/exceptions.txt:103
msgid ""
"The second one exception occurs when a 0 is passed as the second parameter "
"to ``div`` function. The traceback would look like:"
msgstr ""
"Другий виняток виникає, коли 0 передається як другий параметр функції "
"``div``. Трасування виглядатиме так:"

#: ../../src/basics/exceptions.txt:117
msgid ""
"The traceback indicates all calls (top to bottom) that cause an exception."
msgstr ""
"Зворотне відстеження вказує на всі виклики (зверху вниз), які викликають "
"виняток."

#: ../../src/basics/exceptions.txt:120 ../../src/basics/syntax.txt
msgid "Exception handling"
msgstr "Обробка винятків"

#: ../../src/basics/exceptions.txt:122
msgid ""
"It is possible to write programs that handle selected exceptions. The "
"``try`` statement is used to do that."
msgstr ""
"Можна писати програми, які оброблятимуть вибрані винятки. Для цього "
"використовується інструкція ``try``."

#: ../../src/basics/exceptions.txt:125
msgid "The try statement works as follows."
msgstr "Інструкція try працює наступним чином."

#: ../../src/basics/exceptions.txt:127
msgid ""
"First, the try clause (the statement(s) between the try and except keywords) "
"is executed."
msgstr ""
"Спочатку виконується речення try (вираз(и) між ключовими словами try і "
"except)."

#: ../../src/basics/exceptions.txt:129
msgid ""
"If no exception occurs, the except clause is skipped and execution of the "
"try statement is finished."
msgstr ""
"Якщо винятків не відбувається, пропозиція винятку пропускається, і виконання "
"оператора try завершується."

#: ../../src/basics/exceptions.txt:131
msgid ""
"If an exception occurs during execution of the try clause, the rest of the "
"clause is skipped. Then, if its type matches the exception named after the "
"except keyword, the except clause is executed, and then execution continues "
"after the try/except block."
msgstr ""
"Якщо під час виконання try виникає виняток, решта пропозиції пропускається. "
"Потім, якщо його тип збігається з винятком, названим за ключовим словом "
"osim, виконується пропозиція, а потім виконання продовжується після блоку "
"try/except."

#: ../../src/basics/exceptions.txt:135
msgid ""
"If an exception occurs which does not match the exception named in the "
"except clause, it is passed on to outer try statements; if no handler is "
"found, it is an unhandled exception and execution stops with a message as "
"shown above."
msgstr ""
"Якщо виникає виняток, який не збігається з винятком, названим у реченні "
"винятку, він передається зовнішнім операторам try; якщо обробник не "
"знайдено, це необроблена виняткова ситуація, і виконання зупиняється з "
"повідомленням, як показано вище."

#: ../../src/basics/exceptions.txt:152
msgid ""
"A try statement may have more than one except clause, to specify handlers "
"for different exceptions."
msgstr ""
"Інструкція try може мати більше однієї пропозиції, щоб вказати обробники для "
"різних винятків."

#: ../../src/basics/exceptions.txt:182
msgid "Handling ALL exception"
msgstr "Опрацювання усіх винятків"

#: ../../src/basics/exceptions.txt:184
msgid "It's a bad practice to handle **all** exceptions."
msgstr "Обробляти **всі** винятки – це погана практика."

#: ../../src/basics/exceptions.txt:186
msgid ""
"When indicating an ``except`` block without specifying an exception to catch "
"it will work for any exception, that occurs in ``try`` block. The same is "
"relevant for handling ``BaseException`` and ``Exception``. But you can never "
"say what exact goes wrong."
msgstr ""
"Якщо вказати блок ``except`` без визначення винятку для перехоплення, він "
"працюватиме для будь-якого винятку, який виникає в блоці ``try``. Те саме "
"стосується обробки ``BaseException`` і ``Exception``. Проте ніколи не "
"можливо сказати, який саме виняток стався."

#: ../../src/basics/exceptions.txt:191
msgid ""
"However, this scenario may work for logging an exception and raising it "
"again to be handled on upper levels."
msgstr ""
"Проте, такий сценарій може працювати для логування винятків, після чого вони "
"підійматься заново, щоб бути опрацьованими на вищих рівнях програми."

#: ../../src/basics/exceptions.txt:213
msgid ""
"All exceptions are inherited from ``Exception`` class, which is subclass of "
"``BaseException``. So, you can never know what exactly goes wrong with your "
"code."
msgstr ""
"Усі винятки успадковуються від класу ``Exception``, який є підкласом "
"``BaseException``. Отже, ви ніколи не можете знати, що саме пішло не так із "
"вашим кодом."

#: ../../src/basics/exceptions.txt:218
msgid "``finally`` statement"
msgstr "Вираз ``finally``"

#: ../../src/basics/exceptions.txt:220
msgid ""
"The ``try`` statement cannot be used itself. This will cause "
"``SyntaxError``. Either ``except`` or ``finally`` block is required to be "
"included."
msgstr ""
"Оператор ``try`` не може бути використаний сам по собі. Це спричинить "
"``SyntaxError``. Необхідно включити блок ``except`` або ``finally``."

#: ../../src/basics/exceptions.txt:223
msgid ""
"While the ``except`` block tries to catch the exceptions if any, the "
"``finally`` block will be always executed regardless of the exception occurs."
msgstr ""
"У той час як блок ``except`` намагається перехопити винятки, якщо такі є, "
"блок ``finally`` завжди виконуватиметься незалежно від виникнення винятку."

#: ../../src/basics/exceptions.txt:249
msgid "``else`` statement"
msgstr "Вираз ``else``"

#: ../../src/basics/exceptions.txt:251
msgid ""
"The ``try`` statement can also use ``else`` (which is optional). The "
"statements within this block will be execute only in case there were no "
"exceptions raised while running the ``try``."
msgstr ""
"Оператор ``try`` також може використовувати ``else`` (який є "
"необов'язковим). Інструкції в цьому блоці виконуватимуться лише у випадку, "
"якщо під час виконання ``try`` не було викликано винятків."

#: ../../src/basics/exceptions.txt:273
msgid "Raising exceptions"
msgstr "Винятки: raising"

#: ../../src/basics/exceptions.txt:275
msgid ""
"The ``raise`` statement allows the programmer to force a specified exception "
"to occur. The sole argument to raise indicates the exception to be raised. "
"This must be either an exception instance or an exception class (a class "
"that derives from ``BaseException``, such as ``Exception`` or one of its "
"subclasses). If an exception class is passed, it will be implicitly "
"instantiated by calling its constructor with no arguments."
msgstr ""
"Інструкція ``raise`` дозволяє програмісту примусово викликати певний "
"виняток. Єдиний аргумент, який потрібно викликати, вказує на виняток, який "
"потрібно викликати. Це має бути екземпляр винятку або клас винятку (клас, "
"який походить від ``BaseException``, наприклад ``Exception`` або один із "
"його підкласів). Якщо передано клас винятків, він буде неявно створений "
"шляхом виклику його конструктора без аргументів."

#: ../../src/basics/exceptions.txt:287
msgid ""
"``raise`` statement itself will re-raise all the exceptions within the "
"context. Also exceptions can be raised again from the ``except`` block. It's "
"a common pattern to catch the exception for loggers and when re-raise it."
msgstr ""
"Сам оператор ``raise`` повторно викличе всі винятки в контексті опрацювання. "
"Крім того, винятки можуть бути викликані знову з блоку ``except``. Це "
"загальний шаблон для перехоплення винятку для реєстрації повідомлення про "
"виняткову ситуацію і повторного його підняття."

#: ../../src/basics/exceptions.txt:300
msgid "Creating custom exceptions"
msgstr "Створення винятків"

#: ../../src/basics/exceptions.txt:302
msgid ""
"Programs may name their own exceptions by creating a new exception class. "
"Exceptions should typically be derived from the Exception class, either "
"directly or indirectly."
msgstr ""
"Програми можуть називати власні винятки, створюючи новий клас винятків. "
"Винятки зазвичай мають бути похідними від класу Exception, прямо чи "
"опосередковано."

#: ../../src/basics/exceptions.txt:306
msgid ""
"Exception classes can be defined which do anything any other class can do, "
"but are usually kept simple, often only offering a number of attributes that "
"allow information about the error to be extracted by handlers for the "
"exception."
msgstr ""
"Можна визначити класи винятків, які роблять усе, що може зробити будь-який "
"інший клас, але зазвичай вони прості, часто пропонують лише ряд атрибутів, "
"які дозволяють обробникам витягувати інформацію про помилку для винятку."

#: ../../src/basics/exceptions.txt:311
msgid ""
"Most exceptions are defined with names that end in \"Error\", similar to the "
"naming of the standard exceptions."
msgstr ""
"Більшість винятків визначено з іменами, які закінчуються на \"Error\", "
"подібно до назв стандартних винятків."

#: ../../src/basics/exceptions.txt:314
msgid ""
"Many standard modules define their own exceptions to report errors that may "
"occur in functions they define."
msgstr ""
"Багато стандартних модулів визначають власні винятки, щоб повідомляти про "
"помилки, які можуть виникнути у функціях, які вони визначають."

#: ../../src/basics/exceptions.txt:317
msgid "User-defined exception"
msgstr "Виняток, визначений користувачем"

#: ../../src/basics/functions.txt:-1
msgid "Python functions"
msgstr "Функції в Python"

#: ../../src/basics/functions.txt:-1
msgid "python, basics, functions"
msgstr "python, basics, functions"

#: ../../src/basics/functions.txt:8 ../../src/basics/modules.txt:8
#: ../../src/basics/pep8.txt:8 ../../src/basics/testing.txt:8
msgid "Page is under construction"
msgstr "Сторінка в розробці"

#: ../../src/basics/functions.txt:16 ../../src/basics/syntax.txt
msgid "Functions"
msgstr "Функції"

#: ../../src/basics/index.txt:-1
msgid "Python course - Basics"
msgstr "Курс Python - Основи"

#: ../../src/basics/index.txt:-1
msgid "python, basics, index"
msgstr "python, basics, index"

#: ../../src/basics/index.txt:8
msgid "Python Basics"
msgstr "Основи Python"

#: ../../src/basics/modules.txt:-1
msgid "Modules and imports in Python"
msgstr "Модулі та імпорти в Pythons"

#: ../../src/basics/modules.txt:-1
msgid "python, basics, modules, import"
msgstr "python, basics, modules, import"

#: ../../src/basics/modules.txt:16
msgid "Pythons Modules and Imports"
msgstr "Модулі та імпорт Pythons"

#: ../../src/basics/pep8.txt:-1
msgid "PEP-8 style guide"
msgstr "Керівництво по стилю PEP8"

#: ../../src/basics/pep8.txt:-1
msgid "python, style, guide"
msgstr "python, style, guide"

#: ../../src/basics/pep8.txt:16
msgid "Style Guides: PEP8"
msgstr "Керівництво по стилю: PEP8"

#: ../../src/basics/stdtypes.txt:-1
msgid "Python built-in types"
msgstr "Вбудовані типи даних в Python"

#: ../../src/basics/stdtypes.txt:-1
msgid "python, basics"
msgstr "python, basics"

#: ../../src/basics/stdtypes.txt:8
msgid "Built-in Types"
msgstr "Вбудовані типи"

#: ../../src/basics/stdtypes.txt:10
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions :cite:`docs-python:stdtypes`. This section covers "
"only the most base of them. Others will be discussed in the future within "
"their own topics."
msgstr ""
"Основними вбудованими типами є числа, послідовності, відображення, класи, "
"екземпляри та винятки :cite:`docs-python:stdtypes`. Цей розділ охоплює лише "
"найпростіші з них. Інші будуть обговорюватися в майбутньому в рамках їхніх "
"власних тем."

#: ../../src/basics/stdtypes.txt:16
msgid "Numeric types"
msgstr "Числові типи"

#: ../../src/basics/stdtypes.txt:18
msgid ""
"There are 3 distinct numeric types: *integers*, *floating point numbers*, "
"and *complex numbers*. In addition, Booleans are a subtype of integers. "
"Integers have unlimited precision. Floating point numbers are usually "
"implemented using ``double`` in C. Complex numbers have a real and imaginary "
"part, which are each a floating point number."
msgstr ""
"Існує 3 різних типи чисел: *integers*, *floating point numbers*, та *complex "
"numbers*. Крім того, логічні значення є підтипом цілих чисел. Цілі числа "
"мають необмежену точність. Числа з плаваючою комою зазвичай реалізуються "
"через знак ``double`` у C. Комплексні числа мають дійсну та уявну частини, "
"кожна з яких є числом з плаваючою комою."

#: ../../src/basics/stdtypes.txt:24
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators. Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers. Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers. Appending ``j`` or "
"``J`` to a numeric literal yields an imaginary number (a complex number with "
"a zero real part) which you can add to an integer or float to get a complex "
"number with real and imaginary parts."
msgstr ""
"Числа створюються за допомогою числових літералів або як результат "
"вбудованих функцій і операторів. Неприкрашені цілі літерали (включаючи "
"шістнадцяткові, вісімкові та двійкові числа) дають цілі числа. Числові "
"літерали, що містять десяткову кому або знак експоненти, дають числа з "
"плаваючою комою. Додавання ``j`` або ``J`` до числового літералу дає уявне "
"число (комплексне число з нульовою дійсною частиною), яке ви можете додати "
"до цілого числа або числа з плаваючою точкою, щоб отримати комплексне число "
"з дійсною та уявною частинами."

#: ../../src/basics/stdtypes.txt:33
msgid "Supported operations"
msgstr "Операції підтримки"

#: ../../src/basics/stdtypes.txt:36 ../../src/basics/stdtypes.txt:154
#: ../../src/basics/stdtypes.txt:204
msgid "Operation"
msgstr "Операції"

#: ../../src/basics/stdtypes.txt:36 ../../src/basics/stdtypes.txt:154
#: ../../src/basics/stdtypes.txt:204
msgid "Result"
msgstr "Результат"

#: ../../src/basics/stdtypes.txt:38
msgid "``x + y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:38
msgid "sum of *x* and *y*"
msgstr "сума *x* і *y*"

#: ../../src/basics/stdtypes.txt:40
msgid "``x - y``"
msgstr "``x - y``"

#: ../../src/basics/stdtypes.txt:40
msgid "difference of *x* and *y*"
msgstr "різниця між *x* і *y*"

#: ../../src/basics/stdtypes.txt:42
msgid "``x * y``"
msgstr "``x * y``"

#: ../../src/basics/stdtypes.txt:42
msgid "product of *x* and *y*"
msgstr "добуток *x* і *y*"

#: ../../src/basics/stdtypes.txt:44
msgid "``x / y``"
msgstr "``x / y``"

#: ../../src/basics/stdtypes.txt:44
msgid "quotient of *x* and *y*"
msgstr "частка *x* і *y*"

#: ../../src/basics/stdtypes.txt:46
msgid "``x // y``"
msgstr "``x // y``"

#: ../../src/basics/stdtypes.txt:46
msgid "floored quotient of *x* and *y*"
msgstr "цілочисельне ділення *x* і *y*"

#: ../../src/basics/stdtypes.txt:48
msgid "``x % y``"
msgstr "``x % y``"

#: ../../src/basics/stdtypes.txt:48
msgid "remainder of ``x / y``"
msgstr "залишок від ділення ``x / y``"

#: ../../src/basics/stdtypes.txt:50
msgid "``-x``"
msgstr "``-x``"

#: ../../src/basics/stdtypes.txt:50
msgid "*x* negated"
msgstr "*x* від'ємне"

#: ../../src/basics/stdtypes.txt:52
msgid "``+x``"
msgstr "``+x``"

#: ../../src/basics/stdtypes.txt:52
msgid "*y* unchanged"
msgstr "*y* без змін"

#: ../../src/basics/stdtypes.txt:54
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../src/basics/stdtypes.txt:54
msgid "absolute value or magnitude of *x*"
msgstr "абсолютне значення або величина *x*"

#: ../../src/basics/stdtypes.txt:56
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../src/basics/stdtypes.txt:56
msgid "*x* converted to integer"
msgstr "*x* перетворено на ціле число"

#: ../../src/basics/stdtypes.txt:58
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../src/basics/stdtypes.txt:58
msgid "*x* converted to floating point"
msgstr "*x* перетворено на число з плаваючою комою"

#: ../../src/basics/stdtypes.txt:60
msgid "``complex(re, im)``"
msgstr "``complex(re, im)``"

#: ../../src/basics/stdtypes.txt:60
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"комплексне число з дійсною частиною *re*, уявною частиною *im*. *im* за "
"замовчуванням на нуль."

#: ../../src/basics/stdtypes.txt:63
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../src/basics/stdtypes.txt:63
msgid "the pair ``(x // y, x % y)``"
msgstr "об'єднує ``(x // y, x % y)``"

#: ../../src/basics/stdtypes.txt:65
msgid "``pow(x, y)`` ``x ** y``"
msgstr "``pow(x, y)`` ``x ** y``"

#: ../../src/basics/stdtypes.txt:65
msgid "*x* to the power *y*"
msgstr "*x* у степені *y*"

#: ../../src/basics/stdtypes.txt:69
msgid ""
"``x // y`` also referred to as integer division. The resultant value is a "
"whole integer, through the result's type is not necessarily int. The result "
"is always rounded towards minus infinity: ``1 // 2`` is ``0``"
msgstr ""
"``x // y`` також називають цілим діленням. Результуюче значення є цілим "
"числом, через тип результату не обов'язково int. Результат завжди "
"округлюється до мінус нескінченності: ``1 // 2`` дорівнює ``0``"

#: ../../src/basics/stdtypes.txt:74
msgid ""
"``float(x)`` also accepts the strings ``\"nan\"`` and ``\"inf\"`` with an "
"optional prefix \"+\" or \"-\" for :abbr:`NaN(Not a Number)` and positive "
"and negative infinity."
msgstr ""
"``float(x)`` також приймає рядки ``\"nan\"`` та ``\"inf\"`` з необов'язковим "
"префіксом \"+\" або \"-\" для: :abbr:`NaN(Not a Number, не число)` і "
"позитивна та негативна нескінченність."

#: ../../src/basics/stdtypes.txt:79
msgid "Code examples"
msgstr "Приклади коду"

#: ../../src/basics/stdtypes.txt:81
msgid "Integer numbers"
msgstr "Цілі числа"

#: ../../src/basics/stdtypes.txt:94
msgid "Floating point numbers"
msgstr "Числа з плаваючою комою"

#: ../../src/basics/stdtypes.txt:109 ../../src/basics/stdtypes.txt:182
#: ../../src/basics/stdtypes.txt:290 ../../src/basics/stdtypes.txt:299
#: ../../src/basics/stdtypes.txt:328
msgid "Value comparisons"
msgstr "Порівняння цінностей"

#: ../../src/basics/stdtypes.txt:111
msgid ""
"Numbers of built-in numeric types can be compared within and across their "
"types (with the restriction that complex numbers do not support order "
"comparison). Within the limits of the types involved, they compare "
"mathematically correct without loss of precision."
msgstr ""
"Числа вбудованих числових типів можна порівнювати всередині та між типами (з "
"обмеженням, що комплексні числа не підтримують порядок порівняння). У межах "
"залучених типів вони порівняються математично правильно без втрати точності."

#: ../../src/basics/stdtypes.txt:116
msgid ""
"The \"not-a-number\" values ``float(\"NaN\")`` and ``decimal."
"Decimal('NaN')`` are special. Any ordered comparison of a number to a not-a-"
"number value is false."
msgstr ""
"Значення \"not-a-number\" ``float(\"NaN\")`` і ``decimal.Decimal('NaN')`` є "
"спеціальними. Будь-яке впорядковане порівняння числа з нечисловим значенням "
"є хибним."

#: ../../src/basics/stdtypes.txt:120
msgid "Sequence types"
msgstr "Типи послідовностей"

#: ../../src/basics/stdtypes.txt:122
msgid ""
"There are 3 basic sequence types: *lists*, *tuples*, and *range objects*. "
"Additional sequence types tailored for processing of binary data and text "
"strings are described in dedicated sections."
msgstr ""
"Існує 3 основних типи послідовностей: списки, кортежі та об'єкти діапазону. "
"Додаткові типи послідовностей, призначені для обробки двійкових даних і "
"текстових рядків, описані у інших розділах."

#: ../../src/basics/stdtypes.txt:127
msgid "Lists"
msgstr "Списки"

#: ../../src/basics/stdtypes.txt:129
msgid ""
"Lists are mutable sequences, typically used to store collections of items. "
"They may be constructed in several ways:"
msgstr ""
"Списки - це змінні послідовності, які зазвичай використовуються для "
"зберігання колекцій елементів. Вони можуть бути побудовані кількома "
"способами:"

#: ../../src/basics/stdtypes.txt:132
msgid "using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"використовуючи пару квадратних дужок для cтворення порожнього списку: ``[]``"

#: ../../src/basics/stdtypes.txt:133
msgid ""
"using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"використовуючи квадратні дужки, розділяючи елементи комами: ``[a]``, ``[a, "
"b, c]``"

#: ../../src/basics/stdtypes.txt:134
msgid "using a list comprehension: ``[x for x in iterable]``"
msgstr "використовуючи генератори списків: ``[x for x in iterable]``"

#: ../../src/basics/stdtypes.txt:135
msgid "using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "використовуючи конструкції типу: ``list()`` або ``list(iterable)``"

#: ../../src/basics/stdtypes.txt:138
msgid "Tuples"
msgstr "Кортежі"

#: ../../src/basics/stdtypes.txt:140
msgid ""
"Tuples are immutable sequences, typically used to store collections of data "
"or for cases where an immutable sequence of data is needed (such as allowing "
"storage in a ``set`` or ``dict`` instances). They may be constructed in a "
"number of ways:"
msgstr ""
"Кортежі - це незмінні послідовності, які зазвичай використовуються для "
"зберігання колекцій даних або для випадків, коли потрібна незмінна "
"послідовність даних (наприклад, дозволяє зберігати в екземплярах ``set`` або "
"``dict``). Вони можуть бути конструйовані декількома способами:"

#: ../../src/basics/stdtypes.txt:145
msgid "using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"використовуючи пару круглих дужок для позначення порожнього кортежу: ``()``"

#: ../../src/basics/stdtypes.txt:146
msgid "using a trailing comma for a singleton tuple: ``a,`` or ``(a, b, c)``"
msgstr ""
"використовуючи кінцеву кому для одноэлементного кортежу: ``a,`` або ``(a, b, "
"c)``"

#: ../../src/basics/stdtypes.txt:147
msgid "separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "відокремлюючи елементи комами: ``a, b, c`` або ``(a, b, c)``"

#: ../../src/basics/stdtypes.txt:148
msgid "using the type constructor: ``tuple()`` or ``tuple(iterable)``"
msgstr "за допомогою конструктора типу: ``tuple()`` або ``tuple(iterable)``"

#: ../../src/basics/stdtypes.txt:151
msgid "Common operations"
msgstr "Загальні операції"

#: ../../src/basics/stdtypes.txt:156
msgid "``x in s`` ``x not in s``"
msgstr "``x in s`` ``x not in s``"

#: ../../src/basics/stdtypes.txt:156
msgid ""
"``True`` if an item of *s* equal to *x* ``False`` if an item of *s* equal to "
"*x*"
msgstr ""
"``True``, якщо елемент *s* дорівнює *x* ``False``, якщо елемент *s* дорівнює "
"*x*"

#: ../../src/basics/stdtypes.txt:159
msgid "``s + t``"
msgstr "``s + t``"

#: ../../src/basics/stdtypes.txt:159
msgid "the concatenation of *s* and *t*"
msgstr "конкатенація s і t"

#: ../../src/basics/stdtypes.txt:161
msgid "``s * n``"
msgstr "``s * n``"

#: ../../src/basics/stdtypes.txt:161
msgid "equivalent to adding *s* to itself *n* times"
msgstr "еквівалентно додаванню *s* до себе *n* разів"

#: ../../src/basics/stdtypes.txt:163
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../src/basics/stdtypes.txt:163
msgid "*i*-th item of *s*, origin 0"
msgstr "*i*-й елемент *s*, джерело 0"

#: ../../src/basics/stdtypes.txt:165
msgid "``s[i:j]`` ``s[i:j:k]``"
msgstr "``s[i:j]`` ``s[i:j:k]``"

#: ../../src/basics/stdtypes.txt:165
msgid ""
"slice of *s* from *i* to *j* with step *k*. any of these (or even all 3) may "
"be omitted."
msgstr ""
"фрагмент *s* від *i* до *j* з кроком *k*. будь-який із цих (або навіть усі "
"3) можна опустити."

#: ../../src/basics/stdtypes.txt:168
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../src/basics/stdtypes.txt:168
msgid "length of *s*"
msgstr "довжина *s*"

#: ../../src/basics/stdtypes.txt:170
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../src/basics/stdtypes.txt:170
msgid "smallest item of *s*"
msgstr "найменший елемент *s*"

#: ../../src/basics/stdtypes.txt:172
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../src/basics/stdtypes.txt:172
msgid "largest item of *s*"
msgstr "найбільший елемент *s*"

#: ../../src/basics/stdtypes.txt:174
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../src/basics/stdtypes.txt:174
msgid "total number of occurrences of *x* in *s*"
msgstr "загальна кількість входжень *x* у *s*"

#: ../../src/basics/stdtypes.txt:176
msgid "``s.index(x)`` ``s.index(x, i)`` ``s.index(x, i, j)``"
msgstr "``s.index(x)`` ``s.index(x, i)`` ``s.index(x, i, j)``"

#: ../../src/basics/stdtypes.txt:176
msgid ""
"index of the first occurrence of *x* in *s* at or after index *i* and before "
"index *j*"
msgstr ""
"індекс першого входження *x* у *s* на або після індексу *i* та перед "
"індексом *j*"

#: ../../src/basics/stdtypes.txt:184
msgid ""
"Sequences can be compared only within each of their types, with the "
"restriction that ranges do not support order comparison. Equality comparison "
"across these types results in inequality, and ordering comparison across "
"these types raises ``TypeError``."
msgstr ""
"Послідовності можна порівнювати лише в межах кожного типу, з обмеженням, що "
"діапазони не підтримують порівняння порядку. Порівняння рівності між цими "
"типами призводить до нерівності, а впорядковане порівняння цих типів "
"викликає ``TypeError``."

#: ../../src/basics/stdtypes.txt:189
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements. The built-in containers typically assume identical objects are "
"equal to themselves. Lexicographical comparison between built-in collections "
"works as follows:"
msgstr ""
"Послідовності порівнюють лексикографічно за допомогою порівняння відповідних "
"елементів. Вбудовані контейнери зазвичай припускають, що ідентичні об'єкти "
"рівні собі. Лексикографічне порівняння між вбудованими колекціями працює "
"таким чином:"

#: ../../src/basics/stdtypes.txt:194
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal."
msgstr ""
"Щоб дві колекції порівнювалися рівноправними, вони повинні бути одного типу, "
"мати однакову довжину, і кожна пара відповідних елементів повинна "
"порівнюватися."

#: ../../src/basics/stdtypes.txt:196
msgid ""
"Collections that supports order comparison are ordered the same as their "
"first unequal elements. If corresponding element does not exist, the shorter "
"collection is ordered first."
msgstr ""
"Колекції, які підтримують порівняння порядку, упорядковуються так само, як і "
"їхні перші нерівні елементи. Якщо відповідний елемент не існує, спочатку "
"впорядковується коротша колекція."

#: ../../src/basics/stdtypes.txt:201
msgid "Mutable sequence types"
msgstr "Змінні типи послідовностей"

#: ../../src/basics/stdtypes.txt:206
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../src/basics/stdtypes.txt:206
msgid "item *i* of *s* is replaced by *x*"
msgstr "елемент *i* з *s* замінюється на *x*"

#: ../../src/basics/stdtypes.txt:208
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../src/basics/stdtypes.txt:208
msgid "slice of *s* from *i* to *j* replaced by the contents of *t*"
msgstr "фрагмент *s* від *i* до *j*, замінений вмістом *t*"

#: ../../src/basics/stdtypes.txt:211
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../src/basics/stdtypes.txt:211
msgid "same as ``s[i:j] = []``"
msgstr "те саме, що ``s[i:j] = []``"

#: ../../src/basics/stdtypes.txt:213
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../src/basics/stdtypes.txt:213
msgid "the elements of *s* are replaced by those of *t* [#]_"
msgstr "елементи *s* замінюються елементами *t* [#]_"

#: ../../src/basics/stdtypes.txt:215
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../src/basics/stdtypes.txt:215
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "видаляє елементи ``s[i:j:k]`` зі списку"

#: ../../src/basics/stdtypes.txt:217
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../src/basics/stdtypes.txt:217
msgid ""
"appends *x* to the end of the sequence; the same as ``s[len(s):len(s)] = "
"[x]``"
msgstr ""
"додає *x* до кінця послідовності; те саме, що ``s[len(s):len(s)] = [x]``"

#: ../../src/basics/stdtypes.txt:220
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../src/basics/stdtypes.txt:220
msgid "removes all items from *s* (``del s[:]``) [#py33]_"
msgstr "видаляє всі елементи з *s* (``del s[:]``) [#py33]_"

#: ../../src/basics/stdtypes.txt:222
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../src/basics/stdtypes.txt:222
msgid "creates a shallow copy of *s* (``s[:]``) [#py33]_"
msgstr "створює поверхневу копію *s* (``s[:]``) [#py33]_"

#: ../../src/basics/stdtypes.txt:224
msgid "``s.extend(t)`` ``s += t``"
msgstr "``s.extend(t)`` ``s += t``"

#: ../../src/basics/stdtypes.txt:224
msgid "extends *s* with the contents of *t*"
msgstr "розширює *s* вмістом *t*"

#: ../../src/basics/stdtypes.txt:227
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../src/basics/stdtypes.txt:227
msgid "inserts *x* into *s* at the index *i*; same as ``s[i:i] = [x]``"
msgstr "вставляє *x* у *s* за індексом *i*; те саме, що ``s[i:i] = [x]``"

#: ../../src/basics/stdtypes.txt:230
msgid "``s.pop()``, ``s.pop(i)``"
msgstr "``s.pop()``, ``s.pop(i)``"

#: ../../src/basics/stdtypes.txt:230
msgid ""
"retrieves the item at *i* and also removes it from *s* (if *i* is omitted - "
"use the last one available index)"
msgstr ""
"отримує елемент за адресою *i*, а також видаляє його з *s* (якщо *i* "
"пропущено - використовуйте останній доступний індекс)"

#: ../../src/basics/stdtypes.txt:233
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../src/basics/stdtypes.txt:233
msgid "remove the first item that is equal to *x* from *s*"
msgstr "видалити перший елемент, який дорівнює *x*, із *s*"

#: ../../src/basics/stdtypes.txt:235
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../src/basics/stdtypes.txt:235
msgid "reverses the items of *s* in place"
msgstr "перевертає елементи *s* на місце"

#: ../../src/basics/stdtypes.txt:238
msgid "*t* must have the same length as the slice it is replacing"
msgstr "*t* повинен мати таку ж довжину, як і фрагмент, який він замінює"

#: ../../src/basics/stdtypes.txt:239
msgid "new in Python version 3.3"
msgstr "нове у версії Python 3.3"

#: ../../src/basics/stdtypes.txt:242
msgid "Text sequence type"
msgstr "Тип текстової послідовності"

#: ../../src/basics/stdtypes.txt:245
msgid "String methods"
msgstr "Рядкові методи"

#: ../../src/basics/stdtypes.txt:247
msgid ""
"Strings implement all of the common sequence operations, along with the "
"additional methods."
msgstr ""
"Рядки реалізують усі звичайні операції з послідовністю разом із додатковими "
"методами."

#: ../../src/basics/stdtypes.txt:292
msgid ""
"Strings compare lexicographically using the numerical Unicode code points of "
"their characters."
msgstr ""
"Рядки порівнюються лексикографічно з використанням числових кодових точок "
"Unicode своїх символів."

#: ../../src/basics/stdtypes.txt:296
msgid "Set types"
msgstr "Типи сетів"

#: ../../src/basics/stdtypes.txt:301
msgid ""
"Sets (instances of ``set`` or ``frozenset``) can be compared within and "
"across their types. They define order comparison operators to mean subset "
"and superset tests. Those relations do not define total ordering (e.g. two "
"sets ``{1, 2}`` and ``{2, 3}`` are not equal, nor subsets of one another, "
"nor supersets of one another)."
msgstr ""
"Сети (екземпляри ``set`` або ``frozenset``) можна порівнювати всередині та "
"між типами. Вони визначають оператори порівняння порядку, щоб проходити "
"тести підмножини та надмножини. Ці відношення не визначають загального "
"порядку (наприклад, два набори ``{1, 2}`` та ``{2, 3}`` не є рівними, ані "
"підмножини одного іншого, ані надмножини один одного)."

#: ../../src/basics/stdtypes.txt:308
msgid "Mapping type"
msgstr "Тип відображення"

#: ../../src/basics/stdtypes.txt:310
msgid ""
"A mapping object maps hashable values to arbitrary objects. Mappings are "
"mutable objects. There is currently ony one standard mapping type, the "
"*dictionary*. In few words mappings are collections of keys and their values."
msgstr ""
"Об'єкт зіставлення зіставляє хешовані значення з довільними об'єктами. "
"Відображення є змінними об'єктами. Наразі існує лише один стандартний тип "
"відображення, *dictionary*. Якщо кількома словами, то відображення - це "
"набори ключів та їхніх значень."

#: ../../src/basics/stdtypes.txt:314
msgid ""
"A dictionary's keys are almost arbitrary values. Values that are not "
"hashable may not be used as keys. Values that compare equal (such as ``1``, "
"``1.0`` and ``True``) can be used interchangeably to index the same "
"dictionary entry."
msgstr ""
"Ключі словника - це майже довільні значення. Значення, які не хешуються, не "
"можуть бути використані як ключі. Значення, які порівнюються (такі як ``1``, "
"``1.0`` і ``True``), можна використовувати як взаємозамінні для індексування "
"тієї самої словникової статті."

#: ../../src/basics/stdtypes.txt:318
msgid "Dictionaries can be created by several means:"
msgstr "Словники можна створювати кількома способами:"

#: ../../src/basics/stdtypes.txt:320
msgid "Use braces to denote the empty dictionary: ``{}``"
msgstr "Використовуйте дужки для позначення порожнього словника: ``{}``"

#: ../../src/basics/stdtypes.txt:321
msgid ""
"Use a comma-separated list of ``key: value`` pairs with braces: "
"``{'first_name': 'Serhii', 'last_name': 'Horodilov', 'age': 34}``"
msgstr ""
"Використовуйте розділений комами список пар ``key: value`` з дужками: "
"``{'first_name': 'Serhii', 'last_name': 'Horodilov', 'age': 34}``"

#: ../../src/basics/stdtypes.txt:323
msgid "Use a dict comprehension: ``{x: x ** 2 for x in range(10)}``"
msgstr "Використовуючи генератори списків: ``{x: x 2 for x in range(10)}``"

#: ../../src/basics/stdtypes.txt:324
msgid ""
"Use the type constructor: ``dict()``, ``dict([('key', 100)])``, "
"``dict(key=100)``"
msgstr ""
"Використовуйте конструктор типу: ``dict()``, ``dict([('key', 100)])``, "
"``dict(key=100)``"

#: ../../src/basics/stdtypes.txt:330
msgid ""
"Instances of ``dict`` compare equal if and only if they have equal key-value "
"pairs."
msgstr ""
"Екземпляри ``dict`` вважаються рівними тоді і тільки тоді, коли вони мають "
"однакові пари ключ-значення."

#: ../../src/basics/stdtypes.txt:333
msgid "Order comparisons raise ``TypeError``."
msgstr "Порівняння порядку викликає ``TypeError``."

#: ../../src/basics/syntax.txt:-1
msgid "Python syntax"
msgstr "Синтаксис Python"

#: ../../src/basics/syntax.txt:-1
msgid "python, basics, syntax"
msgstr "python, basics, syntax"

#: ../../src/basics/syntax.txt:8
msgid "Python Syntax"
msgstr "Синтаксис Python"

#: ../../src/basics/syntax.txt:10
msgid ""
"As a natural language like English or Ukrainian has its own rules to write "
"down something, programming languages do. This makes them programming "
"**languages**."
msgstr ""
"Оскільки природна мова, як-от англійська чи українська, має власні правила "
"запису чогось, так і мови програмування роблять схожі речі. Це і робить їх "
"мовами програмування."

#: ../../src/basics/syntax.txt:14
msgid ""
"A programming language syntax is the set of rules and principles that govern "
"how code is written and structured in a given programming language. Syntax "
"encompasses the rules for writing statements, expressions, variables, data "
"types, control structures, and other constructs that make up the language."
msgstr ""
"Синтаксис мови програмування - це набір правил і принципів, які регулюють "
"написання та структурування коду даною мовою програмування. Синтаксис "
"охоплює правила написання операторів, виразів, змінних, типів даних, "
"керуючих структур та інших конструкцій, які складають мову."

#: ../../src/basics/syntax.txt:19
msgid ""
"The syntax of a programming language defines how code is organized and "
"interpreted by a compiler or interpreter. It defines the rules for writing "
"valid statements and expressions that can be understood and executed by the "
"language's runtime system."
msgstr ""
"Синтаксис мови програмування визначає, як код організовується та "
"інтерпретується компілятором або інтерпретатором. Він визначає правила "
"написання дійсних операторів і виразів, які можуть бути зрозумілі та "
"виконані системою виконання мови."

#: ../../src/basics/syntax.txt:24
msgid ""
"A programming language's syntax is designed to be both readable and "
"expressive, allowing programmers to write code that is easy to understand "
"and modify. Syntax often influences the style and structure of code, as well "
"as its maintainability and performance."
msgstr ""
"Синтаксис мови програмування розроблено таким чином, щоб він був читабельним "
"і виразним, дозволяючи програмістам писати код, який легко зрозуміти та "
"змінювати. Синтаксис часто впливає на стиль і структуру коду, а також на "
"його зручність обслуговування та продуктивність."

#: ../../src/basics/syntax.txt:29
msgid ""
"Different programming languages have different syntax, with some languages "
"being more concise and expressive than others. While syntax is an important "
"aspect of a programming language, it is only one of several factors that "
"determine its ease of use, flexibility, and suitability for different "
"programming tasks."
msgstr ""
"Різні мови програмування мають різний синтаксис, при цьому деякі мови є "
"більш лаконічними та виразнішими, ніж інші. Хоча синтаксис є важливим "
"аспектом мови програмування, він є лише одним із кількох факторів, які "
"визначають її легкість у використанні, гнучкість і придатність для різних "
"завдань програмування."

#: ../../src/basics/syntax.txt:35
msgid ""
"In the case of Python, the language's syntax defines how code is written and "
"structured in a way that is consistent, readable, and easy to understand. A "
"general overview is provided below, no need to dive deep in this now. All of "
"the following is to be discussed during the course. So, some of the key "
"aspects of Python's syntax include:"
msgstr ""
"У випадку Python синтаксис мови визначає, як код буде написаний і "
"структурований таким чином, щоб він був послідовним, читабельним і легким "
"для розуміння. Нижче наведено загальний огляд, немає потреби глибоко "
"занурюватися в це зараз. Усе наведене нижче має бути обговорено під час "
"курсу. Отже, деякі з ключових аспектів синтаксису Python включають:"

#: ../../src/basics/syntax.txt
msgid "Indentation"
msgstr "Відступ"

#: ../../src/basics/syntax.txt:42
msgid ""
"Python uses whitespace, specifically indentation, to delimit blocks of code, "
"such as loops, conditionals, and functions. This means that the indentation "
"level of a line determines which block of code it belongs to."
msgstr ""
"Python використовує пробіли, зокрема відступи, для розмежування блоків коду, "
"таких як цикли, умови та функції. Це означає, що рівень відступу рядка "
"визначає, до якого блоку коду він належить."

#: ../../src/basics/syntax.txt
msgid "Statement structure"
msgstr "Структура коду"

#: ../../src/basics/syntax.txt:48
msgid ""
"Python statements are typically written on one line, with the end of the "
"line indicating the end of the statement. However, if a statement is too "
"long to fit on one line, it can be continued across multiple lines using "
"backslashes."
msgstr ""
"Інструкції Python зазвичай пишуться в один рядок, причому кінець рядка "
"вказує на кінець інструкції. Проте, якщо оператор занадто довгий, щоб "
"поміститися в один рядок, його можна продовжити в кількох рядках, "
"використовуючи зворотні похилі риски."

#: ../../src/basics/syntax.txt ../../src/basics/variables.txt:8
msgid "Variables"
msgstr "Змінні"

#: ../../src/basics/syntax.txt:54
msgid ""
"In Python, variables are created automatically when a value is assigned to "
"them, and their type is inferred from the value. Variables can be assigned "
"values of different types, including integers, floats, strings, and more "
"complex data structures like lists and dictionaries."
msgstr ""
"У Python змінні створюються автоматично, якщо їм присвоюється значення, і "
"їхній тип визначається на основі значення. Змінним можна присвоювати "
"значення різних типів, включаючи цілі числа, числа з плаваючою комою, рядки "
"та складніші структури даних, такі як списки та словники."

#: ../../src/basics/syntax.txt
msgid "Operators"
msgstr "Оператори"

#: ../../src/basics/syntax.txt:60
msgid ""
"Python supports a wide range of operators for performing arithmetic, "
"comparison, and logical operations. These include arithmetic operators like "
"``+``, ``-``, ``*``, and ``/``, as well as comparison operators like ``<``, "
"``>``, ``==``, and ``!=``."
msgstr ""
"Python підтримує широкий спектр операторів для виконання арифметичних, "
"порівнянь і логічних операцій. До них належать арифметичні оператори, такі "
"як ``+``, ``-``, ``*`` і ``/``, а також оператори порівняння, такі як "
"``<`` , ``>``, ``==`` і ``!=``."

#: ../../src/basics/syntax.txt
msgid "Control flow"
msgstr "Контроль потоку"

#: ../../src/basics/syntax.txt:66
msgid ""
"Python provides control flow statements like if, else, elif, for, and while "
"to control the flow of execution in a program. These statements are used to "
"make decisions, repeat code, or perform actions based on conditions."
msgstr ""
"Python надає оператори потоку керування, як-от if, else, elif, for та while, "
"для керування потоком виконання в програмі. Ці оператори використовуються "
"для прийняття рішень, повторення коду або виконання дій на основі заданих "
"умов."

#: ../../src/basics/syntax.txt:72
msgid ""
"In Python, functions are defined using the def keyword and can take "
"arguments and return values. The body of a function is defined using a block "
"of indented code."
msgstr ""
"У Python функції визначаються за допомогою ключового слова def і можуть "
"отримувати аргументи та повертати значення. Тіло функції визначається за "
"допомогою блоку коду з відступами."

#: ../../src/basics/syntax.txt
msgid "Modules"
msgstr "Модулі"

#: ../../src/basics/syntax.txt:77
msgid ""
"Python has a large library of modules that provide pre-written code for a "
"variety of tasks. Modules can be imported into a program using the import "
"statement."
msgstr ""
"Python має велику бібліотеку модулів, які містять попередньо написаний код "
"для різноманітних завдань. Модулі можна імпортувати в програму за допомогою "
"оператора імпорту."

#: ../../src/basics/syntax.txt:82
msgid ""
"Python provides a way to handle errors and exceptions in a program using the "
"try, except, else, and finally keywords. These statements allow a program to "
"gracefully recover from errors and continue executing."
msgstr ""
"Python надає спосіб обробки помилок і винятків у програмі за допомогою "
"ключових слів try, except, else і finally. Ці оператори дозволяють програмі "
"плавно відновлюватися після помилок і продовжувати виконання."

#: ../../src/basics/syntax.txt:86
msgid "In few words:"
msgstr "У кількох словах:"

#: ../../src/basics/syntax.txt:88
msgid "Input/Output example script"
msgstr "Приклад сценарію Input/Output"

#: ../../src/basics/syntax.txt:107
msgid ""
"The code snippet above demonstrates some basics abilities of Python to "
"gather data from the user, process it and print out back. Note the words "
"starting with a # (hash) symbol. This is a comment. Any sequence of "
"characters after the hash and till the line end are considered to be a "
"comment. These are for those people, who see the code and they are ignored "
"by the interpreter."
msgstr ""
"Наведений вище фрагмент коду демонструє деякі основні можливості Python "
"збирати дані від користувача, обробляти їх і друкувати назад. Зверніть увагу "
"на слова, що починаються символом #(решітка). Це коментар. Будь-яка "
"послідовність символів після хеша і до кінця рядка вважається коментарем. Це "
"необхідно, щоб люди які бачать код могли його зрозуміти, при цьому "
"інтерпретатор їх ігнорує."

#: ../../src/basics/syntax.txt:113
msgid ""
"On the other hand each individual line is the instruction for the "
"interpreter to perform some action, like gather inputs, do math, store data "
"in memory etc."
msgstr ""
"З іншого боку, кожен окремий рядок є вказівкою для інтерпретатора виконати "
"певну дію, як-от збір вхідних даних, виконання математичних розрахунків, "
"збереження даних у пам'яті тощо."

#: ../../src/basics/testing.txt:-1
msgid "Testing software in Python"
msgstr "Тестування в Python"

#: ../../src/basics/testing.txt:-1
msgid "python, testing, unittest, pytest"
msgstr "python, testing, unittest, pytest"

#: ../../src/basics/testing.txt:16
msgid "Testing"
msgstr "Тестування"

#: ../../src/basics/variables.txt:-1
msgid "Variables in programming"
msgstr "Змінні в програмуванні"

#: ../../src/basics/variables.txt:-1
msgid "programming, basics, variables"
msgstr "programming, basics, variables"

#: ../../src/basics/variables.txt:10
msgid ""
"In computer science a **variable** is a named storage location in memory "
"that can hold a value (*data*). The value stored in a variable can be "
"changed or accessed by the program during its execution."
msgstr ""
"В інформатиці **variable** - це назване місце зберігання в пам'яті, яке може "
"зберігати значення (дані). Значення, яке зберігається у змінній, може бути "
"змінено або доступне програмою під час її виконання."

#: ../../src/basics/variables.txt:14
msgid ""
"In Python, variables are created dynamically once a value is assigned to "
"them. This makes Python a dynamically typed language, which means that the "
"data type of a variable is inferred from the value assigned to it. So, you "
"do not need to declare a variable before using it, as in statically typed "
"languages."
msgstr ""
"У Python змінні створюються динамічно після присвоєння їм значення. Це "
"робить Python динамічно типізованою мовою, а це означає, що тип даних "
"змінної виводиться з присвоєного їй значення. Отже, вам не потрібно "
"оголошувати змінну перед її використанням, як у статично типізованих мовах."

#: ../../src/basics/variables.txt:19
msgid ""
"The ability to create variables dynamically and infer their data type makes "
"Python code more concise and easier to read. However, it also requires "
"careful attention to variable naming and assignment to avoid unexpected "
"behavior."
msgstr ""
"Можливість динамічно створювати змінні та виводити їхні типи даних робить "
"код Python більш лаконічним і легшим для читання. Однак це також вимагає "
"пильної уваги до іменування та призначення змінних, щоб уникнути "
"неочікуваної поведінки."

#: ../../src/basics/variables.txt:23
msgid ""
"In Python ``=`` (assignment operator) is used to set a value to some "
"variable, the portion on the left of the operator is a *variable name* and "
"the portion on the right is a *value* to assign to a variable."
msgstr ""
"У Python ``=`` (оператор присвоєння) використовується для встановлення "
"значення деякої змінної, частина ліворуч від оператора - це ім'я змінної, а "
"частина праворуч - це значення, яке призначається для неї."

#: ../../src/basics/variables.txt:27
msgid "Variable assignment in Python"
msgstr "Присвоєння змінної в Python"

#: ../../src/basics/variables.txt:34
msgid "Variable assignment in Java"
msgstr "Присвоєння змінної в Java"

#: ../../src/basics/variables.txt:42
msgid "Naming"
msgstr "Присвоєння назви"

#: ../../src/basics/variables.txt:44
msgid ""
"In Python there are several rules that describe how to name your variables. "
"Some of these are requirements and cannot be ignored, others are rather "
"recommended than required and can be omitted. For now note, that a variable "
"name **cannot**:"
msgstr ""
"У Python є кілька правил, які описують, як іменувати ваші змінні. Деякі з "
"них є вимогами, і їх не можна ігнорувати, інші скоріше рекомендовані, ніж "
"обов'язкові, і їх можна пропустити. Наразі зауважте, що ім'я змінної не може:"

#: ../../src/basics/variables.txt:49
msgid "a language keyword (like ``pass``, ``def`` or ``class``)"
msgstr "бути ключовим словом мови (наприклад, ``pass``, ``def`` або ``class``)"

#: ../../src/basics/variables.txt:50
msgid "start with a number (e.g. ``123``, ``1_something``)"
msgstr "починатися з числа (наприклад, ``123``, ``1_something``)"

#: ../../src/basics/variables.txt:51
msgid "contain special operators in it (``+``, ``-``, ``=`` etc.)"
msgstr "містити спеціальні оператори (``+``, ``-``, ``=`` тощо)"

#: ../../src/basics/variables.txt:52
msgid "contain white spaces"
msgstr "містити пробіли"

#: ../../src/basics/variables.txt:54
msgid "Also here are some general recommendation on naming anything:"
msgstr "Також ось деякі загальні рекомендації щодо іменування будь-чого:"

#: ../../src/basics/variables.txt:56
msgid "do not use built-in functions as a variable name (e.g. ``len = 42``)"
msgstr ""
"не використовуйте вбудовані функції як назву змінної (наприклад, ``len = "
"42``)"

#: ../../src/basics/variables.txt:57
msgid "keep names meaningful (``x = 10`` vs ``number_of_student = 100``)"
msgstr ""
"зберігайте значення імен (``x = 10`` проти ``number_of_student = 100``)"

#~ msgid "Data Types"
#~ msgstr "Типи Даних"

#~ msgid ""
#~ "Data may represent different things and require various operations "
#~ "available. In programming data types is an important concept. For example "
#~ "**1984** may be a number (``1984``), a text (``\"1984\"``) or event a "
#~ "date. The data type describes the operations, that are allowed for the "
#~ "data, like additions for numbers or concatenation for text (e.g. ``1 + 2 -"
#~ "> 3``, ``\"1\" + \"3\" -> \"13\"``)."
#~ msgstr ""
#~ "Дані можуть представляти різні речі та вимагати різноманітних "
#~ "доступнихоперацій. У програмуванні типи даних є важливою концепцією. "
#~ "Наприклад, **1984** може бути числом (``1984``), текстом (``\"1984\"`` ) "
#~ "або подією чи датою. Тип даних описує можливі операції, дозволені для "
#~ "даних, як-от додавання чисел або конкатенація для тексту (наприклад, ``1 "
#~ "+ 2 -> 3``, ``\"1\" + \"3 \" -> \"13\"``)."

#~ msgid ""
#~ "Python uses dynamic typing. This means as a developer you should not "
#~ "declare a variable with its data type - the interpreter will do this for "
#~ "you. Other popular language using dynamic typing are JavaScript and PHP. "
#~ "Setting variables in Python is as easy as:"
#~ msgstr ""
#~ "Python використовує динамічну типізацію. Це означає, що ви, як розробник, "
#~ "не повинні оголошувати змінну з її типом даних - інтерпретатор зробить це "
#~ "за вас. Іншими популярними мовами, які використовують динамічну "
#~ "типізацію, є JavaScript і PHP. Налаштування змінних у Python доволі "
#~ "просто, як: "

#~ msgid "Built-In Data Types"
#~ msgstr "Вбудовані типи даних"

#~ msgid "Python has the following data types built-in:"
#~ msgstr "Python має такі вбудовані типи даних:"

#~ msgid "Integers (``int``)"
#~ msgstr "Цілі числа (``int``)"

#~ msgid "Floating-point numbers (``float``)"
#~ msgstr "Числа з плаваючою крапкою (``float``)"

#~ msgid "Complex numbers (``complex``)"
#~ msgstr "Комплексні числа (``complex``)"

#~ msgid "Booleans (``bool``)"
#~ msgstr "Логічні значення (``bool``)"

#~ msgid "Strings (``str``)"
#~ msgstr "Рядки (``str``)"

#~ msgid "Bytes (``bytes``)"
#~ msgstr "Байти (``bytes``)"

#~ msgid "Byte arrays (``bytearray``)"
#~ msgstr "Масиви байтів (``bytearray``)"

#~ msgid "Lists (``list``)"
#~ msgstr "Списки (``list``)"

#~ msgid "Tuples (``tuple``)"
#~ msgstr "Кортежі (``tuple``)"

#~ msgid "Sets (``set``)"
#~ msgstr "Cети (``set``)"

#~ msgid "Frozen sets (``frozenset``)"
#~ msgstr "Заморожені сети (``frozenset``)"

#~ msgid "Dictionaries (``dict``)"
#~ msgstr "Словники (``dict``)"

#~ msgid "None (``NoneType``)"
#~ msgstr "Жодного (``NoneType``)"

#~ msgid ""
#~ "Any one can use them without additional imports or packages installations."
#~ msgstr ""
#~ "Будь-хто може використовувати їх без додаткового імпорту чи встановлення "
#~ "пакетів. "

#~ msgid "Text"
#~ msgstr "Текстові дані"

#~ msgid ""
#~ "Text data are stored as strings (``str`` data type) in Python. Any "
#~ "sequence of letters, digits, punctuation marks and whitespace characters "
#~ "enclosed with quotes is considered to be a string literal. Both single "
#~ "quotes (``'``) and double quotes (``\"``) can be used interchangeably to "
#~ "create a string in Python."
#~ msgstr ""
#~ "Текстові дані зберігаються як рядки (тип даних ``str``) у Python. Будь-"
#~ "яка послідовність літер, цифр, знаків пунктуації та пробілів, взята в "
#~ "лапки, вважається рядковим літералом. Обидві одинарні лапки (``'``) або "
#~ "подвійні лапки (``\"``) можна взаємозамінно використовувати для створення "
#~ "рядків."

#~ msgid "Escaping"
#~ msgstr "Екранування"

#~ msgid ""
#~ "In programming this is a process of using a special character to indicate "
#~ "that the following character(s) should be treated differently from their "
#~ "literal meaning. The common usage is to include a special character(s) "
#~ "within strings. A **backslash** character is used to *escape* the "
#~ "following one."
#~ msgstr ""
#~ "У програмуванні це процес використання спеціального символу, щоб вказати, "
#~ "що наступний(і) символ(и) слід розглядати інакше, ніж їхнє буквальне "
#~ "значення. Загальне використання полягає в тому, щоб включити "
#~ "спеціальний(і) символ(и) в рядки. Символ **backslash** використовується "
#~ "для екранування наступного. "

#~ msgid "Example of Escaping in Python"
#~ msgstr "Приклади Екранування в Python"

#~ msgid "Single quotes or double quotes"
#~ msgstr "Одинарні або подвійні лапки"

#~ msgid ""
#~ "Don't care. Use any quote mark you like. A *string* is a sequence of "
#~ "characters after the opening quote and till the closing one. You may use "
#~ "double quotes in case a single quote is a part of the text (e.g. ``\"It's "
#~ "a Serhii's document\"``) and vise versa (e.g. ``'The name of the ship was "
#~ "a \"Billy of Tea\"'``). It's a good practice not to mess single and "
#~ "double quotes within one project. Just keep using a chosen one character "
#~ "for all strings."
#~ msgstr ""
#~ "Неважливо які лапки ви використовуйте. Рядок - це послідовність символів "
#~ "після початкової лапки та до кінцевої. Ви можете використовувати подвійні "
#~ "лапки, якщо одинарна лапка є частиною тексту (наприклад, ``\"Це документ "
#~ "Сергія\"``) і навпаки (наприклад ``'Назва корабля була \"Billy of "
#~ "Tea\"'``). Рекомендується не плутати одинарні та подвійні лапки в одному "
#~ "проекті. Просто продовжуйте використовувати один вибраний символ для всіх "
#~ "рядків. "

#~ msgid "Multiline strings"
#~ msgstr "Багатострічкові рядки"

#~ msgid ""
#~ "You can assign a multiline string by using triple quotes: Both single "
#~ "quote and double quote characters are available."
#~ msgstr ""
#~ "Ви можете призначити багаторядковий рядок, використовуючи потрійні лапки: "
#~ "в середині них доступні як одинарні, так і подвійні лапки. "

#~ msgid ""
#~ "The same syntax is used to create docstring, which are a special case of "
#~ "string usage. We will look on these in the future."
#~ msgstr ""
#~ "Такий самий синтаксис використовується для створення рядка документації, "
#~ "який є окремим випадком використання рядка. Ми розглянемо це в "
#~ "майбутньому. "

#~ msgid "This subsection describes only the most common operations."
#~ msgstr "У цьому розділі описано лише найпоширеніші операції. "

#~ msgid "Concatenation"
#~ msgstr "Конкатинація"

#~ msgid ""
#~ "The ``+`` operator is used to concatenate (join) two or more strings."
#~ msgstr ""
#~ "Оператор ``+`` використовується для конкатенації (об'єднання) двох або "
#~ "більше рядків. "

#~ msgid ""
#~ "On the other hand the ``join`` method concatenates a collection of "
#~ "strings, which may be more efficient than using ``+``."
#~ msgstr ""
#~ "З іншого боку, метод ``join`` об'єднує колекцію рядків, що може бути "
#~ "ефективнішим, ніж використання ``+``. "

#~ msgid "Repetition"
#~ msgstr "Повторення"

#~ msgid ""
#~ "The ``*`` operator is used to repeat a string a specified number of "
#~ "times. Only multipliers of the ``int`` type are allowed."
#~ msgstr ""
#~ "Оператор ``*`` використовується для повторення рядка вказану кількість "
#~ "разів. Дозволені операції лише з множниками типу ``int``. "

#~ msgid "Length"
#~ msgstr "Довжина"

#~ msgid "The ``len`` function is used to find the length of a string."
#~ msgstr "Функція ``len`` використовується для визначення довжини рядка."

#~ msgid "Case conversion"
#~ msgstr "Перетворення регістру"

#~ msgid ""
#~ "The ``lower``, ``upper``, ``capitalize`` and ``title`` methods perform "
#~ "actions on case."
#~ msgstr ""
#~ "Методи ``lower``, ``upper``, ``capitalize`` і ``title`` виконують дії з "
#~ "зміною регістра. "

#~ msgid "``lower`` creates a new string with all lower-case characters."
#~ msgstr "``lower`` створює новий рядок з усіма символами нижнього регістру."

#~ msgid "``upper`` creates a new string with all upper-case characters."
#~ msgstr "``upper`` створює новий рядок з усіма символами верхнього регістру."

#~ msgid ""
#~ "``capitalize`` creates a new string with the upper-case 1st character."
#~ msgstr ""
#~ "``capitalize`` створює новий рядок із першим символом у верхньому "
#~ "регістрі. "

#~ msgid "``title`` will make all characters after whitespace upper case."
#~ msgstr "``title`` зробить усі символи після пробілів верхнім регістром."

#~ msgid "Stripping"
#~ msgstr "Зачистка"

#~ msgid ""
#~ "The ``strip``, ``lstrip`` and ``rstrip`` methods are used to remove "
#~ "leading and/or trailing whitespace characters."
#~ msgstr ""
#~ "Методи ``strip``, ``lstrip`` і ``rstrip`` використовуються для видалення "
#~ "початкових і/або кінцевих пробільних символів. "

#~ msgid "Strings are subscriptable"
#~ msgstr "Рядки можна підписувати"

#~ msgid "``str`` is not the only one subscriptable data type in Python."
#~ msgstr "``str`` - це не єдиний тип даних, який можна підписувати в Python."

#~ msgid ""
#~ "This means you can access individual characters or slices within a string "
#~ "using indexes. A string is a *sequence* of characters and each character "
#~ "within a string has its own position - an *index*. Indexing starts at 0, "
#~ "so the first character in a string is at index 0, the second one is at "
#~ "index 1, and so on. Negative indexing is also possible, with -1 "
#~ "representing the last character in a string, -2 representing the second-"
#~ "to-last character, and so on. Use square brackets (``[]``) to access the "
#~ "index."
#~ msgstr ""
#~ "Це означає, що ви можете отримати доступ до окремих символів або "
#~ "фрагментів у рядку за допомогою індексів. Рядок — це послідовність "
#~ "символів, і кожен символ у рядку має власну позицію — індекс. Індексація "
#~ "починається з 0, отже, перший символ у рядку має індекс 0, другий - "
#~ "індекс 1 і так далі. Також можливе від'ємне індексування, коли -1 "
#~ "представляє останній символ у рядку, а -2 представляє передостанній "
#~ "символ і так далі. Використовуйте квадратні дужки (``[]``), щоб отримати "
#~ "доступ до індексу. "

#~ msgid ""
#~ "You can also *slice* strings, this means to get a subsequence of "
#~ "characters. The slice syntax consists of 3 digits:"
#~ msgstr ""
#~ "Ви також можете *розрізати* рядки, тобто отримати підпослідовність "
#~ "символів. Синтаксис фрагмента складається з 3 цифр: "

#~ msgid ""
#~ "the first one represent the index to start (inclusive), defaults to 0"
#~ msgstr ""
#~ "Перший представляє початковий індекс (включно), за замовчанням дорівнює "
#~ "0. "

#~ msgid ""
#~ "the second one represent the index to stop (non-inclusive), defaults to "
#~ "the length of the sequence"
#~ msgstr ""
#~ "Другий представляє індекс для зупинки (не включно), за замовчуванням "
#~ "довжина послідовності. "

#~ msgid "the third one represents a step, defaults to 1"
#~ msgstr "Третій представляє крок, за замовчуванням 1."

#~ msgid ""
#~ "These numbers are separated within colon (``:``) and enclosed within "
#~ "square brackets. Any slice digit may be omitted."
#~ msgstr ""
#~ "Ці числа розділені двокрапкою (``:``) і взяті в квадратні дужки. Будь-яка "
#~ "цифра зрізу може бути упущена. "

#~ msgid "Sequence slicing"
#~ msgstr "Нарізка послідовності"

#~ msgid "Strings are iterable"
#~ msgstr "Рядки можна повторювати"

#~ msgid ""
#~ "Since strings are arrays, we can loop through the characters in a string "
#~ "with a ``for`` loop:"
#~ msgstr ""
#~ "Оскільки рядки є масивами, ми можемо прокручувати символи в рядку за "
#~ "допомогою циклу ``for``: "

#~ msgid "Strings are immutable"
#~ msgstr "Рядки незмінні"

#~ msgid ""
#~ "This means, you cannot change an individual character within a string."
#~ msgstr "Це означає, що ви не можете змінити окремий символ у рядку."

#~ msgid "Integers"
#~ msgstr "Цілі числа"

#~ msgid ""
#~ "``int``, or integer, is a whole number, positive or negative, without "
#~ "decimals."
#~ msgstr ""
#~ "``int``, тобто ціле число, може бути додатнім або від'ємним, без "
#~ "десяткових знаків. "

#~ msgid "Floats"
#~ msgstr "Числа з плаваючою комою"

#~ msgid ""
#~ "``float``, or floating point number, is a number, positive or negative, "
#~ "containing one or more decimals."
#~ msgstr ""
#~ "``float``, або число з плаваючою комою, - це число, додатне чи від’ємне, "
#~ "що містить один або більше десяткових знаків. "
