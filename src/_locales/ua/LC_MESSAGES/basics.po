# PYTHON/BASICS TRANSLATION
# Copyright (C) 2023, Python training course authors and contributors
# This file is distributed under the same license as the Python Training
# Course package.
# OLEKSANDR YEROMIN <unicorn.in.pants@gmail.com>, 2023.
#
msgid ""
msgstr ""
"Project-Id-Version: Python Training Course 2022.11.dev\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-04-13 18:20+0300\n"
"PO-Revision-Date: 2023-04-13 18:21+0300\n"
"Last-Translator: Serhii Horodilov <sgorodil@gmail.com>\n"
"Language-Team: \n"
"Language: uk\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && "
"n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"Generated-By: Babel 2.12.1\n"
"X-Generator: Poedit 3.2.2\n"

#: ../../src/basics/controlflow.txt:3
msgid "Control Flow"
msgstr "Керування виконанням"

#: ../../src/basics/decorators.txt:6
msgid "Decorators"
msgstr "Декоратори"

#: ../../src/basics/decorators.txt:8
msgid ""
"Decorators provide a simple syntax for calling higher-order functions :cite:"
"`realpython:decorators`."
msgstr ""
"Декоратори забезпечують простий синтаксис для виклику функцій вищого "
"порядку :cite:`realpython:decorators`."

#: ../../src/basics/decorators.txt:13
msgid "There is some kind of misunderstanding in definitions."
msgstr "Є деяке непорозуміння у визначеннях."

#: ../../src/basics/decorators.txt:15
msgid ""
"**Decorator** is a function returning another function, usually applied as a "
"function transformation using the ``@wrapper`` syntax :cite:`docs-python:"
"term-decorator`."
msgstr ""
"**Декоратор** — це функція, яка повертає іншу функцію, зазвичай "
"застосовується як перетворення функції за допомогою синтаксису ``@wrapper`` :"
"cite:`docs-python:term-decorator`."

#: ../../src/basics/decorators.txt:19
msgid ""
"However, that's no quit enough to describe it. The more complete definition "
"is:"
msgstr "Однак цього недостатньо, щоб описати це. Більш повне визначення таке:"

#: ../../src/basics/decorators.txt:22
msgid ""
"**Decorator** is a structural design pattern that lets you attach new "
"behaviors to objects by placing these objects inside special wrapper objects "
"that contain the behaviors :cite:`refactoring.guru:decorator`."
msgstr ""
"**Декоратор** — це структурний шаблон проектування, який дає змогу додавати "
"нову поведінку до об'єктів, розміщуючи ці об'єкти всередині спеціальних "
"об'єктів-огорток, які містять поведінку :cite:`refactoring.guru:decorator`."

#: ../../src/basics/decorators.txt:26
msgid ""
"Before you understand decorators, you must first understand how functions "
"work."
msgstr ""
"Перш ніж зрозуміти декораторів, ви повинні спочатку зрозуміти, як працюють "
"функції."

#: ../../src/basics/decorators.txt:30
msgid "First-class objects"
msgstr "Об'єкти першого класу"

#: ../../src/basics/decorators.txt:32
msgid ""
"In Python functions are `first-class objects`_. Everything in Python is an "
"object. Functions are objects too."
msgstr ""
"У Python функції є `об'єктами першого класу`_. Усе в Python є об'єктом. "
"Функції також є об'єктами."

#: ../../src/basics/decorators.txt:36
msgid "Inner functions"
msgstr "Внутрішні функції"

#: ../../src/basics/decorators.txt:38
msgid ""
"Functions can be nested. This means it is possible to define functions "
"inside other functions."
msgstr ""
"Функції можуть бути вкладеними. Це означає, що можна визначати функції "
"всередині інших функцій."

#: ../../src/basics/decorators.txt:41
msgid "Nested functions example"
msgstr "Приклад вкладених функцій"

#: ../../src/basics/decorators.txt:55
msgid ""
"The order in which inner functions are defined no matters. The function "
"definition does not execute the function body; this gets executed only when "
"the function is called. Furthermore, the inner functions are not defined "
"until the parent function is called. They are locally scoped to their "
"parent. Trying to call ``heapify`` function outside of ``heap_sort`` will "
"cause ``NameError`` exception."
msgstr ""
"Порядок визначення внутрішніх функцій не має значення. Визначення функції не "
"виконує тіло функції; це виконується лише під час виклику функції. Крім "
"того, внутрішні функції не визначені, доки не буде викликана батьківська "
"функція. Вони локально прив'язані до свого батьківського елемента. Спроба "
"викликати функцію ``heapify`` поза межами ``heap_sort`` спричинить виняток "
"``NameError``."

#: ../../src/basics/decorators.txt:63
msgid "Functions are objects"
msgstr "Функції є об'єктами"

#: ../../src/basics/decorators.txt:65
msgid ""
"This means functions can be passed around and used as arguments, just like "
"any other object (e.g. *int*, *str* etc.)."
msgstr ""
"Це означає, що функції можна передавати й використовувати як аргументи, як і "
"будь-який інший об'єкт (наприклад, *int*, *str* тощо)."

#: ../../src/basics/decorators.txt:90
msgid "Returning functions"
msgstr "Повернення функцій"

#: ../../src/basics/decorators.txt:92
msgid ""
"Since function can be passed as an argument, it may be returned from another "
"function."
msgstr ""
"Оскільки функцію можна передати як аргумент, її можна повернути з іншої "
"функції."

#: ../../src/basics/decorators.txt:115
msgid "``parent`` returns functions themselves, there are no parentheses."
msgstr "``parent`` повертає самі функції, тут нема дужок."

#: ../../src/basics/decorators.txt:117
msgid ""
"After running the code snippet above, ``first`` refers the ``first_child`` "
"function from the inner ``parent`` scope. From now it can be used to call "
"the target function it refers."
msgstr ""
"Після виконання наведеного вище фрагмента коду ``first`` посилається на "
"функцію ``first_child`` із внутрішньої області ``parent``. Відтепер його "
"можна використовувати для виклику цільової функції, на яку він посилається."

#: ../../src/basics/decorators.txt:129
msgid "Simple decorators"
msgstr "Прості декоратори"

#: ../../src/basics/decorators.txt:131
msgid ""
"Now you're ready to move on and see the magical beast that is the Python "
"decorators. Let's start with a simple example:"
msgstr ""
"Тепер ви готові рухатися далі та побачити чарівного звіра, яким є декоратори "
"Python. Почнемо з простого прикладу:"

#: ../../src/basics/decorators.txt:149
msgid "Running function:"
msgstr "Запуск функцій:"

#: ../../src/basics/decorators.txt:160
msgid ""
"The common way to use decorators is to replace the original function with a "
"decorated one:"
msgstr ""
"Поширеним способом використання декораторів є заміна оригінальної функції на "
"декоровану:"

#: ../../src/basics/decorators.txt:171
msgid ""
"``say_hello`` function is the reference to the ``decorator.<locals>."
"wrapper``, which itself is bound to the original ``say_hello`` function. "
"There is a syntactic sugar to do this, called *pie-syntax*. The following "
"example does exact the same things as the first decorator example:"
msgstr ""
"Функція ``say_hello`` є посиланням на ``decorator.<locals>.wrapper``, який "
"сам прив'язаний до оригінальної функції ``say_hello``. Для цього існує "
"синтаксичний цукор, який називається *pie-syntax*. Наступний приклад виконує "
"ті самі речі, що й перший приклад декоратора:"

#: ../../src/basics/decorators.txt:193
msgid ""
"There is no way to *undecorate* object in Python. Once something is bound to "
"the decorator's wrapper - it is decorated forever."
msgstr ""
"У Python немає способу *скасувати* об'єкт. Одного разу щось прив'язане до "
"обгортки декоратора - воно прикрашене назавжди."

#: ../../src/basics/decorators.txt:196
msgid ""
"A decorated function still remains a **function**. So, it can be decorated "
"once more time again, and again, and again..."
msgstr ""
"Декорована функція все ще залишається **функцією**. Отже, його можна "
"прикрашати ще раз, і ще, і ще..."

#: ../../src/basics/decorators.txt:248
msgid ""
"\"Wrapper\" is the alternative nickname for the Decorator pattern that "
"clearly expresses the main idea of the pattern. A wrapper is an object that "
"can be linked with some target object. The wrapper contains the same set of "
"methods as the target and delegates to it all requests it receives. However, "
"the wrapper may alter the result by doing something either before or after "
"it passes the request to the target."
msgstr ""
"\"Обгортка\" — альтернативне прізвисько візерунка \"Декоратор\", яке чітко "
"виражає основну ідею візерунка. Обгортка — це об'єкт, який можна зв'язати з "
"деяким цільовим об'єктом. Обгортка містить той самий набір методів, що й "
"мета, і делегує їй усі отримані запити. Однак обгортка може змінити "
"результат, зробивши щось до або після того, як вона передає запит цільовому "
"об'єкту."

#: ../../src/basics/decorators.txt:256
msgid "Passing arguments to the wrapper"
msgstr "Передача аргументів до wrapper"

#: ../../src/basics/decorators.txt:258
msgid ""
"Until now the examples use *simple* decorators. But what if the decorated "
"function gets some arguments? This will cause ``TypeError`` exception that "
"tell that \"arguments are missed\". This can be fixed with just passing "
"arguments to the ``wrapper`` inner function."
msgstr ""
"Досі приклади використовують *прості* декоратори. Але що, якщо декорована "
"функція отримує деякі аргументи? Це спричинить виняток ``TypeError``, який "
"повідомляє, що \"аргументи пропущено\". Це можна виправити, просто передавши "
"аргументи внутрішній функції ``wrapper``."

#: ../../src/basics/decorators.txt:284
msgid ""
"If case you're trying to make a generic decorator, you may pass ``*args`` "
"and ``**kwargs`` instead of exact arguments:"
msgstr ""
"Якщо ви намагаєтеся створити загальний декоратор, ви можете передати "
"``*args`` і ``**kwargs`` замість точних аргументів:"

#: ../../src/basics/decorators.txt:303
msgid "Passing arguments to decorator"
msgstr "Передача аргументів декоратору"

#: ../../src/basics/decorators.txt:305
msgid ""
"At last it's time to know how to pass arguments to the decorator. Here is a "
"simple implementation of ``defer`` decorator which deferred the function "
"execution for some time:"
msgstr ""
"Нарешті настав час знати, як передавати аргументи декоратору. Ось проста "
"реалізація декоратора ``defer``, яка відкладає виконання функції на деякий "
"час:"

#: ../../src/basics/decorators.txt:348
msgid "Class decorators"
msgstr "Декоратори класів"

#: ../../src/basics/decorators.txt:350
msgid ""
"There are some pre-defined decorators exists for usage together with "
"classes. They are:"
msgstr ""
"Існують деякі попередньо визначені декоратори для використання разом із "
"класами. Це:"

#: ../../src/basics/decorators.txt:353
msgid "``classmethod``"
msgstr "``classmethod``"

#: ../../src/basics/decorators.txt:354
msgid "``staticmethod``"
msgstr "``staticmethod``"

#: ../../src/basics/decorators.txt:355
msgid "``property``"
msgstr "``property``"

#: ../../src/basics/decorators.txt:357
msgid ""
"If you develop an intuitive understanding for their differences you'll be "
"able to write object-oriented Python that communicates its intent more "
"clearly and will be easier to maintain in the long run :cite:`realpython:"
"methods-demystified`."
msgstr ""
"Якщо ви розвинете інтуїтивне розуміння їхніх відмінностей, ви зможете "
"написати об'єктно-орієнтований Python, який чіткіше передає свої наміри та "
"який буде легше підтримувати в довгостроковій перспективі :cite:`realpython:"
"methods-demystified`."

#: ../../src/basics/decorators.txt:363
msgid "Class methods"
msgstr "Методи класу"

#: ../../src/basics/decorators.txt:365
msgid ""
"Instead of accepting a ``self`` parameter, class methods take a ``cls`` "
"parameter that points to the class — and not the object instance — when the "
"method is called."
msgstr ""
"Замість того, щоб приймати параметр self, під час виклику методу методи "
"класу приймають параметр ``cls``, який вказує на клас, а не на екземпляр "
"класу."

#: ../../src/basics/decorators.txt:369
msgid ""
"Because the class method only has access to this ``cls`` argument, it can't "
"modify object instance state. That would require access to ``self``. "
"However, class methods can still modify class state that applies across all "
"instances of the class."
msgstr ""
"Оскільки метод класу має доступ лише до цього аргументу ``cls``, він не може "
"змінити стан екземпляра об'єкта. Це потребує доступу до ``self``. Однак "
"методи класу все ще можуть змінювати стан класу, який застосовується до всіх "
"екземплярів класу."

#: ../../src/basics/decorators.txt:374
msgid ""
"The common usage for ``classmethod`` is provide alternative initializers."
msgstr ""
"Загальним використанням ``методи класу`` є надання альтернативних "
"ініціалізаторів."

#: ../../src/basics/decorators.txt:377
msgid "Static methods"
msgstr "Статичні методи"

#: ../../src/basics/decorators.txt:379
msgid ""
"This type of method takes neither a ``self`` nor a ``cls`` parameter (but of "
"course it's free to accept an arbitrary number of other parameters)."
msgstr ""
"Цей тип методу не приймає ані ``self``, ані ``cls`` параметр (але, звичайно, "
"він може приймати будь-яку кількість інших параметрів)."

#: ../../src/basics/decorators.txt:382
msgid ""
"Therefore a static method can neither modify object state nor class state. "
"Static methods are restricted in what data they can access - and they're "
"primarily a way to namespace your methods."
msgstr ""
"Тому статичний метод не може змінити ні стан об'єкта, ні стан класу. "
"Статичні методи обмежені в тому, до яких даних вони можуть отримати доступ, "
"і вони, перш за все, є способом простору імен ваших методів."

#: ../../src/basics/decorators.txt:386
msgid ""
"It's tricky to explain ``staticmethod`` usage. Almost always you can create "
"a dedicated function instead of static method. But sometimes you need to "
"bind some logic independent from class itself or its instances to a class - "
"it common to encapsulate it with ``staticmethod``."
msgstr ""
"Важко пояснити використання ``staticmethod``. Майже завжди ви можете "
"створити спеціальну функцію замість статичного методу. Але іноді вам "
"потрібно прив'язати до класу певну логіку, незалежну від самого класу або "
"його екземплярів – зазвичай інкапсулювати її за допомогою ``staticmethod``."

#: ../../src/basics/decorators.txt:392
msgid "Properties"
msgstr "Властивості"

#: ../../src/basics/decorators.txt:394
msgid ""
"It's a way to bind a method name to access it as an attribute. Properties "
"are **read-only** by default. This means a value cannot be assigned to "
"``property member``."
msgstr ""
"Це спосіб прив'язати назву методу для доступу до нього як до атрибута. За "
"замовчуванням властивості доступні **лише для читання**. Це означає, що "
"значення не можна призначити ``члену властивості``."

#: ../../src/basics/decorators.txt:399
msgid "Some examples"
msgstr "Деякі приклади"

#: ../../src/basics/exceptions.txt:6
msgid "Errors and Exceptions"
msgstr "Помилки та винятки"

#: ../../src/basics/exceptions.txt:8
msgid ""
"There are (at least) two distinguishable kinds of errors: *syntax errors* "
"and *exceptions* :cite:`docs-python:errors`."
msgstr ""
"Існує (принаймні) два типи помилок: *синтаксичні помилки* та *виключення* :"
"cite:`docs-python:errors`."

#: ../../src/basics/exceptions.txt:12
msgid "Syntax errors"
msgstr "Синтаксичні помилки"

#: ../../src/basics/exceptions.txt:14
msgid "Syntax errors are also known as parsing errors."
msgstr "Синтаксичні помилки також відомі як помилки Python парсера."

#: ../../src/basics/exceptions.txt:24
msgid ""
"The parser repeats the offending line and displays a little \"arrow\" "
"pointing at the earliest point in the line where the error was detected. The "
"error is caused by (or at least detected at) the token preceding the arrow."
msgstr ""
"Синтаксичний аналізатор повторює неправильний рядок і відображає маленьку "
"\"стрілку\", яка вказує на найперший символ рядка, де було виявлено помилку. "
"Помилка спричинена (або принаймні виявлена) символом(а) перед стрілкою."

#: ../../src/basics/exceptions.txt:29
msgid "Exceptions"
msgstr "Винятки"

#: ../../src/basics/exceptions.txt:31
msgid ""
"Even if a statement or expression is syntactically correct, it may cause an "
"error when an attempt is made to execute it. Errors detected during "
"execution are called exceptions and are not unconditionally fatal: you will "
"soon learn how to handle them in Python programs."
msgstr ""
"Навіть якщо оператор або вираз синтаксично правильний, це може спричинити "
"помилку під час спроби його виконання. Помилки, виявлені під час виконання, "
"називаються винятками і не є фатальними: незабаром ви дізнаєтеся, як їх "
"обробляти в програмах на Python."

#: ../../src/basics/exceptions.txt:36
msgid ""
"Exceptions come in different types, and the type is printed as part of the "
"message."
msgstr ""
"Винятки бувають різних типів, і тип друкується як частина повідомлення."

#: ../../src/basics/exceptions.txt:39
msgid "For example, the ``div`` function implemented as"
msgstr "Наприклад, функція ``div``, реалізована як"

#: ../../src/basics/exceptions.txt:48
msgid ""
"may cause a ``ZeroDivisionError`` exception in case 0 is passed as ``y`` "
"parameter."
msgstr ""
"може викликати виняток ``ZeroDivisionError``, якщо 0 передається як параметр "
"``y``."

#: ../../src/basics/exceptions.txt:51
msgid ""
"Standard exception names are built-in identifiers (not reserved keywords)."
msgstr ""
"Стандартні назви винятків є вбудованими ідентифікаторами (а не "
"зарезервованими ключовими словами)."

#: ../../src/basics/exceptions.txt:53
msgid "The list of `built-in exceptions`_"
msgstr "Список `вбудованих винятків`_"

#: ../../src/basics/exceptions.txt:56
msgid "Tracebacks"
msgstr "Відстеження"

#: ../../src/basics/exceptions.txt:58
msgid "\"File\" is replaced with a *dummy string* within the examples."
msgstr "У наведених прикладах \"Файл\" замінено на *фіктивний рядок*."

#: ../../src/basics/exceptions.txt:60
msgid "Let's assume the following modules structure:"
msgstr "Припустимо наступну структуру модулів:"

#: ../../src/basics/exceptions.txt:68
msgid ""
"The **main** module imports a ``div`` function implemented above from the "
"**func** module. The code in main is implemented as follows:"
msgstr ""
"Модуль **main** імпортує функцію ``div``, реалізовану вище, з модуля "
"**func**. Основний код реалізовано наступним чином:"

#: ../../src/basics/exceptions.txt:80
msgid ""
"While running the code with correct inputs it will work fine. But there are "
"at two exceptions for this script."
msgstr ""
"Під час виконання коду з правильними введеннями він працюватиме нормально. "
"Але для цього сценарію є два винятки."

#: ../../src/basics/exceptions.txt:83
msgid ""
"The first one is related on type conversion. While running the main script "
"there is case of invalid input."
msgstr ""
"Перший пов'язаний з перетворенням типів. Під час виконання основного "
"сценарію є випадок неправильного введення."

#: ../../src/basics/exceptions.txt:95
msgid ""
"Note the **traceback** indicates the module and the exact line of code that "
"causes the exception."
msgstr ""
"Зауважте, що **traceback** вказує на модуль і точний рядок коду, який "
"викликає виняток."

#: ../../src/basics/exceptions.txt:98
msgid ""
"The second one exception occurs when a 0 is passed as the second parameter "
"to ``div`` function. The traceback would look like:"
msgstr ""
"Другий виняток виникає, коли 0 передається як другий параметр функції "
"``div``. Трасування виглядатиме так:"

#: ../../src/basics/exceptions.txt:112
msgid ""
"The traceback indicates all calls (top to bottom) that cause an exception."
msgstr ""
"Зворотне відстеження вказує на всі виклики (зверху вниз), які викликають "
"виняток."

#: ../../src/basics/exceptions.txt:115 ../../src/basics/syntax.txt
msgid "Exception handling"
msgstr "Обробка винятків"

#: ../../src/basics/exceptions.txt:117
msgid ""
"It is possible to write programs that handle selected exceptions. The "
"``try`` statement is used to do that."
msgstr ""
"Можна писати програми, які оброблятимуть вибрані винятки. Для цього "
"використовується інструкція ``try``."

#: ../../src/basics/exceptions.txt:120
msgid "The try statement works as follows."
msgstr "Інструкція try працює наступним чином."

#: ../../src/basics/exceptions.txt:122
msgid ""
"First, the try clause (the statement(s) between the try and except keywords) "
"is executed."
msgstr ""
"Спочатку виконується речення try (вираз(и) між ключовими словами try і "
"except)."

#: ../../src/basics/exceptions.txt:124
msgid ""
"If no exception occurs, the except clause is skipped and execution of the "
"try statement is finished."
msgstr ""
"Якщо винятків не відбувається, пропозиція винятку пропускається, і виконання "
"оператора try завершується."

#: ../../src/basics/exceptions.txt:126
msgid ""
"If an exception occurs during execution of the try clause, the rest of the "
"clause is skipped. Then, if its type matches the exception named after the "
"except keyword, the except clause is executed, and then execution continues "
"after the try/except block."
msgstr ""
"Якщо під час виконання try виникає виняток, решта пропозиції пропускається. "
"Потім, якщо його тип збігається з винятком, названим за ключовим словом "
"osim, виконується пропозиція, а потім виконання продовжується після блоку "
"try/except."

#: ../../src/basics/exceptions.txt:130
msgid ""
"If an exception occurs which does not match the exception named in the "
"except clause, it is passed on to outer try statements; if no handler is "
"found, it is an unhandled exception and execution stops with a message as "
"shown above."
msgstr ""
"Якщо виникає виняток, який не збігається з винятком, названим у реченні "
"винятку, він передається зовнішнім операторам try; якщо обробник не "
"знайдено, це необроблена виняткова ситуація, і виконання зупиняється з "
"повідомленням, як показано вище."

#: ../../src/basics/exceptions.txt:147
msgid ""
"A try statement may have more than one except clause, to specify handlers "
"for different exceptions."
msgstr ""
"Інструкція try може мати більше однієї пропозиції, щоб вказати обробники для "
"різних винятків."

#: ../../src/basics/exceptions.txt:177
msgid "Handling ALL exception"
msgstr "Опрацювання усіх винятків"

#: ../../src/basics/exceptions.txt:179
msgid "It's a bad practice to handle **all** exceptions."
msgstr "Обробляти **всі** винятки – це погана практика."

#: ../../src/basics/exceptions.txt:181
msgid ""
"When indicating an ``except`` block without specifying an exception to catch "
"it will work for any exception, that occurs in ``try`` block. The same is "
"relevant for handling ``BaseException`` and ``Exception``. But you can never "
"say what exact goes wrong."
msgstr ""
"Якщо вказати блок ``except`` без визначення винятку для перехоплення, він "
"працюватиме для будь-якого винятку, який виникає в блоці ``try``. Те саме "
"стосується обробки ``BaseException`` і ``Exception``. Проте ніколи не "
"можливо сказати, який саме виняток стався."

#: ../../src/basics/exceptions.txt:186
msgid ""
"However, this scenario may work for logging an exception and raising it "
"again to be handled on upper levels."
msgstr ""
"Проте, такий сценарій може працювати для логування винятків, після чого вони "
"підійматься заново, щоб бути опрацьованими на вищих рівнях програми."

#: ../../src/basics/exceptions.txt:208
msgid ""
"All exceptions are inherited from ``Exception`` class, which is subclass of "
"``BaseException``. So, you can never know what exactly goes wrong with your "
"code."
msgstr ""
"Усі винятки успадковуються від класу ``Exception``, який є підкласом "
"``BaseException``. Отже, ви ніколи не можете знати, що саме пішло не так із "
"вашим кодом."

#: ../../src/basics/exceptions.txt:213
msgid "``finally`` statement"
msgstr "Вираз ``finally``"

#: ../../src/basics/exceptions.txt:215
msgid ""
"The ``try`` statement cannot be used itself. This will cause "
"``SyntaxError``. Either ``except`` or ``finally`` block is required to be "
"included."
msgstr ""
"Оператор ``try`` не може бути використаний сам по собі. Це спричинить "
"``SyntaxError``. Необхідно включити блок ``except`` або ``finally``."

#: ../../src/basics/exceptions.txt:218
msgid ""
"While the ``except`` block tries to catch the exceptions if any, the "
"``finally`` block will be always executed regardless of the exception occurs."
msgstr ""
"У той час як блок ``except`` намагається перехопити винятки, якщо такі є, "
"блок ``finally`` завжди виконуватиметься незалежно від виникнення винятку."

#: ../../src/basics/exceptions.txt:244
msgid "``else`` statement"
msgstr "Вираз ``else``"

#: ../../src/basics/exceptions.txt:246
msgid ""
"The ``try`` statement can also use ``else`` (which is optional). The "
"statements within this block will be execute only in case there were no "
"exceptions raised while running the ``try``."
msgstr ""
"Оператор ``try`` також може використовувати ``else`` (який є "
"необов'язковим). Інструкції в цьому блоці виконуватимуться лише у випадку, "
"якщо під час виконання ``try`` не було викликано винятків."

#: ../../src/basics/exceptions.txt:268
msgid "Raising exceptions"
msgstr "Винятки: raising"

#: ../../src/basics/exceptions.txt:270
msgid ""
"The ``raise`` statement allows the programmer to force a specified exception "
"to occur. The sole argument to raise indicates the exception to be raised. "
"This must be either an exception instance or an exception class (a class "
"that derives from ``BaseException``, such as ``Exception`` or one of its "
"subclasses). If an exception class is passed, it will be implicitly "
"instantiated by calling its constructor with no arguments."
msgstr ""
"Інструкція ``raise`` дозволяє програмісту примусово викликати певний "
"виняток. Єдиний аргумент, який потрібно викликати, вказує на виняток, який "
"потрібно викликати. Це має бути екземпляр винятку або клас винятку (клас, "
"який походить від ``BaseException``, наприклад ``Exception`` або один із "
"його підкласів). Якщо передано клас винятків, він буде неявно створений "
"шляхом виклику його конструктора без аргументів."

#: ../../src/basics/exceptions.txt:282
msgid ""
"``raise`` statement itself will re-raise all the exceptions within the "
"context. Also exceptions can be raised again from the ``except`` block. It's "
"a common pattern to catch the exception for loggers and when re-raise it."
msgstr ""
"Сам оператор ``raise`` повторно викличе всі винятки в контексті опрацювання. "
"Крім того, винятки можуть бути викликані знову з блоку ``except``. Це "
"загальний шаблон для перехоплення винятку для реєстрації повідомлення про "
"виняткову ситуацію і повторного його підняття."

#: ../../src/basics/exceptions.txt:295
msgid "Creating custom exceptions"
msgstr "Створення винятків"

#: ../../src/basics/exceptions.txt:297
msgid ""
"Programs may name their own exceptions by creating a new exception class. "
"Exceptions should typically be derived from the Exception class, either "
"directly or indirectly."
msgstr ""
"Програми можуть називати власні винятки, створюючи новий клас винятків. "
"Винятки зазвичай мають бути похідними від класу Exception, прямо чи "
"опосередковано."

#: ../../src/basics/exceptions.txt:301
msgid ""
"Exception classes can be defined which do anything any other class can do, "
"but are usually kept simple, often only offering a number of attributes that "
"allow information about the error to be extracted by handlers for the "
"exception."
msgstr ""
"Можна визначити класи винятків, які роблять усе, що може зробити будь-який "
"інший клас, але зазвичай вони прості, часто пропонують лише ряд атрибутів, "
"які дозволяють обробникам витягувати інформацію про помилку для винятку."

#: ../../src/basics/exceptions.txt:306
msgid ""
"Most exceptions are defined with names that end in \"Error\", similar to the "
"naming of the standard exceptions."
msgstr ""
"Більшість винятків визначено з іменами, які закінчуються на \"Error\", "
"подібно до назв стандартних винятків."

#: ../../src/basics/exceptions.txt:309
msgid ""
"Many standard modules define their own exceptions to report errors that may "
"occur in functions they define."
msgstr ""
"Багато стандартних модулів визначають власні винятки, щоб повідомляти про "
"помилки, які можуть виникнути у функціях, які вони визначають."

#: ../../src/basics/exceptions.txt:312
msgid "User-defined exception"
msgstr "Виняток, визначений користувачем"

#: ../../src/basics/functions.txt:3 ../../src/basics/syntax.txt
msgid "Functions"
msgstr "Функції"

#: ../../src/basics/index.txt:3
msgid "Python Basics"
msgstr "Основи Python"

#: ../../src/basics/modules.txt:3
msgid "Pythons Modules and Imports"
msgstr "Модулі та імпорт Pythons"

#: ../../src/basics/pep8.txt:3
msgid "Style Guides: PEP8"
msgstr "Керівництво по стилю: PEP8"

#: ../../src/basics/stdtypes.txt:3
msgid "Built-in Types"
msgstr "Вбудовані типи"

#: ../../src/basics/stdtypes.txt:5
msgid ""
"The principal built-in types are numerics, sequences, mappings, classes, "
"instances and exceptions :cite:`docs-python:stdtypes`. This section covers "
"only the most base of them. Others will be discussed in the future within "
"their own topics."
msgstr ""
"Основними вбудованими типами є числа, послідовності, відображення, класи, "
"екземпляри та винятки :cite:`docs-python:stdtypes`. Цей розділ охоплює лише "
"найпростіші з них. Інші будуть обговорюватися в майбутньому в рамках їхніх "
"власних тем."

#: ../../src/basics/stdtypes.txt:11
msgid "Numeric types"
msgstr "Числові типи"

#: ../../src/basics/stdtypes.txt:13
msgid ""
"There are 3 distinct numeric types: *integers*, *floating point numbers*, "
"and *complex numbers*. In addition, Booleans are a subtype of integers. "
"Integers have unlimited precision. Floating point numbers are usually "
"implemented using ``double`` in C. Complex numbers have a real and imaginary "
"part, which are each a floating point number."
msgstr ""
"Існує 3 різних типи чисел: *integers*, *floating point numbers*, та *complex "
"numbers*. Крім того, логічні значення є підтипом цілих чисел. Цілі числа "
"мають необмежену точність. Числа з плаваючою комою зазвичай реалізуються "
"через знак ``double`` у C. Комплексні числа мають дійсну та уявну частини, "
"кожна з яких є числом з плаваючою комою."

#: ../../src/basics/stdtypes.txt:19
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators. Unadorned integer literals (including hex, octal "
"and binary numbers) yield integers. Numeric literals containing a decimal "
"point or an exponent sign yield floating point numbers. Appending ``j`` or "
"``J`` to a numeric literal yields an imaginary number (a complex number with "
"a zero real part) which you can add to an integer or float to get a complex "
"number with real and imaginary parts."
msgstr ""
"Числа створюються за допомогою числових літералів або як результат "
"вбудованих функцій і операторів. Неприкрашені цілі літерали (включаючи "
"шістнадцяткові, вісімкові та двійкові числа) дають цілі числа. Числові "
"літерали, що містять десяткову кому або знак експоненти, дають числа з "
"плаваючою комою. Додавання ``j`` або ``J`` до числового літералу дає уявне "
"число (комплексне число з нульовою дійсною частиною), яке ви можете додати "
"до цілого числа або числа з плаваючою точкою, щоб отримати комплексне число "
"з дійсною та уявною частинами."

#: ../../src/basics/stdtypes.txt:28
msgid "Supported operations"
msgstr "Операції підтримки"

#: ../../src/basics/stdtypes.txt:31 ../../src/basics/stdtypes.txt:149
#: ../../src/basics/stdtypes.txt:199
msgid "Operation"
msgstr "Операції"

#: ../../src/basics/stdtypes.txt:31 ../../src/basics/stdtypes.txt:149
#: ../../src/basics/stdtypes.txt:199
msgid "Result"
msgstr "Результат"

#: ../../src/basics/stdtypes.txt:33
msgid "``x + y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:33
msgid "sum of *x* and *y*"
msgstr "сума *x* і *y*"

#: ../../src/basics/stdtypes.txt:35
msgid "``x - y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:35
msgid "difference of *x* and *y*"
msgstr "різниця між *x* і *y*"

#: ../../src/basics/stdtypes.txt:37
msgid "``x * y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:37
msgid "product of *x* and *y*"
msgstr "добуток *x* і *y*"

#: ../../src/basics/stdtypes.txt:39
msgid "``x / y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:39
msgid "quotient of *x* and *y*"
msgstr "частка *x* і *y*"

#: ../../src/basics/stdtypes.txt:41
msgid "``x // y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:41
msgid "floored quotient of *x* and *y*"
msgstr "цілочисельне ділення *x* і *y*"

#: ../../src/basics/stdtypes.txt:43
msgid "``x % y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:43
msgid "remainder of ``x / y``"
msgstr "залишок від ділення``x / y``"

#: ../../src/basics/stdtypes.txt:45
msgid "``-x``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:45
msgid "*x* negated"
msgstr "*x* від'ємне"

#: ../../src/basics/stdtypes.txt:47
msgid "``+x``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:47
msgid "*y* unchanged"
msgstr "*y* без змін"

#: ../../src/basics/stdtypes.txt:49
msgid "``abs(x)``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:49
msgid "absolute value or magnitude of *x*"
msgstr "абсолютне значення або величина *x*"

#: ../../src/basics/stdtypes.txt:51
msgid "``int(x)``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:51
msgid "*x* converted to integer"
msgstr "*x* перетворено на ціле число"

#: ../../src/basics/stdtypes.txt:53
msgid "``float(x)``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:53
msgid "*x* converted to floating point"
msgstr "*x* перетворено на число з плаваючою комою"

#: ../../src/basics/stdtypes.txt:55
msgid "``complex(re, im)``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:55
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"комплексне число з дійсною частиною *re*, уявною частиною *im*. *im* за "
"замовчуванням на нуль."

#: ../../src/basics/stdtypes.txt:58
msgid "``divmod(x, y)``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:58
msgid "the pair ``(x // y, x % y)``"
msgstr "об'єднує ``(x // y, x % y)``"

#: ../../src/basics/stdtypes.txt:60
msgid "``pow(x, y)`` ``x ** y``"
msgstr "``x + y``"

#: ../../src/basics/stdtypes.txt:60
msgid "*x* to the power *y*"
msgstr "*x* у степені *y*"

#: ../../src/basics/stdtypes.txt:64
msgid ""
"``x // y`` also referred to as integer division. The resultant value is a "
"whole integer, through the result's type is not necessarily int. The result "
"is always rounded towards minus infinity: ``1 // 2`` is ``0``"
msgstr ""
"``x // y`` також називають цілим діленням. Результуюче значення є цілим "
"числом, через тип результату не обов'язково int. Результат завжди "
"округлюється до мінус нескінченності: ``1 // 2`` дорівнює ``0``"

#: ../../src/basics/stdtypes.txt:69
msgid ""
"``float(x)`` also accepts the strings ``\"nan\"`` and ``\"inf\"`` with an "
"optional prefix \"+\" or \"-\" for :abbr:Nan(Not a Number) and positive and "
"negative infinity."
msgstr ""
"``float(x)`` також приймає рядки ``\"nan\"`` та ``\"inf\"`` з необов'язковим "
"префіксом \"+\" або \"-\" для: abbr:Nan(не число) і позитивна і негативна "
"нескінченність."

#: ../../src/basics/stdtypes.txt:74
msgid "Code examples"
msgstr "Приклади коду"

#: ../../src/basics/stdtypes.txt:76
msgid "Integer numbers"
msgstr "Цілі числа"

#: ../../src/basics/stdtypes.txt:89
msgid "Floating point numbers"
msgstr "Числа з плаваючою комою"

#: ../../src/basics/stdtypes.txt:104 ../../src/basics/stdtypes.txt:177
#: ../../src/basics/stdtypes.txt:285 ../../src/basics/stdtypes.txt:294
#: ../../src/basics/stdtypes.txt:323
msgid "Value comparisons"
msgstr "Порівняння цінностей"

#: ../../src/basics/stdtypes.txt:106
msgid ""
"Numbers of built-in numeric types can be compared within and across their "
"types (with the restriction that complex numbers do not support order "
"comparison). Within the limits of the types involved, they compare "
"mathematically correct without loss of precision."
msgstr ""
"Числа вбудованих числових типів можна порівнювати всередині та між типами (з "
"обмеженням, що комплексні числа не підтримують порядок порівняння). У межах "
"залучених типів вони порівняються математично правильно без втрати точності."

#: ../../src/basics/stdtypes.txt:111
msgid ""
"The \"not-a-number\" values ``float(\"NaN\")`` and ``decimal."
"Decimal('NaN')`` are special. Any ordered comparison of a number to a not-a-"
"number value is false."
msgstr ""
"Значення \"not-a-number\" ``float(\"NaN\")`` і ``decimal.Decimal('NaN')`` є "
"спеціальними. Будь-яке впорядковане порівняння числа з нечисловим значенням "
"є хибним."

#: ../../src/basics/stdtypes.txt:115
msgid "Sequence types"
msgstr "Типи послідовностей"

#: ../../src/basics/stdtypes.txt:117
msgid ""
"There are 3 basic sequence types: *lists*, *tuples*, and *range objects*. "
"Additional sequence types tailored for processing of binary data and text "
"strings are described in dedicated sections."
msgstr ""
"Існує 3 основних типи послідовностей: списки, кортежі та об'єкти діапазону. "
"Додаткові типи послідовностей, призначені для обробки двійкових даних і "
"текстових рядків, описані у інших розділах."

#: ../../src/basics/stdtypes.txt:122
msgid "Lists"
msgstr "Списки"

#: ../../src/basics/stdtypes.txt:124
msgid ""
"Lists are mutable sequences, typically used to store collections of items. "
"They may be constructed in several ways:"
msgstr ""
"Списки - це змінні послідовності, які зазвичай використовуються для "
"зберігання колекцій елементів. Вони можуть бути побудовані кількома "
"способами:"

#: ../../src/basics/stdtypes.txt:127
msgid "using a pair of square brackets to denote the empty list: ``[]``"
msgstr ""
"використовуючи пару квадратних дужок для cтворення порожнього списку: ``[]``"

#: ../../src/basics/stdtypes.txt:128
msgid ""
"using square brackets, separating items with commas: ``[a]``, ``[a, b, c]``"
msgstr ""
"використовуючи квадратні дужки, розділяючи елементи комами: ``[a]``, ``[a, "
"b, c]``"

#: ../../src/basics/stdtypes.txt:129
msgid "using a list comprehension: ``[x for x in iterable]``"
msgstr "використовуючи генератори списків: ``[x for x in iterable]``"

#: ../../src/basics/stdtypes.txt:130
msgid "using the type constructor: ``list()`` or ``list(iterable)``"
msgstr "використовуючи конструкції типу: ``list()`` або ``list(iterable)``"

#: ../../src/basics/stdtypes.txt:133
msgid "Tuples"
msgstr "Кортежі"

#: ../../src/basics/stdtypes.txt:135
msgid ""
"Tuples are immutable sequences, typically used to store collections of data "
"or for cases where an immutable sequence of data is needed (such as allowing "
"storage in a ``set`` or ``dict`` instances). They may be constructed in a "
"number of ways:"
msgstr ""
"Кортежі - це незмінні послідовності, які зазвичай використовуються для "
"зберігання колекцій даних або для випадків, коли потрібна незмінна "
"послідовність даних (наприклад, дозволяє зберігати в екземплярах ``set`` або "
"``dict``). Вони можуть бути конструйовані декількома способами:"

#: ../../src/basics/stdtypes.txt:140
msgid "using a pair of parentheses to denote the empty tuple: ``()``"
msgstr ""
"використовуючи пару круглих дужок для позначення порожнього кортежу: ``()``"

#: ../../src/basics/stdtypes.txt:141
msgid "using a trailing comma for a singleton tuple: ``a,`` or ``(a, b, c)``"
msgstr ""
"використовуючи кінцеву кому для одноэлементного кортежу: ``a,`` або ``(a, b, "
"c)``"

#: ../../src/basics/stdtypes.txt:142
msgid "separating items with commas: ``a, b, c`` or ``(a, b, c)``"
msgstr "відокремлюючи елементи комами: ``a, b, c`` або ``(a, b, c)``"

#: ../../src/basics/stdtypes.txt:143
msgid "using the type constructor: ``tuple()`` or ``tuple(iterable)``"
msgstr "за допомогою конструктора типу: ``tuple()`` або ``tuple(iterable)``"

#: ../../src/basics/stdtypes.txt:146
msgid "Common operations"
msgstr "Загальні операції"

#: ../../src/basics/stdtypes.txt:151
msgid "``x in s`` ``x not in s``"
msgstr "``x in s`` ``x not in s``"

#: ../../src/basics/stdtypes.txt:151
msgid ""
"``True`` if an item of *s* equal to *x* ``False`` if an item of *s* equal to "
"*x*"
msgstr ""
"``True``, якщо елемент *s* дорівнює *x* ``False``, якщо елемент *s* дорівнює "
"*x*"

#: ../../src/basics/stdtypes.txt:154
msgid "``s + t``"
msgstr "``s + t``"

#: ../../src/basics/stdtypes.txt:154
msgid "the concatenation of *s* and *t*"
msgstr "конкатенація s і t"

#: ../../src/basics/stdtypes.txt:156
msgid "``s * n``"
msgstr "``s * n``"

#: ../../src/basics/stdtypes.txt:156
msgid "equivalent to adding *s* to itself *n* times"
msgstr "еквівалентно додаванню *s* до себе *n* разів"

#: ../../src/basics/stdtypes.txt:158
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../src/basics/stdtypes.txt:158
msgid "*i*-th item of *s*, origin 0"
msgstr "*i*-й елемент *s*, джерело 0"

#: ../../src/basics/stdtypes.txt:160
msgid "``s[i:j]`` ``s[i:j:k]``"
msgstr "``s[i:j]`` ``s[i:j:k]``"

#: ../../src/basics/stdtypes.txt:160
msgid ""
"slice of *s* from *i* to *j* with step *k*. any of these (or even all 3) may "
"be omitted."
msgstr ""
"фрагмент *s* від *i* до *j* з кроком *k*. будь-який із цих (або навіть усі "
"3) можна опустити."

#: ../../src/basics/stdtypes.txt:163
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../src/basics/stdtypes.txt:163
msgid "length of *s*"
msgstr "довжина *s*"

#: ../../src/basics/stdtypes.txt:165
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../src/basics/stdtypes.txt:165
msgid "smallest item of *s*"
msgstr "найменший елемент *s*"

#: ../../src/basics/stdtypes.txt:167
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../src/basics/stdtypes.txt:167
msgid "largest item of *s*"
msgstr "найбільший елемент *s*"

#: ../../src/basics/stdtypes.txt:169
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../src/basics/stdtypes.txt:169
msgid "total number of occurrences of *x* in *s*"
msgstr "загальна кількість входжень *x* у *s*"

#: ../../src/basics/stdtypes.txt:171
msgid "``s.index(x)`` ``s.index(x, i)`` ``s.index(x, i, j)``"
msgstr "``s.index(x)`` ``s.index(x, i)`` ``s.index(x, i, j)``"

#: ../../src/basics/stdtypes.txt:171
msgid ""
"index of the first occurrence of *x* in *s* at or after index *i* and before "
"index *j*"
msgstr ""
"індекс першого входження *x* у *s* на або після індексу *i* та перед "
"індексом *j*"

#: ../../src/basics/stdtypes.txt:179
msgid ""
"Sequences can be compared only within each of their types, with the "
"restriction that ranges do not support order comparison. Equality comparison "
"across these types results in inequality, and ordering comparison across "
"these types raises ``TypeError``."
msgstr ""
"Послідовності можна порівнювати лише в межах кожного типу, з обмеженням, що "
"діапазони не підтримують порівняння порядку. Порівняння рівності між цими "
"типами призводить до нерівності, а впорядковане порівняння цих типів "
"викликає ``TypeError``."

#: ../../src/basics/stdtypes.txt:184
msgid ""
"Sequences compare lexicographically using comparison of corresponding "
"elements. The built-in containers typically assume identical objects are "
"equal to themselves. Lexicographical comparison between built-in collections "
"works as follows:"
msgstr ""
"Послідовності порівнюють лексикографічно за допомогою порівняння відповідних "
"елементів. Вбудовані контейнери зазвичай припускають, що ідентичні об'єкти "
"рівні собі. Лексикографічне порівняння між вбудованими колекціями працює "
"таким чином:"

#: ../../src/basics/stdtypes.txt:189
msgid ""
"For two collections to compare equal, they must be of the same type, have "
"the same length, and each pair of corresponding elements must compare equal."
msgstr ""
"Щоб дві колекції порівнювалися рівноправними, вони повинні бути одного типу, "
"мати однакову довжину, і кожна пара відповідних елементів повинна "
"порівнюватися."

#: ../../src/basics/stdtypes.txt:191
msgid ""
"Collections that supports order comparison are ordered the same as their "
"first unequal elements. If corresponding element does not exist, the shorter "
"collection is ordered first."
msgstr ""
"Колекції, які підтримують порівняння порядку, упорядковуються так само, як і "
"їхні перші нерівні елементи. Якщо відповідний елемент не існує, спочатку "
"впорядковується коротша колекція."

#: ../../src/basics/stdtypes.txt:196
msgid "Mutable sequence types"
msgstr "Змінні типи послідовностей"

#: ../../src/basics/stdtypes.txt:201
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../src/basics/stdtypes.txt:201
msgid "item *i* of *s* is replaced by *x*"
msgstr "елемент *i* з *s* замінюється на *x*"

#: ../../src/basics/stdtypes.txt:203
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../src/basics/stdtypes.txt:203
msgid "slice of *s* from *i* to *j* replaced by the contents of *t*"
msgstr "фрагмент *s* від *i* до *j*, замінений вмістом *t*"

#: ../../src/basics/stdtypes.txt:206
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../src/basics/stdtypes.txt:206
msgid "same as ``s[i:j] = []``"
msgstr "те саме, що ``s[i:j] = []``"

#: ../../src/basics/stdtypes.txt:208
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../src/basics/stdtypes.txt:208
msgid "the elements of *s* are replaced by those of *t* [#]_"
msgstr "елементи *s* замінюються елементами *t* [#]_"

#: ../../src/basics/stdtypes.txt:210
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../src/basics/stdtypes.txt:210
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "видаляє елементи ``s[i:j:k]`` зі списку"

#: ../../src/basics/stdtypes.txt:212
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../src/basics/stdtypes.txt:212
msgid ""
"appends *x* to the end of the sequence; the same as ``s[len(s):len(s)] = "
"[x]``"
msgstr ""
"додає *x* до кінця послідовності; те саме, що ``s[len(s):len(s)] = [x]``"

#: ../../src/basics/stdtypes.txt:215
msgid "``s.clear()``"
msgstr "``s.clear()``"

#: ../../src/basics/stdtypes.txt:215
msgid "removes all items from *s* (``del s[:]``) [#py33]_"
msgstr "видаляє всі елементи з *s* (``del s[:]``) [#py33]_"

#: ../../src/basics/stdtypes.txt:217
msgid "``s.copy()``"
msgstr "``s.copy()``"

#: ../../src/basics/stdtypes.txt:217
msgid "creates a shallow copy of *s* (``s[:]``) [#py33]_"
msgstr "створює поверхневу копію *s* (``s[:]``) [#py33]_"

#: ../../src/basics/stdtypes.txt:219
msgid "``s.extend(t)`` ``s += t``"
msgstr "``s.extend(t)`` ``s += t``"

#: ../../src/basics/stdtypes.txt:219
msgid "extends *s* with the contents of *t*"
msgstr "розширює *s* вмістом *t*"

#: ../../src/basics/stdtypes.txt:222
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../src/basics/stdtypes.txt:222
msgid "inserts *x* into *s* at the index *i*; same as ``s[i:i] = [x]``"
msgstr "вставляє *x* у *s* за індексом *i*; те саме, що ``s[i:i] = [x]``"

#: ../../src/basics/stdtypes.txt:225
msgid "``s.pop()``, ``s.pop(i)``"
msgstr "``s.pop()``, ``s.pop(i)``"

#: ../../src/basics/stdtypes.txt:225
msgid ""
"retrieves the item at *i* and also removes it from *s* (if *i* is omitted - "
"use the last one available index)"
msgstr ""
"отримує елемент за адресою *i*, а також видаляє його з *s* (якщо *i* "
"пропущено - використовуйте останній доступний індекс)"

#: ../../src/basics/stdtypes.txt:228
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../src/basics/stdtypes.txt:228
msgid "remove the first item that is equal to *x* from *s*"
msgstr "видалити перший елемент, який дорівнює *x*, із *s*"

#: ../../src/basics/stdtypes.txt:230
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../src/basics/stdtypes.txt:230
msgid "reverses the items of *s* in place"
msgstr "перевертає елементи *s* на місце"

#: ../../src/basics/stdtypes.txt:233
msgid "*t* must have the same length as the slice it is replacing"
msgstr "*t* повинен мати таку ж довжину, як і фрагмент, який він замінює"

#: ../../src/basics/stdtypes.txt:234
msgid "new in Python version 3.3"
msgstr "нове у версії Python 3.3"

#: ../../src/basics/stdtypes.txt:237
msgid "Text sequence type"
msgstr "Тип текстової послідовності"

#: ../../src/basics/stdtypes.txt:240
msgid "String methods"
msgstr "Рядкові методи"

#: ../../src/basics/stdtypes.txt:242
msgid ""
"Strings implement all of the common sequence operations, along with the "
"additional methods."
msgstr ""
"Рядки реалізують усі звичайні операції з послідовністю разом із додатковими "
"методами."

#: ../../src/basics/stdtypes.txt:287
msgid ""
"Strings compare lexicographically using the numerical Unicode code points of "
"their characters."
msgstr ""
"Рядки порівнюються лексикографічно з використанням числових кодових точок "
"Unicode своїх символів."

#: ../../src/basics/stdtypes.txt:291
msgid "Set types"
msgstr "Типи сетів"

#: ../../src/basics/stdtypes.txt:296
msgid ""
"Sets (instances of ``set`` or ``frozenset``) can be compared within and "
"across their types. They define order comparison operators to mean subset "
"and superset tests. Those relations do not define total ordering (e.g. two "
"sets ``{1, 2}`` and ``{2, 3}`` are not equal, nor subsets of one another, "
"nor supersets of one another)."
msgstr ""
"Сети (екземпляри ``set`` або ``frozenset``) можна порівнювати всередині та "
"між типами. Вони визначають оператори порівняння порядку, щоб проходити "
"тести підмножини та надмножини. Ці відношення не визначають загального "
"порядку (наприклад, два набори ``{1, 2}`` та ``{2, 3}`` не є рівними, ані "
"підмножини одного іншого, ані надмножини один одного)."

#: ../../src/basics/stdtypes.txt:303
msgid "Mapping type"
msgstr "Тип відображення"

#: ../../src/basics/stdtypes.txt:305
msgid ""
"A mapping object maps hashable values to arbitrary objects. Mappings are "
"mutable objects. There is currently ony one standard mapping type, the "
"*dictionary*. In few words mappings are collections of keys and their values."
msgstr ""
"Об'єкт зіставлення зіставляє хешовані значення з довільними об'єктами. "
"Відображення є змінними об'єктами. Наразі існує лише один стандартний тип "
"відображення, *dictionary*. Якщо кількома словами, то відображення - це "
"набори ключів та їхніх значень."

#: ../../src/basics/stdtypes.txt:309
msgid ""
"A dictionary's keys are almost arbitrary values. Values that are not "
"hashable may not be used as keys. Values that compare equal (such as ``1``, "
"``1.0`` and ``True``) can be used interchangeably to index the same "
"dictionary entry."
msgstr ""
"Ключі словника - це майже довільні значення. Значення, які не хешуються, не "
"можуть бути використані як ключі. Значення, які порівнюються (такі як ``1``, "
"``1.0`` і ``True``), можна використовувати як взаємозамінні для індексування "
"тієї самої словникової статті."

#: ../../src/basics/stdtypes.txt:313
msgid "Dictionaries can be created by several means:"
msgstr "Словники можна створювати кількома способами:"

#: ../../src/basics/stdtypes.txt:315
msgid "Use braces to denote the empty dictionary: ``{}``"
msgstr "Використовуйте дужки для позначення порожнього словника: ``{}``"

#: ../../src/basics/stdtypes.txt:316
msgid ""
"Use a comma-separated list of ``key: value`` pairs with braces: "
"``{'first_name': 'Serhii', 'last_name': 'Horodilov', 'age': 34}``"
msgstr ""
"Використовуйте розділений комами список пар ``key: value`` з дужками: "
"``{'first_name': 'Serhii', 'last_name': 'Horodilov', 'age': 34}``"

#: ../../src/basics/stdtypes.txt:318
msgid "Use a dict comprehension: ``{x: x ** 2 for x in range(10)}``"
msgstr "Використовуючи генератори списків: ``{x: x 2 for x in range(10)}``"

#: ../../src/basics/stdtypes.txt:319
msgid ""
"Use the type constructor: ``dict()``, ``dict([('key', 100)])``, "
"``dict(key=100)``"
msgstr ""
"Використовуйте конструктор типу: ``dict()``, ``dict([('key', 100)])``, "
"``dict(key=100)``"

#: ../../src/basics/stdtypes.txt:325
msgid ""
"Instances of ``dict`` compare equal if and only if they have equal key-value "
"pairs."
msgstr ""
"Екземпляри ``dict`` вважаються рівними тоді і тільки тоді, коли вони мають "
"однакові пари ключ-значення."

#: ../../src/basics/stdtypes.txt:328
msgid "Order comparisons raise ``TypeError``."
msgstr "Порівняння порядку викликає ``TypeError``."

#: ../../src/basics/syntax.txt:3
msgid "Python Syntax"
msgstr "Синтаксис Python"

#: ../../src/basics/syntax.txt:5
msgid ""
"As a natural language like English or Ukrainian has its own rules to write "
"down something, programming languages do. This makes them programming "
"**languages**."
msgstr ""
"Оскільки природна мова, як-от англійська чи українська, має власні правила "
"запису чогось, так і мови програмування роблять схожі речі. Це і робить їх "
"мовами програмування."

#: ../../src/basics/syntax.txt:9
msgid ""
"A programming language syntax is the set of rules and principles that govern "
"how code is written and structured in a given programming language. Syntax "
"encompasses the rules for writing statements, expressions, variables, data "
"types, control structures, and other constructs that make up the language."
msgstr ""
"Синтаксис мови програмування - це набір правил і принципів, які регулюють "
"написання та структурування коду даною мовою програмування. Синтаксис "
"охоплює правила написання операторів, виразів, змінних, типів даних, "
"керуючих структур та інших конструкцій, які складають мову."

#: ../../src/basics/syntax.txt:14
msgid ""
"The syntax of a programming language defines how code is organized and "
"interpreted by a compiler or interpreter. It defines the rules for writing "
"valid statements and expressions that can be understood and executed by the "
"language's runtime system."
msgstr ""
"Синтаксис мови програмування визначає, як код організовується та "
"інтерпретується компілятором або інтерпретатором. Він визначає правила "
"написання дійсних операторів і виразів, які можуть бути зрозумілі та "
"виконані системою виконання мови."

#: ../../src/basics/syntax.txt:19
msgid ""
"A programming language's syntax is designed to be both readable and "
"expressive, allowing programmers to write code that is easy to understand "
"and modify. Syntax often influences the style and structure of code, as well "
"as its maintainability and performance."
msgstr ""
"Синтаксис мови програмування розроблено таким чином, щоб він був читабельним "
"і виразним, дозволяючи програмістам писати код, який легко зрозуміти та "
"змінювати. Синтаксис часто впливає на стиль і структуру коду, а також на "
"його зручність обслуговування та продуктивність."

#: ../../src/basics/syntax.txt:24
msgid ""
"Different programming languages have different syntax, with some languages "
"being more concise and expressive than others. While syntax is an important "
"aspect of a programming language, it is only one of several factors that "
"determine its ease of use, flexibility, and suitability for different "
"programming tasks."
msgstr ""
"Різні мови програмування мають різний синтаксис, при цьому деякі мови є "
"більш лаконічними та виразнішими, ніж інші. Хоча синтаксис є важливим "
"аспектом мови програмування, він є лише одним із кількох факторів, які "
"визначають її легкість у використанні, гнучкість і придатність для різних "
"завдань програмування."

#: ../../src/basics/syntax.txt:30
msgid ""
"In the case of Python, the language's syntax defines how code is written and "
"structured in a way that is consistent, readable, and easy to understand. A "
"general overview is provided below, no need to dive deep in this now. All of "
"the following is to be discussed during the course. So, some of the key "
"aspects of Python's syntax include:"
msgstr ""
"У випадку Python синтаксис мови визначає, як код буде написаний і "
"структурований таким чином, щоб він був послідовним, читабельним і легким "
"для розуміння. Нижче наведено загальний огляд, немає потреби глибоко "
"занурюватися в це зараз. Усе наведене нижче має бути обговорено під час "
"курсу. Отже, деякі з ключових аспектів синтаксису Python включають:"

#: ../../src/basics/syntax.txt
msgid "Indentation"
msgstr "Відступ"

#: ../../src/basics/syntax.txt:37
msgid ""
"Python uses whitespace, specifically indentation, to delimit blocks of code, "
"such as loops, conditionals, and functions. This means that the indentation "
"level of a line determines which block of code it belongs to."
msgstr ""
"Python використовує пробіли, зокрема відступи, для розмежування блоків коду, "
"таких як цикли, умови та функції. Це означає, що рівень відступу рядка "
"визначає, до якого блоку коду він належить."

#: ../../src/basics/syntax.txt
msgid "Statement structure"
msgstr "Структура коду"

#: ../../src/basics/syntax.txt:43
msgid ""
"Python statements are typically written on one line, with the end of the "
"line indicating the end of the statement. However, if a statement is too "
"long to fit on one line, it can be continued across multiple lines using "
"backslashes."
msgstr ""
"Інструкції Python зазвичай пишуться в один рядок, причому кінець рядка "
"вказує на кінець інструкції. Проте, якщо оператор занадто довгий, щоб "
"поміститися в один рядок, його можна продовжити в кількох рядках, "
"використовуючи зворотні похилі риски."

#: ../../src/basics/syntax.txt ../../src/basics/variables.txt:3
msgid "Variables"
msgstr "Змінні"

#: ../../src/basics/syntax.txt:49
msgid ""
"In Python, variables are created automatically when a value is assigned to "
"them, and their type is inferred from the value. Variables can be assigned "
"values of different types, including integers, floats, strings, and more "
"complex data structures like lists and dictionaries."
msgstr ""
"У Python змінні створюються автоматично, якщо їм присвоюється значення, і "
"їхній тип визначається на основі значення. Змінним можна присвоювати "
"значення різних типів, включаючи цілі числа, числа з плаваючою комою, рядки "
"та складніші структури даних, такі як списки та словники."

#: ../../src/basics/syntax.txt
msgid "Operators"
msgstr "Оператори"

#: ../../src/basics/syntax.txt:55
msgid ""
"Python supports a wide range of operators for performing arithmetic, "
"comparison, and logical operations. These include arithmetic operators like "
"``+``, ``-``, ``*``, and ``/``, as well as comparison operators like ``<``, "
"``>``, ``==``, and ``!=``."
msgstr ""
"Python підтримує широкий спектр операторів для виконання арифметичних, "
"порівнянь і логічних операцій. До них належать арифметичні оператори, такі "
"як ``+``, ``-``, ``*`` і ``/``, а також оператори порівняння, такі як "
"``<`` , ``>``, ``==`` і ``!=``."

#: ../../src/basics/syntax.txt
msgid "Control flow"
msgstr "Контроль потоку"

#: ../../src/basics/syntax.txt:61
msgid ""
"Python provides control flow statements like if, else, elif, for, and while "
"to control the flow of execution in a program. These statements are used to "
"make decisions, repeat code, or perform actions based on conditions."
msgstr ""
"Python надає оператори потоку керування, як-от if, else, elif, for та while, "
"для керування потоком виконання в програмі. Ці оператори використовуються "
"для прийняття рішень, повторення коду або виконання дій на основі заданих "
"умов."

#: ../../src/basics/syntax.txt:67
msgid ""
"In Python, functions are defined using the def keyword and can take "
"arguments and return values. The body of a function is defined using a block "
"of indented code."
msgstr ""
"У Python функції визначаються за допомогою ключового слова def і можуть "
"отримувати аргументи та повертати значення. Тіло функції визначається за "
"допомогою блоку коду з відступами."

#: ../../src/basics/syntax.txt
msgid "Modules"
msgstr "Модулі"

#: ../../src/basics/syntax.txt:72
msgid ""
"Python has a large library of modules that provide pre-written code for a "
"variety of tasks. Modules can be imported into a program using the import "
"statement."
msgstr ""
"Python має велику бібліотеку модулів, які містять попередньо написаний код "
"для різноманітних завдань. Модулі можна імпортувати в програму за допомогою "
"оператора імпорту."

#: ../../src/basics/syntax.txt:77
msgid ""
"Python provides a way to handle errors and exceptions in a program using the "
"try, except, else, and finally keywords. These statements allow a program to "
"gracefully recover from errors and continue executing."
msgstr ""
"Python надає спосіб обробки помилок і винятків у програмі за допомогою "
"ключових слів try, except, else і finally. Ці оператори дозволяють програмі "
"плавно відновлюватися після помилок і продовжувати виконання."

#: ../../src/basics/syntax.txt:81
msgid "In few words:"
msgstr "У кількох словах:"

#: ../../src/basics/syntax.txt:83
msgid "Input/Output example script"
msgstr "Приклад сценарію Input/Output"

#: ../../src/basics/syntax.txt:102
msgid ""
"The code snippet above demonstrates some basics abilities of Python to "
"gather data from the user, process it and print out back. Note the words "
"starting with a # (hash) symbol. This is a comment. Any sequence of "
"characters after the hash and till the line end are considered to be a "
"comment. These are for those people, who see the code and they are ignored "
"by the interpreter."
msgstr ""
"Наведений вище фрагмент коду демонструє деякі основні можливості Python "
"збирати дані від користувача, обробляти їх і друкувати назад. Зверніть увагу "
"на слова, що починаються символом #(решітка). Це коментар. Будь-яка "
"послідовність символів після хеша і до кінця рядка вважається коментарем. Це "
"необхідно, щоб люди які бачать код могли його зрозуміти, при цьому "
"інтерпретатор їх ігнорує."

#: ../../src/basics/syntax.txt:108
msgid ""
"On the other hand each individual line is the instruction for the "
"interpreter to perform some action, like gather inputs, do math, store data "
"in memory etc."
msgstr ""
"З іншого боку, кожен окремий рядок є вказівкою для інтерпретатора виконати "
"певну дію, як-от збір вхідних даних, виконання математичних розрахунків, "
"збереження даних у пам'яті тощо."

#: ../../src/basics/testing.txt:3
msgid "Testing"
msgstr "Тестування"

#: ../../src/basics/variables.txt:5
msgid ""
"In computer science a **variable** is a named storage location in memory "
"that can hold a value (*data*). The value stored in a variable can be "
"changed or accessed by the program during its execution."
msgstr ""
"В інформатиці **variable** - це назване місце зберігання в пам'яті, яке може "
"зберігати значення (дані). Значення, яке зберігається у змінній, може бути "
"змінено або доступне програмою під час її виконання."

#: ../../src/basics/variables.txt:9
msgid ""
"In Python, variables are created dynamically once a value is assigned to "
"them. This makes Python a dynamically typed language, which means that the "
"data type of a variable is inferred from the value assigned to it. So, you "
"do not need to declare a variable before using it, as in statically typed "
"languages."
msgstr ""
"У Python змінні створюються динамічно після присвоєння їм значення. Це "
"робить Python динамічно типізованою мовою, а це означає, що тип даних "
"змінної виводиться з присвоєного їй значення. Отже, вам не потрібно "
"оголошувати змінну перед її використанням, як у статично типізованих мовах."

#: ../../src/basics/variables.txt:14
msgid ""
"The ability to create variables dynamically and infer their data type makes "
"Python code more concise and easier to read. However, it also requires "
"careful attention to variable naming and assignment to avoid unexpected "
"behavior."
msgstr ""
"Можливість динамічно створювати змінні та виводити їхні типи даних робить "
"код Python більш лаконічним і легшим для читання. Однак це також вимагає "
"пильної уваги до іменування та призначення змінних, щоб уникнути "
"неочікуваної поведінки."

#: ../../src/basics/variables.txt:18
msgid ""
"In Python ``=`` (assignment operator) is used to set a value to some "
"variable, the portion on the left of the operator is a *variable name* and "
"the portion on the right is a *value* to assign to a variable."
msgstr ""
"У Python ``=`` (оператор присвоєння) використовується для встановлення "
"значення деякої змінної, частина ліворуч від оператора - це ім'я змінної, а "
"частина праворуч - це значення, яке призначається для неї."

#: ../../src/basics/variables.txt:22
msgid "Variable assignment in Python"
msgstr "Присвоєння змінної в Python"

#: ../../src/basics/variables.txt:29
msgid "Variable assignment in Java"
msgstr "Присвоєння змінної в Java"

#: ../../src/basics/variables.txt:37
msgid "Naming"
msgstr "Присвоєння назви"

#: ../../src/basics/variables.txt:39
msgid ""
"In Python there are several rules that describe how to name your variables. "
"Some of these are requirements and cannot be ignored, others are rather "
"recommended than required and can be omitted. For now note, that a variable "
"name **cannot**:"
msgstr ""
"У Python є кілька правил, які описують, як іменувати ваші змінні. Деякі з "
"них є вимогами, і їх не можна ігнорувати, інші скоріше рекомендовані, ніж "
"обов'язкові, і їх можна пропустити. Наразі зауважте, що ім'я змінної не може:"

#: ../../src/basics/variables.txt:44
msgid "a language keyword (like ``pass``, ``def`` or ``class``)"
msgstr "бути ключовим словом мови (наприклад, ``pass``, ``def`` або ``class``)"

#: ../../src/basics/variables.txt:45
msgid "start with a number (e.g. ``123``, ``1_something``)"
msgstr "починатися з числа (наприклад, ``123``, ``1_something``)"

#: ../../src/basics/variables.txt:46
msgid "contain special operators in it (``+``, ``-``, ``=`` etc.)"
msgstr "містити спеціальні оператори (``+``, ``-``, ``=`` тощо)"

#: ../../src/basics/variables.txt:47
msgid "contain white spaces"
msgstr "містити пробіли"

#: ../../src/basics/variables.txt:49
msgid "Also here are some general recommendation on naming anything:"
msgstr "Також ось деякі загальні рекомендації щодо іменування будь-чого:"

#: ../../src/basics/variables.txt:51
msgid "do not use built-in functions as a variable name (e.g. ``len = 42``)"
msgstr ""
"не використовуйте вбудовані функції як назву змінної (наприклад, ``len = "
"42``)"

#: ../../src/basics/variables.txt:52
msgid "keep names meaningful (``x = 10`` vs ``number_of_student = 100``)"
msgstr ""
"зберігайте значення імен (``x = 10`` проти ``number_of_student = 100``)"

#~ msgid "Data Types"
#~ msgstr "Типи Даних"

#~ msgid ""
#~ "Data may represent different things and require various operations "
#~ "available. In programming data types is an important concept. For example "
#~ "**1984** may be a number (``1984``), a text (``\"1984\"``) or event a "
#~ "date. The data type describes the operations, that are allowed for the "
#~ "data, like additions for numbers or concatenation for text (e.g. ``1 + 2 -"
#~ "> 3``, ``\"1\" + \"3\" -> \"13\"``)."
#~ msgstr ""
#~ "Дані можуть представляти різні речі та вимагати різноманітних "
#~ "доступнихоперацій. У програмуванні типи даних є важливою концепцією. "
#~ "Наприклад, **1984** може бути числом (``1984``), текстом (``\"1984\"`` ) "
#~ "або подією чи датою. Тип даних описує можливі операції, дозволені для "
#~ "даних, як-от додавання чисел або конкатенація для тексту (наприклад, ``1 "
#~ "+ 2 -> 3``, ``\"1\" + \"3 \" -> \"13\"``)."

#~ msgid ""
#~ "Python uses dynamic typing. This means as a developer you should not "
#~ "declare a variable with its data type - the interpreter will do this for "
#~ "you. Other popular language using dynamic typing are JavaScript and PHP. "
#~ "Setting variables in Python is as easy as:"
#~ msgstr ""
#~ "Python використовує динамічну типізацію. Це означає, що ви, як розробник, "
#~ "не повинні оголошувати змінну з її типом даних - інтерпретатор зробить це "
#~ "за вас. Іншими популярними мовами, які використовують динамічну "
#~ "типізацію, є JavaScript і PHP. Налаштування змінних у Python доволі "
#~ "просто, як: "

#~ msgid "Built-In Data Types"
#~ msgstr "Вбудовані типи даних"

#~ msgid "Python has the following data types built-in:"
#~ msgstr "Python має такі вбудовані типи даних:"

#~ msgid "Integers (``int``)"
#~ msgstr "Цілі числа (``int``)"

#~ msgid "Floating-point numbers (``float``)"
#~ msgstr "Числа з плаваючою крапкою (``float``)"

#~ msgid "Complex numbers (``complex``)"
#~ msgstr "Комплексні числа (``complex``)"

#~ msgid "Booleans (``bool``)"
#~ msgstr "Логічні значення (``bool``)"

#~ msgid "Strings (``str``)"
#~ msgstr "Рядки (``str``)"

#~ msgid "Bytes (``bytes``)"
#~ msgstr "Байти (``bytes``)"

#~ msgid "Byte arrays (``bytearray``)"
#~ msgstr "Масиви байтів (``bytearray``)"

#~ msgid "Lists (``list``)"
#~ msgstr "Списки (``list``)"

#~ msgid "Tuples (``tuple``)"
#~ msgstr "Кортежі (``tuple``)"

#~ msgid "Sets (``set``)"
#~ msgstr "Cети (``set``)"

#~ msgid "Frozen sets (``frozenset``)"
#~ msgstr "Заморожені сети (``frozenset``)"

#~ msgid "Dictionaries (``dict``)"
#~ msgstr "Словники (``dict``)"

#~ msgid "None (``NoneType``)"
#~ msgstr "Жодного (``NoneType``)"

#~ msgid ""
#~ "Any one can use them without additional imports or packages installations."
#~ msgstr ""
#~ "Будь-хто може використовувати їх без додаткового імпорту чи встановлення "
#~ "пакетів. "

#~ msgid "Text"
#~ msgstr "Текстові дані"

#~ msgid ""
#~ "Text data are stored as strings (``str`` data type) in Python. Any "
#~ "sequence of letters, digits, punctuation marks and whitespace characters "
#~ "enclosed with quotes is considered to be a string literal. Both single "
#~ "quotes (``'``) and double quotes (``\"``) can be used interchangeably to "
#~ "create a string in Python."
#~ msgstr ""
#~ "Текстові дані зберігаються як рядки (тип даних ``str``) у Python. Будь-"
#~ "яка послідовність літер, цифр, знаків пунктуації та пробілів, взята в "
#~ "лапки, вважається рядковим літералом. Обидві одинарні лапки (``'``) або "
#~ "подвійні лапки (``\"``) можна взаємозамінно використовувати для створення "
#~ "рядків."

#~ msgid "Escaping"
#~ msgstr "Екранування"

#~ msgid ""
#~ "In programming this is a process of using a special character to indicate "
#~ "that the following character(s) should be treated differently from their "
#~ "literal meaning. The common usage is to include a special character(s) "
#~ "within strings. A **backslash** character is used to *escape* the "
#~ "following one."
#~ msgstr ""
#~ "У програмуванні це процес використання спеціального символу, щоб вказати, "
#~ "що наступний(і) символ(и) слід розглядати інакше, ніж їхнє буквальне "
#~ "значення. Загальне використання полягає в тому, щоб включити "
#~ "спеціальний(і) символ(и) в рядки. Символ **backslash** використовується "
#~ "для екранування наступного. "

#~ msgid "Example of Escaping in Python"
#~ msgstr "Приклади Екранування в Python"

#~ msgid "Single quotes or double quotes"
#~ msgstr "Одинарні або подвійні лапки"

#~ msgid ""
#~ "Don't care. Use any quote mark you like. A *string* is a sequence of "
#~ "characters after the opening quote and till the closing one. You may use "
#~ "double quotes in case a single quote is a part of the text (e.g. ``\"It's "
#~ "a Serhii's document\"``) and vise versa (e.g. ``'The name of the ship was "
#~ "a \"Billy of Tea\"'``). It's a good practice not to mess single and "
#~ "double quotes within one project. Just keep using a chosen one character "
#~ "for all strings."
#~ msgstr ""
#~ "Неважливо які лапки ви використовуйте. Рядок - це послідовність символів "
#~ "після початкової лапки та до кінцевої. Ви можете використовувати подвійні "
#~ "лапки, якщо одинарна лапка є частиною тексту (наприклад, ``\"Це документ "
#~ "Сергія\"``) і навпаки (наприклад ``'Назва корабля була \"Billy of "
#~ "Tea\"'``). Рекомендується не плутати одинарні та подвійні лапки в одному "
#~ "проекті. Просто продовжуйте використовувати один вибраний символ для всіх "
#~ "рядків. "

#~ msgid "Multiline strings"
#~ msgstr "Багатострічкові рядки"

#~ msgid ""
#~ "You can assign a multiline string by using triple quotes: Both single "
#~ "quote and double quote characters are available."
#~ msgstr ""
#~ "Ви можете призначити багаторядковий рядок, використовуючи потрійні лапки: "
#~ "в середині них доступні як одинарні, так і подвійні лапки. "

#~ msgid ""
#~ "The same syntax is used to create docstring, which are a special case of "
#~ "string usage. We will look on these in the future."
#~ msgstr ""
#~ "Такий самий синтаксис використовується для створення рядка документації, "
#~ "який є окремим випадком використання рядка. Ми розглянемо це в "
#~ "майбутньому. "

#~ msgid "This subsection describes only the most common operations."
#~ msgstr "У цьому розділі описано лише найпоширеніші операції. "

#~ msgid "Concatenation"
#~ msgstr "Конкатинація"

#~ msgid ""
#~ "The ``+`` operator is used to concatenate (join) two or more strings."
#~ msgstr ""
#~ "Оператор ``+`` використовується для конкатенації (об'єднання) двох або "
#~ "більше рядків. "

#~ msgid ""
#~ "On the other hand the ``join`` method concatenates a collection of "
#~ "strings, which may be more efficient than using ``+``."
#~ msgstr ""
#~ "З іншого боку, метод ``join`` об'єднує колекцію рядків, що може бути "
#~ "ефективнішим, ніж використання ``+``. "

#~ msgid "Repetition"
#~ msgstr "Повторення"

#~ msgid ""
#~ "The ``*`` operator is used to repeat a string a specified number of "
#~ "times. Only multipliers of the ``int`` type are allowed."
#~ msgstr ""
#~ "Оператор ``*`` використовується для повторення рядка вказану кількість "
#~ "разів. Дозволені операції лише з множниками типу ``int``. "

#~ msgid "Length"
#~ msgstr "Довжина"

#~ msgid "The ``len`` function is used to find the length of a string."
#~ msgstr "Функція ``len`` використовується для визначення довжини рядка."

#~ msgid "Case conversion"
#~ msgstr "Перетворення регістру"

#~ msgid ""
#~ "The ``lower``, ``upper``, ``capitalize`` and ``title`` methods perform "
#~ "actions on case."
#~ msgstr ""
#~ "Методи ``lower``, ``upper``, ``capitalize`` і ``title`` виконують дії з "
#~ "зміною регістра. "

#~ msgid "``lower`` creates a new string with all lower-case characters."
#~ msgstr "``lower`` створює новий рядок з усіма символами нижнього регістру."

#~ msgid "``upper`` creates a new string with all upper-case characters."
#~ msgstr "``upper`` створює новий рядок з усіма символами верхнього регістру."

#~ msgid ""
#~ "``capitalize`` creates a new string with the upper-case 1st character."
#~ msgstr ""
#~ "``capitalize`` створює новий рядок із першим символом у верхньому "
#~ "регістрі. "

#~ msgid "``title`` will make all characters after whitespace upper case."
#~ msgstr "``title`` зробить усі символи після пробілів верхнім регістром."

#~ msgid "Stripping"
#~ msgstr "Зачистка"

#~ msgid ""
#~ "The ``strip``, ``lstrip`` and ``rstrip`` methods are used to remove "
#~ "leading and/or trailing whitespace characters."
#~ msgstr ""
#~ "Методи ``strip``, ``lstrip`` і ``rstrip`` використовуються для видалення "
#~ "початкових і/або кінцевих пробільних символів. "

#~ msgid "Strings are subscriptable"
#~ msgstr "Рядки можна підписувати"

#~ msgid "``str`` is not the only one subscriptable data type in Python."
#~ msgstr "``str`` - це не єдиний тип даних, який можна підписувати в Python."

#~ msgid ""
#~ "This means you can access individual characters or slices within a string "
#~ "using indexes. A string is a *sequence* of characters and each character "
#~ "within a string has its own position - an *index*. Indexing starts at 0, "
#~ "so the first character in a string is at index 0, the second one is at "
#~ "index 1, and so on. Negative indexing is also possible, with -1 "
#~ "representing the last character in a string, -2 representing the second-"
#~ "to-last character, and so on. Use square brackets (``[]``) to access the "
#~ "index."
#~ msgstr ""
#~ "Це означає, що ви можете отримати доступ до окремих символів або "
#~ "фрагментів у рядку за допомогою індексів. Рядок — це послідовність "
#~ "символів, і кожен символ у рядку має власну позицію — індекс. Індексація "
#~ "починається з 0, отже, перший символ у рядку має індекс 0, другий - "
#~ "індекс 1 і так далі. Також можливе від'ємне індексування, коли -1 "
#~ "представляє останній символ у рядку, а -2 представляє передостанній "
#~ "символ і так далі. Використовуйте квадратні дужки (``[]``), щоб отримати "
#~ "доступ до індексу. "

#~ msgid ""
#~ "You can also *slice* strings, this means to get a subsequence of "
#~ "characters. The slice syntax consists of 3 digits:"
#~ msgstr ""
#~ "Ви також можете *розрізати* рядки, тобто отримати підпослідовність "
#~ "символів. Синтаксис фрагмента складається з 3 цифр: "

#~ msgid ""
#~ "the first one represent the index to start (inclusive), defaults to 0"
#~ msgstr ""
#~ "Перший представляє початковий індекс (включно), за замовчанням дорівнює "
#~ "0. "

#~ msgid ""
#~ "the second one represent the index to stop (non-inclusive), defaults to "
#~ "the length of the sequence"
#~ msgstr ""
#~ "Другий представляє індекс для зупинки (не включно), за замовчуванням "
#~ "довжина послідовності. "

#~ msgid "the third one represents a step, defaults to 1"
#~ msgstr "Третій представляє крок, за замовчуванням 1."

#~ msgid ""
#~ "These numbers are separated within colon (``:``) and enclosed within "
#~ "square brackets. Any slice digit may be omitted."
#~ msgstr ""
#~ "Ці числа розділені двокрапкою (``:``) і взяті в квадратні дужки. Будь-яка "
#~ "цифра зрізу може бути упущена. "

#~ msgid "Sequence slicing"
#~ msgstr "Нарізка послідовності"

#~ msgid "Strings are iterable"
#~ msgstr "Рядки можна повторювати"

#~ msgid ""
#~ "Since strings are arrays, we can loop through the characters in a string "
#~ "with a ``for`` loop:"
#~ msgstr ""
#~ "Оскільки рядки є масивами, ми можемо прокручувати символи в рядку за "
#~ "допомогою циклу ``for``: "

#~ msgid "Strings are immutable"
#~ msgstr "Рядки незмінні"

#~ msgid ""
#~ "This means, you cannot change an individual character within a string."
#~ msgstr "Це означає, що ви не можете змінити окремий символ у рядку."

#~ msgid "Integers"
#~ msgstr "Цілі числа"

#~ msgid ""
#~ "``int``, or integer, is a whole number, positive or negative, without "
#~ "decimals."
#~ msgstr ""
#~ "``int``, тобто ціле число, може бути додатнім або від'ємним, без "
#~ "десяткових знаків. "

#~ msgid "Floats"
#~ msgstr "Числа з плаваючою комою"

#~ msgid ""
#~ "``float``, or floating point number, is a number, positive or negative, "
#~ "containing one or more decimals."
#~ msgstr ""
#~ "``float``, або число з плаваючою комою, - це число, додатне чи від’ємне, "
#~ "що містить один або більше десяткових знаків. "
