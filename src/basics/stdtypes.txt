*******************************************************************************
                                Built-in Types
*******************************************************************************

The principal built-in types are numerics, sequences, mappings, classes,
instances and exceptions :cite:`docs-python:stdtypes`. This section covers
only the most base of them. Others will be discussed in the future within
their own topics.

Numeric types
=============

There are 3 distinct numeric types: *integers*, *floating point numbers*, and
*complex numbers*. In addition, Booleans are a subtype of integers. Integers
have unlimited precision. Floating point numbers are usually implemented usign
``double`` in C. Complex numbers have a real and imaginary part, which are each
a floating point number.

Numbers are created by numeric literals or as the result of built-in functions
and operators. Unadorned integer literals (including hex, octal and binary
numbers) yield integers. Numeric literals containing a decimal point or an
exponent sign yield floating point numbers. Appending ``j`` or ``J`` to a
numeric literal yields an imaginary number (a complex number with a zero real
part) which you can add to an integer or float to get a complex number with
real and imaginary parts.

Supported operations
--------------------

+---------------------+-------------------------------------------------------+
| Operation           | Result                                                |
+=====================+=======================================================+
| ``x + y``           | sum of *x* and *y*                                    |
+---------------------+-------------------------------------------------------+
| ``x - y``           | difference of *x* and *y*                             |
+---------------------+-------------------------------------------------------+
| ``x * y``           | product of *x* and *y*                                |
+---------------------+-------------------------------------------------------+
| ``x / y``           | quotient of *x* and *y*                               |
+---------------------+-------------------------------------------------------+
| ``x // y``          | floored quotient of *x* and *y*                       |
+---------------------+-------------------------------------------------------+
| ``x % y``           | remainder of ``x / y``                                |
+---------------------+-------------------------------------------------------+
| ``-x``              | *x* negated                                           |
+---------------------+-------------------------------------------------------+
| ``+x``              | *y* unchanged                                         |
+---------------------+-------------------------------------------------------+
| ``abs(x)``          | absolute value or magnitude of *x*                    |
+---------------------+-------------------------------------------------------+
| ``int(x)``          | *x* converted to integer                              |
+---------------------+-------------------------------------------------------+
| ``float(x)``        | *x* converted to floating point                       |
+---------------------+-------------------------------------------------------+
| ``complex(re, im)`` | a complex number with real part *re*, imaginary part  |
|                     | *im*. *im* defaults to zero.                          |
+---------------------+-------------------------------------------------------+
| ``divmod(x, y)``    | the pair ``(x // y, x % y)``                          |
+---------------------+-------------------------------------------------------+
| ``pow(x, y)``       | *x* to the power *y*                                  |
| ``x ** y``          |                                                       |
+---------------------+-------------------------------------------------------+

.. note:: ``x // y`` also referred to as integer division. The resultant value
          is a whole integer, through the result's type is not necessarily int.
          The result is always rounded towards minus infinity:
          ``1 // 2`` is ``0``

.. note:: ``float(x)`` also accepts the strings ``"nan"`` and ``"inf"`` with
          an optional prefix "+" or "-" for :abbr:Nan(Not a Number) and
          positive and negative infinity.

Code examples
-------------

.. code-block:: python
    :caption: Integer numbers
    
    x = 42
    y = 24
    a = int(42)
    b = int(42.24)
    
    result = x + y   # for both int operands only
    result = x - y   # for both int operands only
    result = x * y   # for both int operands only
    result = x // y  # for any numeric operands

.. code-block:: python
    :caption: Floating point numbers

    x = 42.
    y = .24
    z = 42.24
    a = float(42)
    b = float(42.24)
    
    result = x + y  # for any float operand
    result = x - y  # for any float operand
    result = x * y  # for any float operand
    result = x / y  # for any numeric operands

Value comparison
----------------

Numbers of built-in numeric types can be compared within and across their types
(with the restriction that complex numbers do not support order comparison).
Within the limits of the types involved, they compare mathematically correct
without loss of precision.

The "not-a-number" values ``float("NaN")`` and ``decimal.Decimal('NaN')`` are
special. Any ordered comparison of a number to a not-a-number value is false.

Sequence types
==============

There are 3 basic sequence types: *lists*, *tuples*, and *range objects*.
Additional sequence types tailored for processing of binary data and text
strings are described in dedicated sections.

Common operations
-----------------

+----------------------+------------------------------------------------------+
| Operation            | Result                                               |
+======================+======================================================+
| ``x in s``           | ``True`` if an item of *s* equal to *x*              |
| ``x not in s``       | ``False`` if an item of *s* equal to *x*             |
+----------------------+------------------------------------------------------+
| ``s + t``            | the concatenation of *s* and *t*                     |
+----------------------+------------------------------------------------------+
| ``s * n``            | equivalent to adding *s* to itself *n* times         |
+----------------------+------------------------------------------------------+
| ``s[i]``             | *i*-th item of *s*, origin 0                         |
+----------------------+------------------------------------------------------+
| ``s[i:j]``           | slice of *s* from *i* to *j* with step *k*. any of   |
| ``s[i:j:k]``         | these (or even all 3) may be omitted.                |
+----------------------+------------------------------------------------------+
| ``len(s)``           | length of *s*                                        |
+----------------------+------------------------------------------------------+
| ``min(s)``           | smallest item of *s*                                 |
+----------------------+------------------------------------------------------+
| ``max(s)``           | largest item of *s*                                  |
+----------------------+------------------------------------------------------+
| ``s.count(x)``       | total number of occurrences of *x* in *s*            |
+----------------------+------------------------------------------------------+
| ``s.index(x)``       | index of the first occurrence of *x* in *s*          |
| ``s.index(x, i)``    | (at or after index *i* and before index *j*)         |
| ``s.index(x, i, j)`` |                                                      |
+----------------------+------------------------------------------------------+

Value comparison
----------------

.. todo: make TypeError a link

Sequences can be compared only within each of their types, with the restriction
that ranges do not support order comparison. Equality comparison across these
types results in inequality, and ordering comparison across these types raises
``TypeError``.

Sequences compare lexicographically using comparison of corresponding elements.
The built-in containers typically assume identical objects are equal to
themselves. Lexicographical comparison between buit-in collections works as
follows:

-  For two collections to compare equal, they must be of the same type, have
   the same length, and each pair of corresponding elements must compare equal.
-  Collections that supports order comparison are ordered the same as their
   first unequal elements. If corresponding element does not exist, the shorter
   collection is ordered first.

Text sequence type
==================

Set types
=========

Value comparison
----------------

Sets (instances of ``set`` or ``frozenset``) can be compared within and across
their types. They define order comparison operators to mean subset and superset
tests. Those relations do not define total ordering (e.g. two sets ``{1, 2}``
and ``{2, 3}`` are not equal, nor subsets of one another, nor supersets of one
another).

Mapping type
============
