.. meta::
    :description: Version control system
    :author: Serhii Horodilov
    :keywords: version, control, system, vcs, git, basics

*******************************************************************************
                                  Git Basics
*******************************************************************************

Getting a Git repository
========================

You typically obtain a Git repository in one of two ways:

#.  You can take a local directory that is currently not under version control,
    and turn it into a Git repository.
#.  You can clone an existing Git repository from elsewhere.

In either case, you end up with a Git repository on your local machine,
ready for work.

Initializing repo in an existing directory
------------------------------------------

If you have a project directory that is currently not under version control and
you want to start controlling it with Git, you first need to go to that
project's directory. If you've never done this, it looks a little different
depending on which system you're running:

.. code-block:: shell
    :caption: Change directory in bash (Linux)

    cd /home/user/project

.. code-block:: shell
    :caption: Change directory in bash (MacOS)

    cd /Users/user/project

.. code-block:: powershell
    :caption: Change directory in PowerShell (Windows)

    cd C:\Users\user\project

In the project's directory initialize a new Git repository.

.. code-block:: shell

    git init

This creates a new subdirectory named .git that contains all of your necessary
repository files -- a Git repository skeleton.

Cloning an existing repo
------------------------

If you want to get a copy of an existing Git repository -- for example,
a project you'd like to contribute to -- the command you need is ``git clone``.

.. code-block:: shell

    git clone https://github.com/edu-python-course/edu-python-course.github.io

That creates a directory named *edu-python-course.github.io*, initializes a
*.git* directory inside it, pulls down all the data for that repository,
and checks out a working copy of the latest version.

.. code-block:: shell

    git clone https://github.com/edu-python-course/edu-python-course.github.io python-course

That command does the same thing as the previous one, but the target directory
is called *python-course*.

Git has a number of different transfer protocols you can use. The previous
example uses the ``https://`` protocol, but you may also see ``git://`` or
``user@server:path/to/repo.git``, which uses the SSH transfer protocol.

Making changes to the repo
==========================

At this point, you should have a *bona fide* Git repository on your local
machine, and a checkout or *working copy* of all of its files in front of you.
Typically, you'll want to start making changes and committing snapshots of
those changes into your repository each time the project reaches a state you
want to record.

Remember that each file in your working directory can be in one of two states:
**tracked** or **untracked**.

-   Tracked files are files that were in the last snapshot, as well as any
    newly staged files; they can be unmodified, modified, or staged. In short,
    tracked files are files that Git knows about.
-   Untracked files are everything else -- any files in your working directory
    that were not in your last snapshot and are not in your staging area.
    Untracked basically means that Git sees a file you didn't have in
    a previous snapshot (commit), and which hasn't been yet staged.

.. mermaid:: /../assets/mermaid/git-lifecycle.mmd
    :align: center
    :caption: The lifecycle of the status of repo's files

Checking out status of the file(s)
----------------------------------

The main tool you use to determine which files are in which state is
the ``git status`` command.

.. code-block:: shell

    $ # check status
    $ git status
    On branch devel

    No commits yet

    nothing to commit (create/copy files and use "git add" to track)

    $ # add file to the repository
    $ echo "# Project Title" > README.md
    $ # check status once again
    $ git status
    On branch devel

    No commits yet

    Untracked files:
      (use "git add <file>..." to include in what will be committed)
            README.md

    nothing added to commit but untracked files present (use "git add" to track)

Newly added *README.md* file is untracked, because it's under "Untracked files"
heading the status output.

Tracking new files
------------------

In order to begin tracking a new file, you use the ``git add`` command.

.. code-block:: shell

    $ git add README.md
    $ git status
    On branch devel

    No commits yet

    Changes to be committed:
      (use "git rm --cached <file>..." to unstage)
            new file:   README.md

From now *README.md* file is **added** to the stage area and ready to be
committed (is under "Changes to be committed" heading).

.. hint::
    You can use wildcards, to stage multiple files at once. The most common
    use cases is to add **all** modified files, or files inside of a specific
    directory.

    .. code-block:: shell

        git add *     # stage all changes
        git add .     # stage all changes in current directory
        git add docs  # stage all changes in "docs" directory

Staging modified files
----------------------

If a staged (or already committed) file has been changed, it will be moved
under "Modified" heading. These changes wouldn't be committed unless they are
staged.

.. code-block:: shell

    $ git status
    On branch devel

    No commits yet

    Changes to be committed:
      (use "git rm --cached <file>..." to unstage)
            new file:   README.md

    Changes not staged for commit:
      (use "git add <file>..." to update what will be committed)
      (use "git restore <file>..." to discard changes in working directory)
            modified:   README.md

-   Changes may be added to the stage area by repeating ``git add`` command.
-   Changes may be discard by ``git restore <file>`` command. This action will
    restore file to its **staged** version.

Ignoring files
--------------

Often, there is a class of files, that should not be a part of a repo. You
want these files to be prevent from being automatically added or even shown
as being untracked. These are generally files produced by loggers or a build
system, or some local settings for the project that shouldn't be shared across
other developers or maintainers. In such cases you can create a *.gitignore*
file. Here is the content of *.gitignore* used in current repository:

::

    # virtual environment
    /.venv/
    /.env/
    /venv/
    /env/

    # node packages
    /node_modules/

    # ide configs
    /.vscode/
    /.idea/

    # emacs cache and backup files
    \#*
    *~

    # temporary files storage
    /temp/
    /tmp/

    # documentation builds
    _builds/
    _build/
    builds/
    build/

    # translation object files
    *.pot
    *.mo

These lines mean:

-   Content within directories named ".venv", ".env", "venv" or "env"
    will be ignored completely.
-   Content within "node_modules" directory will be ignored completely.
-   Any files within directories named ".vscode" or ".idea" will be ignored
    completely.
-   Any file with name starting with hash (#) will be ignored.
-   Any file with name ending with tilda (~) will be ignored.
-   Content within directories named "temp" or "tmp" will be ignored
    completely.
-   Content within directories named "_builds", "_build", "builds" or
    "build" will be ignored completely.
-   Any file with name ending with ".pot" will be ignored.
-   Any file with name ending with ".mo" will be ignored.

Setting up a *.gitignore* file for your new repository before you get going is
generally a good idea so you don't accidentally commit files that you really
don't want in your Git repository.

The rules for the patterns you can put in the *.gitignore* file are as follows:

-   Blank lines or lines starting with # are ignored.
-   Standard glob patterns work, and will be applied recursively throughout
    the entire working tree.
-   You can start patterns with a forward slash (/) to avoid recursive
    inclusion.
-   You can end patterns with a forward slash (/) to specify a directory.
-   You can negate a pattern by starting it with an exclamation point (!).

Glob patterns are like simplified regular expressions that shells use.
An asterisk (\*) matches zero or more characters; [ab] matches any character
inside the brackets (in this case a or b); a question mark (?) matches
a single character; and brackets enclosing characters separated by a hyphen
([0-9]) matches any character between them (in this case 0 through 9).
You can also use two asterisks to match nested directories;
a/\*\*/z would match *a/z*, *a/b/z*, *a/b/c/z*, and so on.

.. todo:
    Committing changes

.. todo:
    Describe branching

.. todo:
    Describe merging and cherry-pick
