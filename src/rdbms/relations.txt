*******************************************************************************
                              Data Relationships
*******************************************************************************

It's time to talk about **data relations**.

For example your database contains two tables: ``weather`` and ``city``. The
diagram below demonstrates the overall data structure:

.. mermaid::
    :align: center

    erDiagram
        weather {
            string city
            int temp_lo
            int temp_hi
            date date
        }
        city {
            string name
            point location
        }

Consider the following problem: you want to make sure no one can insert
a record into ``weather`` without a matching entry in ``city`` table.
This is called maintaining the *referential integrity* of your data.
In simplistic database systems this would be implemented (if at all) by first
looking at the cities table to check if a matching record exists, and then
inserting or rejecting the new weather records. This approach has a number of
problems and is very inconvenient.

.. code-block:: sql

    CREATE TABLE city (
            name     varchar(80) primary key,
            location point
    );

    CREATE TABLE weather (
            city      varchar(80) references cities(name),
            temp_lo   int,
            temp_hi   int,
            date      date
    );

This declaration creates a relationship between two (or even more) tables.

Foreign key (FK)
===========

So far, you have knowledge about **primary** keys.
The **foreign** key is a column, that *references* some another table.
In common, it's a reference to another table's PK; but there is no limitation
of this kind, any column can be referenced by another one.
FKs handle data integrity only, it's not required for FK to be non-NULL value.

The relation's properties are described by CONSTRAINTS and the database's
structure.

For example, modifying declaration with ``NOT NULL`` constraint grants
that each record within a table has a matching one entity in another table.

.. code-block:: sql

    CREATE TABLE weather (
            city      varchar(80) references cities(name) NOT NULL,
            ...
    );

This brings us to various relationship models.

One-to-many relationship (1-to-N)
------------------------

This is the most common relationship.

For the example above there are no limitations on temperature measurements in
a specified city. So, a single city may has 0 or N related records in
``weather`` table. But each weather record is related to the only one city.

Another example is employees and office buildings they work in. Some big
company may have multiple offices and employee across the globe.
Multiple employees can be present in a single office building at a time.
But each employee can be physically located only in a single office at a time.

.. mermaid::

    erDiagram
        employee }o--|| office : located
        employee {
            int id
            string first_name
            string last_name
            email email
            int office_id fk
        }
        office {
            int id
            point location
            text address
        }

One-to-one relationship (1-to-1)
-----------------------

``UNIQUE`` and ``NOT NULL`` constraints are used together to ensure there is
and only one matching record. Back to the example with employees. Multiple
workstations (personal computers) are located in each office building.
The only one person can occupy the only one work station at a time.

.. mermaid::

    erDiagram
        employee ||--|| work_station : occupies

Many-to-many relationship (N-to-N)
-------------------------

These relationships require additional table.
A good example may be a *project role*. There are many of them in a production
team. And some employees may be assigned to the same role (e.g. developers,
testers etc.). But also a single person can be a developer and tester at
a time.

.. mermaid::

    erDiagram
        employee }o--|{ employee_role : execute
        role }o--|{ employee_role : assign

Joining data
============

``JOIN`` is used to *join* data fetched from multiple related tables.
To build a valid query you are to set the tables to join and parameter to use
for this operation.

Common syntax is:

::

    T1 join_type T2 [ join_condition ]

There are various join types available.
Here are is some dummy data to demonstrate their purpose.

.. table:: poem

    +----+------------------------+-----------+
    | id | title                  | author_id |
    +====+========================+===========+
    |  1 | On the Field of Battle | 1         |
    +----+------------------------+-----------+
    |  2 | Moses                  | 2         |
    +----+------------------------+-----------+
    |  3 | The Forest Song        | 1         |
    +----+------------------------+-----------+
    |  4 | In the Catacombs       | null      |
    +----+------------------------+-----------+
    |  5 | The Singing Stones     | 1         |
    +----+------------------------+-----------+
    |  6 | Ancient Fairy Tales    | null      |
    +----+------------------------+-----------+
    |  7 | My Thoughts            | 2         |
    +----+------------------------+-----------+
    |  8 | To Shevchenko          | null      |
    +----+------------------------+-----------+


.. table:: author

    +----+---------------+
    | id | name          |
    +====+===============+
    | 1  | Larysa Kosach |
    +----+---------------+
    | 2  | Ivan Franko   |
    +----+---------------+
    | 3  | John Doe      |
    +----+---------------+

.. code-block:: sql

    CREATE TABLE author
    (
        id   SERIAL PRIMARY KEY,
        name VARCHAR(32) NOT NULL UNIQUE
    );
    CREATE TABLE poem
    (
        id        SERIAL PRIMARY KEY,
        title     VARCHAR(32) NOT NULL UNIQUE,
        author_id INT REFERENCES author (id)
    );
    INSERT INTO author(name)
    VALUES ('Larysa Kosach'),
           ('Ivan Franko'),
           ('John Doe');
    INSERT INTO poem(title, author_id)
    VALUES ('On the Field of Battle', 1),
           ('Moses', 2),
           ('The Forest Song', 1),
           ('In the Catacombs', null),
           ('The Singing Stones', 1),
           ('Ancient Fairy Tales', null),
           ('My Thoughts', 2),
           ('To Shevchenko', null)
    ;

Join types
----------

:Cross join:

    .. code-block::

        T1 CROSS JOIN T2

    For every possible combination of rows from T1 and T2
    (i.e., a Cartesian product), the joined table will contain a row consisting
    of all columns in T1 followed by all columns in T2. If the tables have N
    and M rows respectively, the joined table will have N * M rows.

:Qualified joins:

    .. code-block::

        T1 { [INNER] | { LEFT | RIGHT | FULL } [OUTER] } JOIN T2 ON condition

    The words ``INNER`` and ``OUTER`` are optional for all forms.
    ``INNER`` is the default; ``LEFT``, ``RIGHT`` and ``FULL`` imply ``OUTER``
    join.

INNER JOIN
----------

For each row R1 of T1, the joined table has a row for each row in T2 that
satisfies the join condition with R1.

.. code-block:: sql
    :caption: Inner join

    SELECT p.title, a.name
    FROM poem p
             JOIN author a on p.author_id = a.id;

+------------------------+---------------+
| title                  | name          |
+========================+===============+
| On the Field of Battle | Larysa Kosach |
+------------------------+---------------+
| Moses                  | Ivan Franko   |
+------------------------+---------------+
| The Forest Song        | Larysa Kosach |
+------------------------+---------------+
| The Singing Stones     | Larysa Kosach |
+------------------------+---------------+
| My Thoughts            | Ivan Franko   |
+------------------------+---------------+

LEFT OUTER JOIN
---------------

First, an inner join is performed. Then, for each row in T1 that does not
satisfy the join condition with any row in T2, a joined row is added with null
values in columns of T2. Thus, the joined table always has at least one row for
each row in T1.

.. code-block:: sql
    :caption: Left join

    SELECT p.title, a.name
    FROM poem p
             LEFT JOIN author a on p.author_id = a.id;

+------------------------+---------------+
| title                  | name          |
+========================+===============+
| On the Field of Battle | Larysa Kosach |
+------------------------+---------------+
| Moses                  | Ivan Franko   |
+------------------------+---------------+
| The Forest Song        | Larysa Kosach |
+------------------------+---------------+
| In the Catacombs       | null          |
+------------------------+---------------+
| The Singing Stones     | Larysa Kosach |
+------------------------+---------------+
| Ancient Fairy Tales    | null          |
+------------------------+---------------+
| My Thoughts            | Ivan Franko   |
+------------------------+---------------+
| To Shevchenko          | null          |
+------------------------+---------------+

RIGHT OUTER JOIN
----------------

First, an inner join is performed. Then, for each row in T2 that does not
satisfy the join condition with any row in T1, a joined row is added with
null values in columns of T1. This is the converse of a left join: the result
table will always have a row for each row in T2.

.. code-block:: sql
    :caption: Right join

    SELECT p.title, a.name
    FROM poem p
             RIGHT JOIN author a on p.author_id = a.id;

+------------------------+---------------+
| title                  | name          |
+========================+===============+
| On the Field of Battle | Larysa Kosach |
+------------------------+---------------+
| Moses                  | Ivan Franko   |
+------------------------+---------------+
| The Forest Song        | Larysa Kosach |
+------------------------+---------------+
| The Singing Stones     | Larysa Kosach |
+------------------------+---------------+
| My Thoughts            | Ivan Franko   |
+------------------------+---------------+
| null                   | John Doe      |
+------------------------+---------------+

FULL OUTER JOIN
---------------

First, an inner join is performed. Then, for each row in T1 that does not
satisfy the join condition with any row in T2, a joined row is added with
null values in columns of T2. Also, for each row of T2 that does not satisfy
the join condition with any row in T1, a joined row with null values in
the columns of T1 is added.

.. code-block:: sql
    :caption: Full join

    SELECT p.title, a.name
    FROM poem p
             FULL JOIN author a on p.author_id = a.id;

+------------------------+---------------+
| title                  | name          |
+========================+===============+
| On the Field of Battle | Larysa Kosach |
+------------------------+---------------+
| Moses                  | Ivan Franko   |
+------------------------+---------------+
| The Forest Song        | Larysa Kosach |
+------------------------+---------------+
| In the Catacombs       | null          |
+------------------------+---------------+
| The Singing Stones     | Larysa Kosach |
+------------------------+---------------+
| Ancient Fairy Tales    | null          |
+------------------------+---------------+
| My Thoughts            | Ivan Franko   |
+------------------------+---------------+
| To Shevchenko          | null          |
+------------------------+---------------+
| null                   | John Doe      |
+------------------------+---------------+
