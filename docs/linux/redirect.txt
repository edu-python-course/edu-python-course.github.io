*******************************************************************************
                      Standard Streams and Their Workflow
*******************************************************************************

Introduction
============

The redirection capabilities built into Linux provide you with a robust set of
tools to optimize many workflows. The "Unix philosophy" of software development
was to make tools that each do one thing well, and this philosophy has been
carried forward to modern command-line tools, which are individually powerful,
and exponentially more so when combined. Whether you're writing complex
software or just working on the command line, knowing how to manipulate the
different :abbr:`I/O(Input/Output)` streams in your environment will greatly
increase your productivity.

Streams
=======

Input and output in the Linux environment is distributed across 3 *streams*:

- **standard input**   ``stdin``
- **standard output**  ``stdout``
- **standard error**   ``stderr``

which are also numbered: 0 for *stdin*, 1 for *stdout* and 2 for *stderr*.

The standard input comes from user's keyboard during a standard interactions
between the user and the terminal. Standard output and standard error are
displayed on the terminal as text.

Standard Input
==============

The standard input stream typically carries data from a user to a program.
Program that expect standard input usually receive input from a device, such
as a keyboard. But also programs interact with each other, using one's program
output as an input to another.

Standard Output
===============

Standard output is the output that generated by a program. When the standard
output stream is not redirected, it will output text directly to the terminal.
You can output some arbitrary text, using ``echo``:

.. code-block:: bash

    echo Output to the terminal

When used without any additional options, the ``echo`` command outputs any
argument that is passed to it on the command line.

Standard Error
==============

Standard error contains errors generated by a program that has failed in some
way. Like standard output, the default destination for this stream is
the terminal display.

For example, trying to list files in a non-existing directory will generate
an error reported back to the terminal.

.. code-block:: bash

    ls non-existing-directory

::

    ls: cannot access 'not-existing-directory': No such file or directory

A program does not have to crash or finish running in order to generate
the Standard Error, and whether some output is sent to either Standard Output
or Standard Error is down to the behavior of the program.

Standard Output and Standard Error are not technically different from one
another - just this stream is supposed to be reserved for error messages, and
some tools will assume that Standard Error being empty means that a program ran
successfully. Some program can even output minor errors to stderr without
crashing or failing to also produce the intended output.

Stream Redirection
==================

Linux includes redirection commands for each stream. These can be used to write
standard output (or error) to a file. If you write to a file that does not
exist, a new file with that name will be created prior to writing.

Commands with a single angle bracket *overwrite* the destination's existing
contents; commands with a double angle bracket will *append* the destination's
existing contents.

**Overwrite**

- ``>``   - standard output
- ``<``   - standard input
- ``2>``  - standard error

**Append**

- ``>>``  - standard output
- ``<<``  - standard input
- ``2>>`` - standard error

For example, let assume a text file called "names.txt" with content:

::

    Alex
    Serhii
    Vladyslav
    Roman
    Serhii
    Dmytro
    Roman

The ``sort`` program will output the file's content sorted by the alphabet.
And trying to pass some non-existing file to the same program will cause
an error.

.. code-block:: bash

    sort names.txt > sorted_names.txt  # redirect stdout to sorted_names file
    sort non-existing-file.txt 2>> errors.txt  # redirect errors

Pipes
=====

Pipes are used to redirect a stream from one program to another.
When a program's standard output is sent to another through a pipe, the first
program's output will be used as input to the second, rather than being printed
to the terminal. Only the data returned by the second program will be displayed
to the user.

The Linux *pipe* is represented by a vertical bar: ``|``.

The example file from the previous section can be sorted and cleared from
the duplicated names using two commands: ``sort`` and ``uniq``.

.. code-block:: bash

    sort names.txt > sorted_names.txt       # sort and write a file
    uniq sorted_names.txt > uniq_names.txt  # clean from the duplicates

    # the same process using pipes
    sort names.txt | uniq > uniq_names.txt

Of course, you can merge as many programs as you need using pipes.

Conclusion
==========

Learning how to use the redirection capabilities built into the Linux command
line is a crucial skill. Now that you have seen the basics of how redirections
and pipes work, you'll be able to begin your journey into the world of shell
scripting, which makes frequent use of the programs and patterns highlighted
in this guide.
